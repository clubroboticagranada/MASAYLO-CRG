{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"MASAYLO - CRG \u00b6 MASAYLO-CRG es un robot creado a partir de la idea de Antonio G\u00f3mez ( https://github.com/agomezgar/masaylo ) del que se van a desarrollar las tres versiones que se exponen a continuaci\u00f3n MASAYLO-CRG-UNO \u00b6 Esta versi\u00f3n, basada en la placa Keyestudio UNO est\u00e1 pensada para que el alumnado de los \u00faltimos cursos de primaria y los del primer ciclo de ESO trabajen los temas STEAM. En la imagen siguiente vemos el aspecto que presenta el robot MASAYLO-CRG-UNO en fase de dise\u00f1o. La programaci\u00f3n de este modelo la podemos realizar a partir del IDE de Arduino (instalando la librer\u00eda correspondiente) o a partir del entorno gr\u00e1fico MASAYLOBLOCKLY. Aspecto general de MASAYLO-CRG-UNO MASAYLO-CRG-NANO \u00b6 Se trata de un modelo totalmente similar al anterior pero que en esta ocasi\u00f3n va a utilizar una placa tipo Arduino Nano con una shield que permite tambi\u00e9n disponer de pines de conexionado r\u00e1pido. En la imagen de la izquierda vemos la placa y en la de la derecha la shield. El aspecto del robot una vez montado es totalmente similar al de la imagen anterior con la salvedad del cambio de placa. Aspecto placa Nano Aspecto de la shield para placa Nano MASAYLO-CRG-IoT \u00b6 En este caso el modelo se implementa a partir de una placa Node MCU ESP32 con shield que incluye los drivers para motores. Este modelo se dirige a los \u00faltimos cursos de ESO, bachillerato y Ciclos Formativos y su principal objetivo, sin dejar atr\u00e1s la sencillez del robot, es trabajar, adem\u00e1s de los temas STEAM, el Internet Of Thing (IoT) o internet de las cosas. B\u00e1sicamente el robot va dotado de conexi\u00f3n WiFi con todo lo que ello conlleva. La idea principal es poder programarlo a partir de un entorno de programaci\u00f3n por bloques, poder desarrollar APPs para m\u00f3viles o tablets para su control a partir de un entorno gr\u00e1fico como Blocky, montando nuestro propio servidor para tal fin. Otro objetivo de este robot es poder realizar colaboraciones a distancia consistentes en, por ejemplo, ejercer el control de un robot situado en cualquier parte del mundo desde el lugar en el que el alumnado est\u00e1 trabajando con la APP. En la imagen siguiente a la izquierda vemos el aspecto de la placa ESP32 y a la derecha el de la shield. El aspecto del robot una vez montado es totalmente similar al montado para la versi\u00f3n UNO con la salvedad del cambio de placa y que el driver de motores est\u00e1 integrado en la shield. Aspecto placa Node MCU ESP32 de 30 pines Aspecto de la shield para placa ESP32 El prop\u00f3sito principal es que sea un robot sencillo de imprimir y de construir y que pueda servir para iniciar en el tema STEAM al alumnado desde los \u00faltimos cursos de educaci\u00f3n primaria hasta bachillerato y ciclos formativos pasando por las distintas etapas de la ESO. Se ha pretendido que los dise\u00f1os 3D sean f\u00e1cilmente imprimibles, sin necesidad de soportes y aconsejamos una altura de capa de 0.2mm. Se ha procurado que los tiempos de impresi\u00f3n sean lo m\u00e1s cortos posible pero al mismo tiempo vers\u00e1tiles para las posibles diferencias entre las distintas placas a utilizar. En el apartado de descripci\u00f3n del hardware se pondr\u00e1n algunos enlaces recomendados para adquisici\u00f3n del material aunque, como no pod\u00eda ser de otra manera, cada quien lo puede adquirir donde mejor le parezca. Cualquiera de los modelos puede ser utilizado para otra etapa formativa u objetivo y lo podremos adaptar a nuestras necesidades, siendo esto posible porque se suministran los archivos fuente de dise\u00f1o y programaci\u00f3n y para ello solamente tenemos que cumplir con los requisitos establecidos en las licencias .","title":"Introducci\u00f3n"},{"location":"#masaylo-crg","text":"MASAYLO-CRG es un robot creado a partir de la idea de Antonio G\u00f3mez ( https://github.com/agomezgar/masaylo ) del que se van a desarrollar las tres versiones que se exponen a continuaci\u00f3n","title":"MASAYLO - CRG"},{"location":"#masaylo-crg-uno","text":"Esta versi\u00f3n, basada en la placa Keyestudio UNO est\u00e1 pensada para que el alumnado de los \u00faltimos cursos de primaria y los del primer ciclo de ESO trabajen los temas STEAM. En la imagen siguiente vemos el aspecto que presenta el robot MASAYLO-CRG-UNO en fase de dise\u00f1o. La programaci\u00f3n de este modelo la podemos realizar a partir del IDE de Arduino (instalando la librer\u00eda correspondiente) o a partir del entorno gr\u00e1fico MASAYLOBLOCKLY. Aspecto general de MASAYLO-CRG-UNO","title":"MASAYLO-CRG-UNO"},{"location":"#masaylo-crg-nano","text":"Se trata de un modelo totalmente similar al anterior pero que en esta ocasi\u00f3n va a utilizar una placa tipo Arduino Nano con una shield que permite tambi\u00e9n disponer de pines de conexionado r\u00e1pido. En la imagen de la izquierda vemos la placa y en la de la derecha la shield. El aspecto del robot una vez montado es totalmente similar al de la imagen anterior con la salvedad del cambio de placa. Aspecto placa Nano Aspecto de la shield para placa Nano","title":"MASAYLO-CRG-NANO"},{"location":"#masaylo-crg-iot","text":"En este caso el modelo se implementa a partir de una placa Node MCU ESP32 con shield que incluye los drivers para motores. Este modelo se dirige a los \u00faltimos cursos de ESO, bachillerato y Ciclos Formativos y su principal objetivo, sin dejar atr\u00e1s la sencillez del robot, es trabajar, adem\u00e1s de los temas STEAM, el Internet Of Thing (IoT) o internet de las cosas. B\u00e1sicamente el robot va dotado de conexi\u00f3n WiFi con todo lo que ello conlleva. La idea principal es poder programarlo a partir de un entorno de programaci\u00f3n por bloques, poder desarrollar APPs para m\u00f3viles o tablets para su control a partir de un entorno gr\u00e1fico como Blocky, montando nuestro propio servidor para tal fin. Otro objetivo de este robot es poder realizar colaboraciones a distancia consistentes en, por ejemplo, ejercer el control de un robot situado en cualquier parte del mundo desde el lugar en el que el alumnado est\u00e1 trabajando con la APP. En la imagen siguiente a la izquierda vemos el aspecto de la placa ESP32 y a la derecha el de la shield. El aspecto del robot una vez montado es totalmente similar al montado para la versi\u00f3n UNO con la salvedad del cambio de placa y que el driver de motores est\u00e1 integrado en la shield. Aspecto placa Node MCU ESP32 de 30 pines Aspecto de la shield para placa ESP32 El prop\u00f3sito principal es que sea un robot sencillo de imprimir y de construir y que pueda servir para iniciar en el tema STEAM al alumnado desde los \u00faltimos cursos de educaci\u00f3n primaria hasta bachillerato y ciclos formativos pasando por las distintas etapas de la ESO. Se ha pretendido que los dise\u00f1os 3D sean f\u00e1cilmente imprimibles, sin necesidad de soportes y aconsejamos una altura de capa de 0.2mm. Se ha procurado que los tiempos de impresi\u00f3n sean lo m\u00e1s cortos posible pero al mismo tiempo vers\u00e1tiles para las posibles diferencias entre las distintas placas a utilizar. En el apartado de descripci\u00f3n del hardware se pondr\u00e1n algunos enlaces recomendados para adquisici\u00f3n del material aunque, como no pod\u00eda ser de otra manera, cada quien lo puede adquirir donde mejor le parezca. Cualquiera de los modelos puede ser utilizado para otra etapa formativa u objetivo y lo podremos adaptar a nuestras necesidades, siendo esto posible porque se suministran los archivos fuente de dise\u00f1o y programaci\u00f3n y para ello solamente tenemos que cumplir con los requisitos establecidos en las licencias .","title":"MASAYLO-CRG-IoT"},{"location":"ensamble-s/","text":"Materiales necesarios y ensamblado plataforma superior \u00b6 Plataforma superior \u00b6 En esta pieza es donde vamos a colocar el servo para el brazo aparta objetos y los elementos de electr\u00f3nica correspondientes a cada versi\u00f3n. El brazo lo podemos colocar tanto a la derecha como a la izquierda y recordemos que de forma opcional podemos poner tambi\u00e9n el soporte del zumbador o un sensor fijo de ultrasonidos. El aspecto de la pieza denominada plataforma superior lo vemos en la imagen siguiente. Plataforma superior en fase de dise\u00f1o Plataforma superior Brazo aparta objetos \u00b6 Se trata de una especie de gancho accionado por un servo SG-90 que nos va a servir para apartar objetos detectados por el sensor HC-SR04 del camino o trayectoria a seguir. La idea es que el brazo estar\u00e1 normalmente replegado hacia las ruedas y que, cuando vamos siguiendo una l\u00ednea o resolviendo un laberinto o simplemente desplaz\u00e1ndonos con el robot y detectamos enfrente un objeto del tama\u00f1o de una lata de refresco, se accione el brazo para envolverlo, el robot realice un giro arrastrando el objeto fuera de su trayectoria, posteriormente deshaga el giro, retraiga el brazo y continue su camino. El aspecto del brazo en fase de dise\u00f1o e impreso lo vemos en la imagen siguiente. Brazo en fase de dise\u00f1o Brazo impreso P7. Brazo aparta objetos Im\u00e1genes Necesitamos: - 1 brazo impreso - 1 soporte para servo impreso - 1 pala de un brazo para el servo - 1 tornillo de rosca chapa de los que vienen con el servo - 1 servo SG-90 - 2 tornillos M2x10mm - 2 tuercas M2 - 2 tornillos M3x10mm - 2 tuercas M3 Montamos el servo en su soporte y lo sujetamos con los tornillos M2x10. Colocamos la pala en el alojamiento del brazo y atornillamos este conjunto al servo con el tornillo de rosca chapa. El conjunto anterior lo montamos sobre la plataforma superior en el lugar escogido para ello que deber\u00e1 estar lo mas cercano posible a la parte delantera del robot si imprimimos el brazo a su tama\u00f1o original. En las im\u00e1genes vemos el aspecto de las piezas tanto en fase de dise\u00f1o como impresas \u2192 Es conveniente realizar el posicionamiento del engranaje del servo de forma adecuada antes de continuar. Teniendo en cuenta que el servo puede girar 180\u00ba colocamos el engranaje con la mano o con ayuda de una de las palas del servo en tal posici\u00f3n que permita el movimiento correcto del brazo o del sensor de ultrasonidos. En las imagenes siguientes vemos la plataforma superior con el brazo colocado. Plataforma superior con brazo en fase de dise\u00f1o Plataforma superior con brazo Interruptor, Placa UNO y driver motores \u00b6 Introducimos el interruptor en el orificio rectangular de la plataforma superior destinado para ello y ejerciendo un poco de presi\u00f3n lo encajamos en su lugar. P8. Placa UNO y driver motores Im\u00e1genes Necesitamos: - 7 separadores M3x5mm impresos - 7 tornillos M3x12mm - 7 tuercas M3 - 1 placa UNO con pines extendidos - 1 placa driver de motores L298 Utilizando separadores M3x5mm impresos y tornillos M3x12mm con sus tuercas, colocamos tanto la placa UNO como la placa de drivers en su lugar, que con el interruptor ya colocado nos deja la plataforma superior acabada. En la im\u00e1gen vemos el aspecto del separador en fase de dise\u00f1o \u2192 En la imagen siguiente vemos la plataforma superior en el estado actual. Plataforma superior finalizada en fase de dise\u00f1o Ensamble de las dos plataformas \u00b6 P9. Ensamble de las dos plataformas Im\u00e1genes Necesitamos: - 4 separadores M3x28mm impresos - 4 tornillos M3x40mm - 4 tuercas M3 Utilizando los separadores M3x28mm impresos y tornillos M3x40mm con sus tuercas, sujetamos la plataforma superior a la inferior. En la im\u00e1gen vemos el aspecto del separador en fase de dise\u00f1o \u2192 En la imagen siguiente vemos las dos plataformas montadas. Plataformas superior e inferior montadas en fase de dise\u00f1o Plataformas superior e inferior montadas Sensores de ranura \u00b6 El \u00faltimo paso a realizar es colocar los sensores de ranura sujetos a la plataforma superior y alineados con los discos ranurados de forma que estos giren libremente. P10. Sensores de ranura Necesitamos: - 2 sensores de ranura - 2 tornillos M3x10mm - 2 tuercas M3 - 2 arandelas M3 Sujetamos ambos sensores en su lugar. En las imagenes siguientes vemos en detalle el aspecto de estos sensores montados en su lugar. Sensores de ranura en fase de dise\u00f1o Sensores de ranura montados Aspecto final del robot \u00b6 Una vez finalizado el montaje de todos los elementos el robot presenta, en fase de dise\u00f1o, el aspecto que vemos en las im\u00e1genes siguientes. Robot ensamblado en fase de dise\u00f1o Robot ensamblado en fase de dise\u00f1o sobre el soporte de pruebas En las im\u00e1genes siguientes vemos el robot con el ensamblado finalizado. Robot ensamblado Robot ensamblado En la imagen siguiente vemos el robot ensamblado colocado sobre el soporte de pruebas listo para comenzar el conexionado y pruebas del montaje. Robot ensamblado sobre su soporte","title":"Materiales necesarios y ensamblado plataforma superior"},{"location":"ensamble-s/#materiales-necesarios-y-ensamblado-plataforma-superior","text":"","title":"Materiales necesarios y ensamblado plataforma superior"},{"location":"ensamble-s/#plataforma-superior","text":"En esta pieza es donde vamos a colocar el servo para el brazo aparta objetos y los elementos de electr\u00f3nica correspondientes a cada versi\u00f3n. El brazo lo podemos colocar tanto a la derecha como a la izquierda y recordemos que de forma opcional podemos poner tambi\u00e9n el soporte del zumbador o un sensor fijo de ultrasonidos. El aspecto de la pieza denominada plataforma superior lo vemos en la imagen siguiente. Plataforma superior en fase de dise\u00f1o Plataforma superior","title":"Plataforma superior"},{"location":"ensamble-s/#brazo-aparta-objetos","text":"Se trata de una especie de gancho accionado por un servo SG-90 que nos va a servir para apartar objetos detectados por el sensor HC-SR04 del camino o trayectoria a seguir. La idea es que el brazo estar\u00e1 normalmente replegado hacia las ruedas y que, cuando vamos siguiendo una l\u00ednea o resolviendo un laberinto o simplemente desplaz\u00e1ndonos con el robot y detectamos enfrente un objeto del tama\u00f1o de una lata de refresco, se accione el brazo para envolverlo, el robot realice un giro arrastrando el objeto fuera de su trayectoria, posteriormente deshaga el giro, retraiga el brazo y continue su camino. El aspecto del brazo en fase de dise\u00f1o e impreso lo vemos en la imagen siguiente. Brazo en fase de dise\u00f1o Brazo impreso P7. Brazo aparta objetos Im\u00e1genes Necesitamos: - 1 brazo impreso - 1 soporte para servo impreso - 1 pala de un brazo para el servo - 1 tornillo de rosca chapa de los que vienen con el servo - 1 servo SG-90 - 2 tornillos M2x10mm - 2 tuercas M2 - 2 tornillos M3x10mm - 2 tuercas M3 Montamos el servo en su soporte y lo sujetamos con los tornillos M2x10. Colocamos la pala en el alojamiento del brazo y atornillamos este conjunto al servo con el tornillo de rosca chapa. El conjunto anterior lo montamos sobre la plataforma superior en el lugar escogido para ello que deber\u00e1 estar lo mas cercano posible a la parte delantera del robot si imprimimos el brazo a su tama\u00f1o original. En las im\u00e1genes vemos el aspecto de las piezas tanto en fase de dise\u00f1o como impresas \u2192 Es conveniente realizar el posicionamiento del engranaje del servo de forma adecuada antes de continuar. Teniendo en cuenta que el servo puede girar 180\u00ba colocamos el engranaje con la mano o con ayuda de una de las palas del servo en tal posici\u00f3n que permita el movimiento correcto del brazo o del sensor de ultrasonidos. En las imagenes siguientes vemos la plataforma superior con el brazo colocado. Plataforma superior con brazo en fase de dise\u00f1o Plataforma superior con brazo","title":"Brazo aparta objetos"},{"location":"ensamble-s/#interruptor-placa-uno-y-driver-motores","text":"Introducimos el interruptor en el orificio rectangular de la plataforma superior destinado para ello y ejerciendo un poco de presi\u00f3n lo encajamos en su lugar. P8. Placa UNO y driver motores Im\u00e1genes Necesitamos: - 7 separadores M3x5mm impresos - 7 tornillos M3x12mm - 7 tuercas M3 - 1 placa UNO con pines extendidos - 1 placa driver de motores L298 Utilizando separadores M3x5mm impresos y tornillos M3x12mm con sus tuercas, colocamos tanto la placa UNO como la placa de drivers en su lugar, que con el interruptor ya colocado nos deja la plataforma superior acabada. En la im\u00e1gen vemos el aspecto del separador en fase de dise\u00f1o \u2192 En la imagen siguiente vemos la plataforma superior en el estado actual. Plataforma superior finalizada en fase de dise\u00f1o","title":"Interruptor, Placa UNO y driver motores"},{"location":"ensamble-s/#ensamble-de-las-dos-plataformas","text":"P9. Ensamble de las dos plataformas Im\u00e1genes Necesitamos: - 4 separadores M3x28mm impresos - 4 tornillos M3x40mm - 4 tuercas M3 Utilizando los separadores M3x28mm impresos y tornillos M3x40mm con sus tuercas, sujetamos la plataforma superior a la inferior. En la im\u00e1gen vemos el aspecto del separador en fase de dise\u00f1o \u2192 En la imagen siguiente vemos las dos plataformas montadas. Plataformas superior e inferior montadas en fase de dise\u00f1o Plataformas superior e inferior montadas","title":"Ensamble de las dos plataformas"},{"location":"ensamble-s/#sensores-de-ranura","text":"El \u00faltimo paso a realizar es colocar los sensores de ranura sujetos a la plataforma superior y alineados con los discos ranurados de forma que estos giren libremente. P10. Sensores de ranura Necesitamos: - 2 sensores de ranura - 2 tornillos M3x10mm - 2 tuercas M3 - 2 arandelas M3 Sujetamos ambos sensores en su lugar. En las imagenes siguientes vemos en detalle el aspecto de estos sensores montados en su lugar. Sensores de ranura en fase de dise\u00f1o Sensores de ranura montados","title":"Sensores de ranura"},{"location":"ensamble-s/#aspecto-final-del-robot","text":"Una vez finalizado el montaje de todos los elementos el robot presenta, en fase de dise\u00f1o, el aspecto que vemos en las im\u00e1genes siguientes. Robot ensamblado en fase de dise\u00f1o Robot ensamblado en fase de dise\u00f1o sobre el soporte de pruebas En las im\u00e1genes siguientes vemos el robot con el ensamblado finalizado. Robot ensamblado Robot ensamblado En la imagen siguiente vemos el robot ensamblado colocado sobre el soporte de pruebas listo para comenzar el conexionado y pruebas del montaje. Robot ensamblado sobre su soporte","title":"Aspecto final del robot"},{"location":"ensamble/","text":"Materiales necesarios y ensamblado plataforma base \u00b6 Vamos a realizar el paso a paso de montaje del robot utilizando para ellos la versi\u00f3n MASAYLO-CRG-UNO . El montaje de las otras versiones es totalmente similar y la \u00fanica diferencia va a estar en la placa de control teniendo la plataforma superior habilitados orificios para las distintas placas. En cada uno de los pasos iremos indicando los materiales necesarios para su consecuci\u00f3n. Las herramientas necesarias para llevar a cabo el proceso van a depender del tipo de cabeza de tornillo que utilicemos, pero en cualquier caso necesitaremos destornilladores adecuados y unos alicates de punta plana por si es necesario sujetar alg\u00fan tornillo. Para los motores y el interruptor necesitaremos unos trozos de cable de distintos colores (rojo y negro a ser posible para distinguir bien la alimentaci\u00f3n) de entre 10 y 15 cm de longitud. Estos cables ir\u00e1n directamente soldados a las patillas correspondientes de los motores y del interruptor. En el apartado correspondiente se detalla el proceso. Motores, Portapilas e interruptor \u00b6 P0. Motores Im\u00e1genes Si partimos de la base que los motores no vienen ya preinstalados con cables, necesitamos: - 2 motores DC de 3 a 6V con reductora - 4 trozos de hilos de diferentes colores - Tijeras o pelacables - Soldador para electr\u00f3nica - Se aconseja usar esta\u00f1o de 1mm sin plomo con n\u00facleo de resina y composici\u00f3n del 99% de Sn, 0.3% de Ag y 0.7% de Cu En la imagen vemos los motores y los cables sin soldar \u2192 En la imagen vemos los motores con los cables soldados \u2192 P0. Portapilas Im\u00e1genes Lo ideal es adquirirlo con los cables ya instalados, aunque existen otras opciones que tendremos que analizar en cada caso. Para este paso necesitamos - 1 portapilas 5xAA Aunque sobresaldr\u00e1 un poco por los laterales tambi\u00e9n nos puede valer un portapilas 6xAA En la imagen vemos el portapilas preparado con los cables \u2192 P0. Interruptor Im\u00e1genes Necesitamos: - 1 mini interruptor basculante de 2 Pines tipo SPST de 10.5x15mm - 2 trozos de hilos de diferentes colores, idealmente rojo y negro, para mantener el est\u00e1ndar de colores de alimentaci\u00f3n Debemos tener presente que con los cables soldados y la forma de colocaci\u00f3n del interruptor (por presi\u00f3n en la plataforma superior) no podemos tener realizadas las conexiones a priori, es mas interesante realizar estas conexiones mediante, por ejemplo una clema, que permite un montaje c\u00f3modo y que podemos quitar si es necesario en el futuro. En la imagen tenemos el interruptor preparado para la instalaci\u00f3n \u2192 Plataforma base \u00b6 En fase de dise\u00f1o el aspecto de la plataforma base lo vemos en la imagen siguiente. P1. Plataforma base Im\u00e1genes Necesitamos: - 1 plataforma base impresa - 1 portapilas - 2 motores DC de 3 a 6V con reductora ya cableados - 2 tornillos M3x8mm de cabeza avellanada - 4 tornillos M3x30mm - 6 tuercas M3 En la imagen vemos el aspecto de la plataforma base una vez impresa \u2192 Sujetamos el portapilas a la base utilizando los dos tornillos M3x8 y dos tuercas. Debe queda como observamos en la imagen quedando el portapilas bajo la base \u2192 Utilizando dos tornillos M3x30 y dos tuercas por cada motor los colocamos y atornillamos a la plataforma base, teniendo cuidado de que los motores queden bien pegados a la base. La posici\u00f3n exacta de los motores viene determinada por los orificios existentes en su carcasa y las ranuras de las pesta\u00f1as verticales de la pieza impresa, que deben quedar alineadas. En esta etapa es conveniente, tal y como se aprecia en la im\u00e1gen, que el disco perforado del encoder est\u00e9 situado en el eje del motor y que este quede mas o menos centrado en la ranura de la base. En la imagen vemos como debe quedar \u2192 En las im\u00e1genes siguientes vemos los pasos anteriores en fase de dise\u00f1o Plataforma base con portapilas Plataforma base con motores Opci\u00f3n zumbador pasivo \u00b6 Podemos optar por colocar el zumbador pasivo en la plataforma base o bien colocarlo en la plataforma superior. A continuaci\u00f3n vemos el aspecto de la pieza en fase de dise\u00f1o. P2. Zumbador pasivo Im\u00e1genes Necesitamos: - 1 soporte para buzzer impreso - 1 zumbador pasivo - 2 tornillos M3x8mm - 2 tuercas M3 - 2 cables tipo dupont H-H de 20 cm En la imagen vemos el aspecto de la pieza impresa \u2192 En la imagen siguiente vemos la plataforma base con el soporte para zumbador colocado en su lugar, tanto en fase de dise\u00f1o como en la realidad. Plataforma base con buzzer en fase de dise\u00f1o Plataforma base con buzzer Ballcaster y porta sensores IR \u00b6 En realidad esta pieza podr\u00eda ser una solamente pero se ha dividido en dos para evitar el uso de soportes en la impresi\u00f3n. El aspecto en fase de dise\u00f1o de ambas piezas lo vemos en las imagenes siguientes: | | | P3. Ballcaster y porta sensores de infrarrojos Im\u00e1genes Necesitamos: - 1 ballcaster impreso - 1 portasensores IR impreso - 2 tornillos M3x8mm - 4 tornillos M3x10mm - 6 tuercas M3 - 2 sensores IR de distancia ajustable detecci\u00f3n 2 a 30cm - 6 cables tipo dupont H-H de 20 cm Colocamos y atornillamos los sensores IR con los tornillos M3x8. Empotramos dos tuerca M3 en la pieza ballcaster y colocamos esta pieza en la parte posterior del porta sensores alineando con los agujeros inferiores y atornillando con dos tornillos M3x10. Finalmente atornillamos el conjunto a la plataforma base utilizando dos tornillos M3x10 y alineando con los agujeros centrales de la base en la parte que muestra un trozo plano En la imagen vemos el aspecto del conjunto montado sobre las piezas impresas \u2192 En la imagen siguiente vemos la plataforma base con el soporte para sensores de infrarrojos y Ballcaster colocados en su lugar, tanto en fase de dise\u00f1o como en la fase montaje real. Plataforma base con sensor IR en fase de dise\u00f1o Plataforma base con sensor IR Ruedas \u00b6 Nuestra propuesta va a incluir tres dise\u00f1os que van a tener como diferencia el n\u00famero y la posici\u00f3n de juntas t\u00f3ricas. Las ruedas van a tener un radio exterior de 38 mm con una ranura que permite alojar una junta t\u00f3rica de 75 mm de di\u00e1metro exterior y secci\u00f3n transversal de 3mm de di\u00e1metro. En la imagen siguiente vemos a la izquierda el modelo para dos juntas con separaci\u00f3n de 10 mm entre ambas, en el centro la de una sola con la junta colocada y a la derecha tenemos el modelo de dos juntas sin distancia entre las mismas. Observamos como los dise\u00f1os interiores de las ruedas son iguales en cuanto a geometr\u00eda e indicaremos que el n\u00famero y la posici\u00f3n de las juntas se establece para dar soluci\u00f3n a las diferentes adherencias de superficies y evitar en lo posible que las ruedas derrapen cuando giran. El orificio con la forma del eje del motor est\u00e1 dimensionado para que la rueda quede bien acoplada simplemente presionando sobre el eje, pero somos conscientes de que las impresoras 3D tienen ciertas tolerancias y no todas van a darnos exactamente las mismas dimensiones, por ello hemos previsto la posibilidad de realizar la sujeci\u00f3n mediante tornillo que ejerza presi\u00f3n contra el eje del motor y tuerca empotrada en el cilindro de la rueda. Este paso de montaje va a depender de la opci\u00f3n escogida y de si usamos o no tornillo prisionero. P4. Ruedas Im\u00e1genes Necesitamos: - 2 ruedas impresas del modelo escogido - 2 (o 4) juntas t\u00f3ricas de 75x3mm - 2 tornillos M3x10mm - 2 tuercas M3 Colocamos haciendo presi\u00f3n si es necesario una rueda en cada eje de motor. Si es necesario porque el encaje anterior tiene holgura, empotramos una tuerca M3 en cada rueda y fijamos la posici\u00f3n de la rueda utilizando el tornillo prisionero. En la imagen inferior vemos el detalle del tornillo prisionero. En la imagen vemos el aspecto del conjunto montado con las ruedas de una junta \u2192 En las imagenes siguientes vemos la plataforma base con cada tipo de ruedas en fase de dise\u00f1o. Plataforma base con ruedas una junta Plataforma base con ruedas dos juntas Plataforma base con ruedas dos juntas separadas Soporte para servo SG-90 \u00b6 En esta pieza es donde colocamos y atornillamos el servo motor tanto para el brazo aparta objetos como para el sensor de ultrasonidos m\u00f3vil. Si vamos a optar por la opci\u00f3n de ultrasonidos fijo solamente debemos montar un servo pero si optamos por la opci\u00f3n con sensor de ultrasonidos m\u00f3vil debemos montar dos conjuntos. P5. Servo SG-90 Im\u00e1genes Necesitamos: - 1 (o 2) soporte para servo impreso - 1 (o 2) servomotores SG-90 - 2 (o 4) tornillos M2x10mm - 2 (o 4) tuercas M2 Colocamos el servo en la pieza y lo sujetamos utilizando los tornillos M2x10. En las im\u00e1genes vemos el aspecto de la pieza tanto en fase de dise\u00f1o como impresa \u2192 Es conveniente realizar el posicionamiento del engranaje del servo de forma adecuada antes de continuar. Teniendo en cuenta que el servo puede girar 180\u00ba colocamos el engranaje con la mano o con ayuda de una de las palas del servo en tal posici\u00f3n que permita el movimiento correcto del brazo o del sensor de ultrasonidos. En las imagenes siguientes vemos el soporte con el servo colocado. Portaservo con servo en fase de dise\u00f1o Portaservo impreso con servo Soporte sensor de ultrasonidos HC-SR04 \u00b6 Tenemos dos opciones disponibles, un soporte fijo que podemos colocar tanto en la parte superior del porta sensores IR o utilizando alguna de las ranuras de las plataformas superior o inferior, y un soporte m\u00f3vil accionado por un servo pensado para colocarlo a modo de cabeza giratoria tambi\u00e9n en la parte superior del porta sensores de IR. En ambos casos el sensor se coloca presionando ligeramente para que encaje en las pesta\u00f1as del porta sensores. En las im\u00e1genes siguientes tenemos ambos tipos de soportes tanto en modo dise\u00f1o como impresos. Porta HC-SR04 fijo fase dise\u00f1o Porta HC-SR04 fijo impreso Porta HC-SR04 m\u00f3vil fase dise\u00f1o Porta HC-SR04 m\u00f3vil impreso P6. Sensor de ultrasonidos HC-SR04 Im\u00e1genes Necesitamos: - 1 soporte fijo para sensor HC-SR04 impreso - 1 soporte m\u00f3vil para sensor HC-SR04 impreso - 1 (o 2) pala de un brazo para el servo - 1 (o 2) tornillos de rosca chapa de los que vienen con el servo - 1 servo montado en su soporte - 2 tornillos M3x10mm - 2 tuercas M3 Colocamos el sensor de ultrasonidos en su alojamiento en el soporte fijo o m\u00f3vil elegido. Si hemos escogido soporte fijo sujetamos este con dos tornillos M3x10 en el lugar escogido y si hemos escogido el soporte m\u00f3vil sujetamos el soporte del sensor al servo con el tornillo de rosca chapa colocando la pala en la cabeza del servo. En las im\u00e1genes vemos el aspecto de las piezas tanto en fase de dise\u00f1o como impresas \u2192 Es conveniente realizar el posicionamiento del engranaje del servo de forma adecuada antes de continuar. Teniendo en cuenta que el servo puede girar 180\u00ba colocamos el engranaje con la mano o con ayuda de una de las palas del servo en tal posici\u00f3n que permita el movimiento correcto del brazo o del sensor de ultrasonidos. En las imagenes siguientes vemos la plataforma base finalizada con todas sus opciones colocadas. Plataforma base finalizada en fase de dise\u00f1o Plataforma base finalizada","title":"Materiales necesarios y ensamblado plataforma base"},{"location":"ensamble/#materiales-necesarios-y-ensamblado-plataforma-base","text":"Vamos a realizar el paso a paso de montaje del robot utilizando para ellos la versi\u00f3n MASAYLO-CRG-UNO . El montaje de las otras versiones es totalmente similar y la \u00fanica diferencia va a estar en la placa de control teniendo la plataforma superior habilitados orificios para las distintas placas. En cada uno de los pasos iremos indicando los materiales necesarios para su consecuci\u00f3n. Las herramientas necesarias para llevar a cabo el proceso van a depender del tipo de cabeza de tornillo que utilicemos, pero en cualquier caso necesitaremos destornilladores adecuados y unos alicates de punta plana por si es necesario sujetar alg\u00fan tornillo. Para los motores y el interruptor necesitaremos unos trozos de cable de distintos colores (rojo y negro a ser posible para distinguir bien la alimentaci\u00f3n) de entre 10 y 15 cm de longitud. Estos cables ir\u00e1n directamente soldados a las patillas correspondientes de los motores y del interruptor. En el apartado correspondiente se detalla el proceso.","title":"Materiales necesarios y ensamblado plataforma base"},{"location":"ensamble/#motores-portapilas-e-interruptor","text":"P0. Motores Im\u00e1genes Si partimos de la base que los motores no vienen ya preinstalados con cables, necesitamos: - 2 motores DC de 3 a 6V con reductora - 4 trozos de hilos de diferentes colores - Tijeras o pelacables - Soldador para electr\u00f3nica - Se aconseja usar esta\u00f1o de 1mm sin plomo con n\u00facleo de resina y composici\u00f3n del 99% de Sn, 0.3% de Ag y 0.7% de Cu En la imagen vemos los motores y los cables sin soldar \u2192 En la imagen vemos los motores con los cables soldados \u2192 P0. Portapilas Im\u00e1genes Lo ideal es adquirirlo con los cables ya instalados, aunque existen otras opciones que tendremos que analizar en cada caso. Para este paso necesitamos - 1 portapilas 5xAA Aunque sobresaldr\u00e1 un poco por los laterales tambi\u00e9n nos puede valer un portapilas 6xAA En la imagen vemos el portapilas preparado con los cables \u2192 P0. Interruptor Im\u00e1genes Necesitamos: - 1 mini interruptor basculante de 2 Pines tipo SPST de 10.5x15mm - 2 trozos de hilos de diferentes colores, idealmente rojo y negro, para mantener el est\u00e1ndar de colores de alimentaci\u00f3n Debemos tener presente que con los cables soldados y la forma de colocaci\u00f3n del interruptor (por presi\u00f3n en la plataforma superior) no podemos tener realizadas las conexiones a priori, es mas interesante realizar estas conexiones mediante, por ejemplo una clema, que permite un montaje c\u00f3modo y que podemos quitar si es necesario en el futuro. En la imagen tenemos el interruptor preparado para la instalaci\u00f3n \u2192","title":"Motores, Portapilas e interruptor"},{"location":"ensamble/#plataforma-base","text":"En fase de dise\u00f1o el aspecto de la plataforma base lo vemos en la imagen siguiente. P1. Plataforma base Im\u00e1genes Necesitamos: - 1 plataforma base impresa - 1 portapilas - 2 motores DC de 3 a 6V con reductora ya cableados - 2 tornillos M3x8mm de cabeza avellanada - 4 tornillos M3x30mm - 6 tuercas M3 En la imagen vemos el aspecto de la plataforma base una vez impresa \u2192 Sujetamos el portapilas a la base utilizando los dos tornillos M3x8 y dos tuercas. Debe queda como observamos en la imagen quedando el portapilas bajo la base \u2192 Utilizando dos tornillos M3x30 y dos tuercas por cada motor los colocamos y atornillamos a la plataforma base, teniendo cuidado de que los motores queden bien pegados a la base. La posici\u00f3n exacta de los motores viene determinada por los orificios existentes en su carcasa y las ranuras de las pesta\u00f1as verticales de la pieza impresa, que deben quedar alineadas. En esta etapa es conveniente, tal y como se aprecia en la im\u00e1gen, que el disco perforado del encoder est\u00e9 situado en el eje del motor y que este quede mas o menos centrado en la ranura de la base. En la imagen vemos como debe quedar \u2192 En las im\u00e1genes siguientes vemos los pasos anteriores en fase de dise\u00f1o Plataforma base con portapilas Plataforma base con motores","title":"Plataforma base"},{"location":"ensamble/#opcion-zumbador-pasivo","text":"Podemos optar por colocar el zumbador pasivo en la plataforma base o bien colocarlo en la plataforma superior. A continuaci\u00f3n vemos el aspecto de la pieza en fase de dise\u00f1o. P2. Zumbador pasivo Im\u00e1genes Necesitamos: - 1 soporte para buzzer impreso - 1 zumbador pasivo - 2 tornillos M3x8mm - 2 tuercas M3 - 2 cables tipo dupont H-H de 20 cm En la imagen vemos el aspecto de la pieza impresa \u2192 En la imagen siguiente vemos la plataforma base con el soporte para zumbador colocado en su lugar, tanto en fase de dise\u00f1o como en la realidad. Plataforma base con buzzer en fase de dise\u00f1o Plataforma base con buzzer","title":"Opci\u00f3n zumbador pasivo"},{"location":"ensamble/#ballcaster-y-porta-sensores-ir","text":"En realidad esta pieza podr\u00eda ser una solamente pero se ha dividido en dos para evitar el uso de soportes en la impresi\u00f3n. El aspecto en fase de dise\u00f1o de ambas piezas lo vemos en las imagenes siguientes: | | | P3. Ballcaster y porta sensores de infrarrojos Im\u00e1genes Necesitamos: - 1 ballcaster impreso - 1 portasensores IR impreso - 2 tornillos M3x8mm - 4 tornillos M3x10mm - 6 tuercas M3 - 2 sensores IR de distancia ajustable detecci\u00f3n 2 a 30cm - 6 cables tipo dupont H-H de 20 cm Colocamos y atornillamos los sensores IR con los tornillos M3x8. Empotramos dos tuerca M3 en la pieza ballcaster y colocamos esta pieza en la parte posterior del porta sensores alineando con los agujeros inferiores y atornillando con dos tornillos M3x10. Finalmente atornillamos el conjunto a la plataforma base utilizando dos tornillos M3x10 y alineando con los agujeros centrales de la base en la parte que muestra un trozo plano En la imagen vemos el aspecto del conjunto montado sobre las piezas impresas \u2192 En la imagen siguiente vemos la plataforma base con el soporte para sensores de infrarrojos y Ballcaster colocados en su lugar, tanto en fase de dise\u00f1o como en la fase montaje real. Plataforma base con sensor IR en fase de dise\u00f1o Plataforma base con sensor IR","title":"Ballcaster y porta sensores IR"},{"location":"ensamble/#ruedas","text":"Nuestra propuesta va a incluir tres dise\u00f1os que van a tener como diferencia el n\u00famero y la posici\u00f3n de juntas t\u00f3ricas. Las ruedas van a tener un radio exterior de 38 mm con una ranura que permite alojar una junta t\u00f3rica de 75 mm de di\u00e1metro exterior y secci\u00f3n transversal de 3mm de di\u00e1metro. En la imagen siguiente vemos a la izquierda el modelo para dos juntas con separaci\u00f3n de 10 mm entre ambas, en el centro la de una sola con la junta colocada y a la derecha tenemos el modelo de dos juntas sin distancia entre las mismas. Observamos como los dise\u00f1os interiores de las ruedas son iguales en cuanto a geometr\u00eda e indicaremos que el n\u00famero y la posici\u00f3n de las juntas se establece para dar soluci\u00f3n a las diferentes adherencias de superficies y evitar en lo posible que las ruedas derrapen cuando giran. El orificio con la forma del eje del motor est\u00e1 dimensionado para que la rueda quede bien acoplada simplemente presionando sobre el eje, pero somos conscientes de que las impresoras 3D tienen ciertas tolerancias y no todas van a darnos exactamente las mismas dimensiones, por ello hemos previsto la posibilidad de realizar la sujeci\u00f3n mediante tornillo que ejerza presi\u00f3n contra el eje del motor y tuerca empotrada en el cilindro de la rueda. Este paso de montaje va a depender de la opci\u00f3n escogida y de si usamos o no tornillo prisionero. P4. Ruedas Im\u00e1genes Necesitamos: - 2 ruedas impresas del modelo escogido - 2 (o 4) juntas t\u00f3ricas de 75x3mm - 2 tornillos M3x10mm - 2 tuercas M3 Colocamos haciendo presi\u00f3n si es necesario una rueda en cada eje de motor. Si es necesario porque el encaje anterior tiene holgura, empotramos una tuerca M3 en cada rueda y fijamos la posici\u00f3n de la rueda utilizando el tornillo prisionero. En la imagen inferior vemos el detalle del tornillo prisionero. En la imagen vemos el aspecto del conjunto montado con las ruedas de una junta \u2192 En las imagenes siguientes vemos la plataforma base con cada tipo de ruedas en fase de dise\u00f1o. Plataforma base con ruedas una junta Plataforma base con ruedas dos juntas Plataforma base con ruedas dos juntas separadas","title":"Ruedas"},{"location":"ensamble/#soporte-para-servo-sg-90","text":"En esta pieza es donde colocamos y atornillamos el servo motor tanto para el brazo aparta objetos como para el sensor de ultrasonidos m\u00f3vil. Si vamos a optar por la opci\u00f3n de ultrasonidos fijo solamente debemos montar un servo pero si optamos por la opci\u00f3n con sensor de ultrasonidos m\u00f3vil debemos montar dos conjuntos. P5. Servo SG-90 Im\u00e1genes Necesitamos: - 1 (o 2) soporte para servo impreso - 1 (o 2) servomotores SG-90 - 2 (o 4) tornillos M2x10mm - 2 (o 4) tuercas M2 Colocamos el servo en la pieza y lo sujetamos utilizando los tornillos M2x10. En las im\u00e1genes vemos el aspecto de la pieza tanto en fase de dise\u00f1o como impresa \u2192 Es conveniente realizar el posicionamiento del engranaje del servo de forma adecuada antes de continuar. Teniendo en cuenta que el servo puede girar 180\u00ba colocamos el engranaje con la mano o con ayuda de una de las palas del servo en tal posici\u00f3n que permita el movimiento correcto del brazo o del sensor de ultrasonidos. En las imagenes siguientes vemos el soporte con el servo colocado. Portaservo con servo en fase de dise\u00f1o Portaservo impreso con servo","title":"Soporte para servo SG-90"},{"location":"ensamble/#soporte-sensor-de-ultrasonidos-hc-sr04","text":"Tenemos dos opciones disponibles, un soporte fijo que podemos colocar tanto en la parte superior del porta sensores IR o utilizando alguna de las ranuras de las plataformas superior o inferior, y un soporte m\u00f3vil accionado por un servo pensado para colocarlo a modo de cabeza giratoria tambi\u00e9n en la parte superior del porta sensores de IR. En ambos casos el sensor se coloca presionando ligeramente para que encaje en las pesta\u00f1as del porta sensores. En las im\u00e1genes siguientes tenemos ambos tipos de soportes tanto en modo dise\u00f1o como impresos. Porta HC-SR04 fijo fase dise\u00f1o Porta HC-SR04 fijo impreso Porta HC-SR04 m\u00f3vil fase dise\u00f1o Porta HC-SR04 m\u00f3vil impreso P6. Sensor de ultrasonidos HC-SR04 Im\u00e1genes Necesitamos: - 1 soporte fijo para sensor HC-SR04 impreso - 1 soporte m\u00f3vil para sensor HC-SR04 impreso - 1 (o 2) pala de un brazo para el servo - 1 (o 2) tornillos de rosca chapa de los que vienen con el servo - 1 servo montado en su soporte - 2 tornillos M3x10mm - 2 tuercas M3 Colocamos el sensor de ultrasonidos en su alojamiento en el soporte fijo o m\u00f3vil elegido. Si hemos escogido soporte fijo sujetamos este con dos tornillos M3x10 en el lugar escogido y si hemos escogido el soporte m\u00f3vil sujetamos el soporte del sensor al servo con el tornillo de rosca chapa colocando la pala en la cabeza del servo. En las im\u00e1genes vemos el aspecto de las piezas tanto en fase de dise\u00f1o como impresas \u2192 Es conveniente realizar el posicionamiento del engranaje del servo de forma adecuada antes de continuar. Teniendo en cuenta que el servo puede girar 180\u00ba colocamos el engranaje con la mano o con ayuda de una de las palas del servo en tal posici\u00f3n que permita el movimiento correcto del brazo o del sensor de ultrasonidos. En las imagenes siguientes vemos la plataforma base finalizada con todas sus opciones colocadas. Plataforma base finalizada en fase de dise\u00f1o Plataforma base finalizada","title":"Soporte sensor de ultrasonidos HC-SR04"},{"location":"ensambles/","text":"Ejemplos de ensamblajes del robot \u00b6 A continuaci\u00f3n est\u00e1n los enlaces a los archivos fuente de ensamblado con FreeCAD y a sus correspondientes animaciones. Motores, portapilas, buzzer y ballcaster Fuente Animaci\u00f3n Ensamble motores, portapilas, buzzer y ballcaster Driver L298 y placa UNO Fuente Animaci\u00f3n Ensamble L298 y UNO Plataformas inferior y superior y ruedas Fuente Animaci\u00f3n Ensamble Plataformas y ruedas Sensor de infrarrojos Fuente Animaci\u00f3n Ensamble sensor IR Si quieres verlos en FreeCAD debes tener instalado el banco de trabajo Exploded Assembly","title":"Ensamblados"},{"location":"ensambles/#ejemplos-de-ensamblajes-del-robot","text":"A continuaci\u00f3n est\u00e1n los enlaces a los archivos fuente de ensamblado con FreeCAD y a sus correspondientes animaciones. Motores, portapilas, buzzer y ballcaster Fuente Animaci\u00f3n Ensamble motores, portapilas, buzzer y ballcaster Driver L298 y placa UNO Fuente Animaci\u00f3n Ensamble L298 y UNO Plataformas inferior y superior y ruedas Fuente Animaci\u00f3n Ensamble Plataformas y ruedas Sensor de infrarrojos Fuente Animaci\u00f3n Ensamble sensor IR Si quieres verlos en FreeCAD debes tener instalado el banco de trabajo Exploded Assembly","title":"Ejemplos de ensamblajes del robot"},{"location":"ficheros-media/","text":"Ficheros 3D para impresoras de precisi\u00f3n media \u00b6 En este apartado se incluyen los enlaces a los archivos originales de dise\u00f1o y los archivos en formato stl y step. Los archivos disponibles en este apartado est\u00e1n dise\u00f1ados pensando en imprimir en impresoras 3D est\u00e1ndar de bajo coste. Estas impresoras se caracterizan por tener ciertas tolerancias en las impresiones finales, requerir calibraciones con cierta asiduidad, etc. Las impresiones con los archivos de este apartado est\u00e1n pensados para compensar estas tolerancias, en especial en los problemas t\u00edpicos que se no han presentado, como son el ajuste del eje de los motores a la ranura de la rueda o el encaje de las tuercas empotradas en su alojamientos. Archivos fuente de dise\u00f1o \u00b6 Creados con FreeCAD que puedes modificar, cambiar seg\u00fan necesidades o utilizar para aprender el manejo de esta potente herramienta. Archivo Comentarios ruedas Rueda con una sola junta t\u00f3rica y dos versiones para dos juntas, una con esta juntas y la otra separadas. soporte-ballcaster-media.FCStd Solamente contiene la pieza del ballcaster. El soporte de los sensores verticales de IR es el mismo que en alta precisi\u00f3n Archivos STL y STEP \u00b6 Archivos en formato stl , listos para llevar a tu programa de laminaci\u00f3n preferido y hacerlos realidad con tu impresora. La configuraci\u00f3n de impresi\u00f3n debe adaptarse en cada caso a la impresora disponible, aunque hacemos las siguientes recomendaciones: Balsas: No Soportes de impresi\u00f3n: No Resoluci\u00f3n: 0,2 mm Relleno: 15 - 20% Marca de filamento: cualquiera Color del filamento: el preferido Material: PLA Archivos en formato step , para poder cargarlos en otros programas de dise\u00f1o CAD. En la tabla siguiente est\u00e1n los enlaces a estos dos tipos de ficheros. Imagen Archivo STL Archivo STEP rueda-una-junta.stl rueda-una-junta.step rueda-dos-juntas.stl rueda-dos-juntas.step rueda-dos-juntas-ancha.stl rueda-dos-juntas-ancha.step soporte-ballcaster-media.stl soporte-ballcaster-media.step","title":"3D precisi\u00f3n media"},{"location":"ficheros-media/#ficheros-3d-para-impresoras-de-precision-media","text":"En este apartado se incluyen los enlaces a los archivos originales de dise\u00f1o y los archivos en formato stl y step. Los archivos disponibles en este apartado est\u00e1n dise\u00f1ados pensando en imprimir en impresoras 3D est\u00e1ndar de bajo coste. Estas impresoras se caracterizan por tener ciertas tolerancias en las impresiones finales, requerir calibraciones con cierta asiduidad, etc. Las impresiones con los archivos de este apartado est\u00e1n pensados para compensar estas tolerancias, en especial en los problemas t\u00edpicos que se no han presentado, como son el ajuste del eje de los motores a la ranura de la rueda o el encaje de las tuercas empotradas en su alojamientos.","title":"Ficheros 3D para impresoras de precisi\u00f3n media"},{"location":"ficheros-media/#archivos-fuente-de-diseno","text":"Creados con FreeCAD que puedes modificar, cambiar seg\u00fan necesidades o utilizar para aprender el manejo de esta potente herramienta. Archivo Comentarios ruedas Rueda con una sola junta t\u00f3rica y dos versiones para dos juntas, una con esta juntas y la otra separadas. soporte-ballcaster-media.FCStd Solamente contiene la pieza del ballcaster. El soporte de los sensores verticales de IR es el mismo que en alta precisi\u00f3n","title":"Archivos fuente de dise\u00f1o"},{"location":"ficheros-media/#archivos-stl-y-step","text":"Archivos en formato stl , listos para llevar a tu programa de laminaci\u00f3n preferido y hacerlos realidad con tu impresora. La configuraci\u00f3n de impresi\u00f3n debe adaptarse en cada caso a la impresora disponible, aunque hacemos las siguientes recomendaciones: Balsas: No Soportes de impresi\u00f3n: No Resoluci\u00f3n: 0,2 mm Relleno: 15 - 20% Marca de filamento: cualquiera Color del filamento: el preferido Material: PLA Archivos en formato step , para poder cargarlos en otros programas de dise\u00f1o CAD. En la tabla siguiente est\u00e1n los enlaces a estos dos tipos de ficheros. Imagen Archivo STL Archivo STEP rueda-una-junta.stl rueda-una-junta.step rueda-dos-juntas.stl rueda-dos-juntas.step rueda-dos-juntas-ancha.stl rueda-dos-juntas-ancha.step soporte-ballcaster-media.stl soporte-ballcaster-media.step","title":"Archivos STL y STEP"},{"location":"ficheros/","text":"Ficheros 3D para impresoras de alta precisi\u00f3n \u00b6 En este apartado se incluyen los enlaces a los archivos originales de dise\u00f1o y los archivos en formato stl y step. Los archivos disponibles en este apartado est\u00e1n dise\u00f1ados pensando en imprimir en una impresora del tipo Prusa MK3S, MK3S+, Prusa Mini o Prusa Mini+ Originales. Estas impresoras, adem\u00e1s de tener una calidad de impresi\u00f3n muy buena, est\u00e1n optimizadas para que las impresiones finales tengan muy poca tolerancia, en lo que respecta a dimensiones, con relaci\u00f3n a las medidas originales de dise\u00f1o. Es muy posible,si no disponemos de impresoras como estas o de calidades similares, que al imprimir estos dise\u00f1os tengamos alg\u00fan problema a la hora de ensamblar nuestro robot y tengamos que retocar a mano ciertas partes. Ejemplos t\u00edpicos de esto que se no han dado son el ajuste del eje de los motores a la ranura de la rueda o el encaje de las tuercas empotradas en su alojamientos. Si no dispones de una impresora como las citadas, o similar, te aconsejamos que utilices los archivos que se suministran en el apartado 3D precisi\u00f3n media para las piezas incluidas en dicho apartado. Archivos fuente de dise\u00f1o \u00b6 Creados con FreeCAD que puedes modificar, cambiar seg\u00fan necesidades o utilizar para aprender el manejo de esta potente herramienta. Archivo Comentarios plataforma-base-src.FCStd Para colocar el portapilas, los motores DC, el zumbador y el ballcaster o punto de apoyo estilo rueda loca soporte-zumbador-src.FCStd Para colocar un zumbador pasivo. Esta pieza tambi\u00e9n se puede colocar en la plataforma superior soporte-sensores-IR-ballcaster.FCStd Contiene dos piezas, el ballcaster y el soporte de los sensores verticales de IR soportes-ultrasonidos.FCStd Contiene los soporte fijo y m\u00f3vil para el sensor HC-SR04 plataforma-superior-src.FCStd Para colocar cualquiera de las placas, el interruptor y sujetar el servo del brazo ruedas.FCStd Rueda con una sola junta t\u00f3rica y dos versiones para dos juntas, una con esta juntas y la otra separadas. base-servo-src.FCStd Pieza para sujetar un servo tipo SG90 brazo-src.FCStd Brazo aparta objetos con alojamiento para la pala del servo separadores-src.FCStd M3x5 para placa UNO y driver y M3x28 para unir plataformas base y superior soporte-pruebas.FCStd Pieza pensada para poner encima el robot y poder hacer pruebas sin que este se mueva del sitio disco-encoder.FCStd Disco de 23 mm de di\u00e1metro con 20 ranuras acoplable a eje de motor para encoder optico conjunto-src.FCStd Muestra la colocaci\u00f3n de los distintos elementos en fase de dise\u00f1o Todo en un archivo zip Para descargar todos los archivos en un clic Archivos STL y STEP \u00b6 Archivos en formato stl , listos para llevar a tu programa de laminaci\u00f3n preferido y hacerlos realidad con tu impresora. La configuraci\u00f3n de impresi\u00f3n debe adaptarse en cada caso a la impresora disponible, aunque hacemos las siguientes recomendaciones: Balsas: No Soportes de impresi\u00f3n: No Resoluci\u00f3n: 0,2 mm Relleno: 15 - 20% Marca de filamento: cualquiera Color del filamento: el preferido Material: PLA Archivos en formato step , para poder cargarlos en otros programas de dise\u00f1o CAD. En la tabla siguiente est\u00e1n los enlaces a estos dos tipos de ficheros. Imagen Archivo STL Archivo STEP ballcaster.stl ballcaster.step base-servo.stl base-servo.step brazo.stl brazo.step disco-encoder.stl disco-encoder.step plataforma-base.stl plataforma-base.step plataforma-superior.stl plataforma-superior.step rueda-una-junta.stl rueda-una-junta.step rueda-dos-juntas.stl rueda-dos-juntas.step rueda-dos-juntas-ancha.stl rueda-dos-juntas-ancha.step porta-sensores-IR.stl porta-sensores-IR.step separador-M3x5.stl separador-M3x5.step separador-M3x28.stl separador-M3x28.step soporte-para-pruebas.stl soporte-para-pruebas.step soporte-zumbador.stl soporte-zumbador.step ultrasonidos-fijo.stl ultrasonidos-fijo.step ultrasonidos-movil.stl ultrasonidos-movil.step Todos los archivos en un zip Todos los stl en un zip Todos los step en un zip","title":"3D alta precisi\u00f3n"},{"location":"ficheros/#ficheros-3d-para-impresoras-de-alta-precision","text":"En este apartado se incluyen los enlaces a los archivos originales de dise\u00f1o y los archivos en formato stl y step. Los archivos disponibles en este apartado est\u00e1n dise\u00f1ados pensando en imprimir en una impresora del tipo Prusa MK3S, MK3S+, Prusa Mini o Prusa Mini+ Originales. Estas impresoras, adem\u00e1s de tener una calidad de impresi\u00f3n muy buena, est\u00e1n optimizadas para que las impresiones finales tengan muy poca tolerancia, en lo que respecta a dimensiones, con relaci\u00f3n a las medidas originales de dise\u00f1o. Es muy posible,si no disponemos de impresoras como estas o de calidades similares, que al imprimir estos dise\u00f1os tengamos alg\u00fan problema a la hora de ensamblar nuestro robot y tengamos que retocar a mano ciertas partes. Ejemplos t\u00edpicos de esto que se no han dado son el ajuste del eje de los motores a la ranura de la rueda o el encaje de las tuercas empotradas en su alojamientos. Si no dispones de una impresora como las citadas, o similar, te aconsejamos que utilices los archivos que se suministran en el apartado 3D precisi\u00f3n media para las piezas incluidas en dicho apartado.","title":"Ficheros 3D para impresoras de alta precisi\u00f3n"},{"location":"ficheros/#archivos-fuente-de-diseno","text":"Creados con FreeCAD que puedes modificar, cambiar seg\u00fan necesidades o utilizar para aprender el manejo de esta potente herramienta. Archivo Comentarios plataforma-base-src.FCStd Para colocar el portapilas, los motores DC, el zumbador y el ballcaster o punto de apoyo estilo rueda loca soporte-zumbador-src.FCStd Para colocar un zumbador pasivo. Esta pieza tambi\u00e9n se puede colocar en la plataforma superior soporte-sensores-IR-ballcaster.FCStd Contiene dos piezas, el ballcaster y el soporte de los sensores verticales de IR soportes-ultrasonidos.FCStd Contiene los soporte fijo y m\u00f3vil para el sensor HC-SR04 plataforma-superior-src.FCStd Para colocar cualquiera de las placas, el interruptor y sujetar el servo del brazo ruedas.FCStd Rueda con una sola junta t\u00f3rica y dos versiones para dos juntas, una con esta juntas y la otra separadas. base-servo-src.FCStd Pieza para sujetar un servo tipo SG90 brazo-src.FCStd Brazo aparta objetos con alojamiento para la pala del servo separadores-src.FCStd M3x5 para placa UNO y driver y M3x28 para unir plataformas base y superior soporte-pruebas.FCStd Pieza pensada para poner encima el robot y poder hacer pruebas sin que este se mueva del sitio disco-encoder.FCStd Disco de 23 mm de di\u00e1metro con 20 ranuras acoplable a eje de motor para encoder optico conjunto-src.FCStd Muestra la colocaci\u00f3n de los distintos elementos en fase de dise\u00f1o Todo en un archivo zip Para descargar todos los archivos en un clic","title":"Archivos fuente de dise\u00f1o"},{"location":"ficheros/#archivos-stl-y-step","text":"Archivos en formato stl , listos para llevar a tu programa de laminaci\u00f3n preferido y hacerlos realidad con tu impresora. La configuraci\u00f3n de impresi\u00f3n debe adaptarse en cada caso a la impresora disponible, aunque hacemos las siguientes recomendaciones: Balsas: No Soportes de impresi\u00f3n: No Resoluci\u00f3n: 0,2 mm Relleno: 15 - 20% Marca de filamento: cualquiera Color del filamento: el preferido Material: PLA Archivos en formato step , para poder cargarlos en otros programas de dise\u00f1o CAD. En la tabla siguiente est\u00e1n los enlaces a estos dos tipos de ficheros. Imagen Archivo STL Archivo STEP ballcaster.stl ballcaster.step base-servo.stl base-servo.step brazo.stl brazo.step disco-encoder.stl disco-encoder.step plataforma-base.stl plataforma-base.step plataforma-superior.stl plataforma-superior.step rueda-una-junta.stl rueda-una-junta.step rueda-dos-juntas.stl rueda-dos-juntas.step rueda-dos-juntas-ancha.stl rueda-dos-juntas-ancha.step porta-sensores-IR.stl porta-sensores-IR.step separador-M3x5.stl separador-M3x5.step separador-M3x28.stl separador-M3x28.step soporte-para-pruebas.stl soporte-para-pruebas.step soporte-zumbador.stl soporte-zumbador.step ultrasonidos-fijo.stl ultrasonidos-fijo.step ultrasonidos-movil.stl ultrasonidos-movil.step Todos los archivos en un zip Todos los stl en un zip Todos los step en un zip","title":"Archivos STL y STEP"},{"location":"Miscelanea/about/","text":"Autores \u00b6 Este proyecto es una colaboraci\u00f3n entre distintos miembros de Club Robotica Granada y Antonio G\u00f3mez Garc\u00eda . Club Robotica Granada Federico Coca Antonio G\u00f3mez Pedro Ruiz GitHub GitHub GitHub GitHub Twitter Twitter Twitter Twitter Manuel Hidalgo Prudencio Luna Jos\u00e9 Luis Bueno Maribel Ruiz GitHub GitHub --- GitHub Twitter Twitter Twitter ---","title":"Autores"},{"location":"Miscelanea/about/#autores","text":"Este proyecto es una colaboraci\u00f3n entre distintos miembros de Club Robotica Granada y Antonio G\u00f3mez Garc\u00eda . Club Robotica Granada Federico Coca Antonio G\u00f3mez Pedro Ruiz GitHub GitHub GitHub GitHub Twitter Twitter Twitter Twitter Manuel Hidalgo Prudencio Luna Jos\u00e9 Luis Bueno Maribel Ruiz GitHub GitHub --- GitHub Twitter Twitter Twitter ---","title":"Autores"},{"location":"Miscelanea/lic/","text":"Licencias \u00b6 Licencia MIT incluida en la creaci\u00f3n del repositorio. Creative Commons Atribuci\u00f3n-CompartirIgual 4.0 International (\"CC BY-SA\"). CC BY-SA 4.0 Open Source Hardware (OSHW). Enlace a la versi\u00f3n V 1.0 original de la licencia - Enlace a la traducci\u00f3n de la versi\u00f3n V 1.0 original de la licencia - Spanish - Open Source Hardware Association","title":"Licencias"},{"location":"Miscelanea/lic/#licencias","text":"Licencia MIT incluida en la creaci\u00f3n del repositorio. Creative Commons Atribuci\u00f3n-CompartirIgual 4.0 International (\"CC BY-SA\"). CC BY-SA 4.0 Open Source Hardware (OSHW). Enlace a la versi\u00f3n V 1.0 original de la licencia - Enlace a la traducci\u00f3n de la versi\u00f3n V 1.0 original de la licencia - Spanish - Open Source Hardware Association","title":"Licencias"},{"location":"Miscelanea/merchandising/","text":"Merchandising \u00b6 En este apartado simplemente te queremos mostrar algunas de las cosillas que hemos ido haciendo en torno al robot para utilizar en las presentaciones y que los asistentes a las mismas puedan llevarse un peque\u00f1o recuerdo. Pegatina rectangular Creada con una imagen de Masaylo incluye un c\u00f3digo QR que enlaza con la web del proyecto. Su aspecto es el de la imagen siguiente: Archivo fuente Aspecto Formato svg Logotipo \"I love Masaylo\" Se crea el logotipo circular con la leyenda y se realizan pegatinas circulares con el mismo. A continuaci\u00f3n tenemos la im\u00e1genes del mismo en distintas resoluciones. 200 px 250 px 300 px 550 px Se imprime una primera tirada de camisetas como la de la imagen siguiente:","title":"Merchandising"},{"location":"Miscelanea/merchandising/#merchandising","text":"En este apartado simplemente te queremos mostrar algunas de las cosillas que hemos ido haciendo en torno al robot para utilizar en las presentaciones y que los asistentes a las mismas puedan llevarse un peque\u00f1o recuerdo. Pegatina rectangular Creada con una imagen de Masaylo incluye un c\u00f3digo QR que enlaza con la web del proyecto. Su aspecto es el de la imagen siguiente: Archivo fuente Aspecto Formato svg Logotipo \"I love Masaylo\" Se crea el logotipo circular con la leyenda y se realizan pegatinas circulares con el mismo. A continuaci\u00f3n tenemos la im\u00e1genes del mismo en distintas resoluciones. 200 px 250 px 300 px 550 px Se imprime una primera tirada de camisetas como la de la imagen siguiente:","title":"Merchandising"},{"location":"Miscelanea/soft/","text":"Software utilizado \u00b6 Dibujo 3D FreeCAD 0.19 Sistema operativo principal: Ubuntu 20.04.4 LTS (Focal Fossa) Paquete ofim\u00e1tico de referencia: LibreOffice Libreria Material para MkDocs Visual Studio Code Creaci\u00f3n de GIF animados para Ubuntu Peek Sistema principal de capturas de pantalla: Shutter 0.94 Dibujo 2D vectorial Inkscape Retoque de im\u00e1genes GIMP Creaci\u00f3n de GIF animado a partir de video con FFMPEG y GIMP IDE de Arduino Masaylo Blockly releases","title":"Software utilizado"},{"location":"Miscelanea/soft/#software-utilizado","text":"Dibujo 3D FreeCAD 0.19 Sistema operativo principal: Ubuntu 20.04.4 LTS (Focal Fossa) Paquete ofim\u00e1tico de referencia: LibreOffice Libreria Material para MkDocs Visual Studio Code Creaci\u00f3n de GIF animados para Ubuntu Peek Sistema principal de capturas de pantalla: Shutter 0.94 Dibujo 2D vectorial Inkscape Retoque de im\u00e1genes GIMP Creaci\u00f3n de GIF animado a partir de video con FFMPEG y GIMP IDE de Arduino Masaylo Blockly releases","title":"Software utilizado"},{"location":"Miscelanea/webgrafia/","text":"Webgraf\u00eda y bibliograf\u00eda \u00b6 Wikipedia Wiki de Keyestudio Blog de Luis Llamas Detalles sobre Arduino Nano CH340 Rob\u00f3tica con Arduino. Introducci\u00f3n a la programaci\u00f3n de sistemas de control por Antonio G\u00f3mez Garc\u00eda y Mar\u00eda Dolores Nogueras Atance","title":"Webgrafia/Bibliograf\u00eda"},{"location":"Miscelanea/webgrafia/#webgrafia-y-bibliografia","text":"Wikipedia Wiki de Keyestudio Blog de Luis Llamas Detalles sobre Arduino Nano CH340 Rob\u00f3tica con Arduino. Introducci\u00f3n a la programaci\u00f3n de sistemas de control por Antonio G\u00f3mez Garc\u00eda y Mar\u00eda Dolores Nogueras Atance","title":"Webgraf\u00eda y bibliograf\u00eda"},{"location":"conexionado-pruebas/NANO/conex-N/","text":"Conexionado de los distintos elementos \u00b6 B\u00e1sicamente el conexionado es el mismo que el visto en la versi\u00f3n UNO salvo en lo referente al zumbador que ahora se va a conectar a un pin anal\u00f3gico, por ejemplo el A0, y el sensor de infrarrojos para detecci\u00f3n de l\u00ednea izquierdo lo llevaremos a uno de los dos extra que nos ofrece la placa Nano, por ejemplo el A6. Cabr\u00eda pensar en la posibilidad de conectar el buzzer en el pin A6 o A7, pero estos pines no se pueden configurar como salida ya que son de lectura anal\u00f3gica exclusivamente. No obstante, describimos gr\u00e1ficamente el conexionado que debemos realizar entre los distintos elementos. En este caso vamos a utilizar el pinout mostrado en la imagen siguiente. La fuente de esta imagen la tenemos en este archivo svg Masaylo-CRG NANO pinout Alimentaci\u00f3n \u00b6 Seguimos el mismo procedimiento que en la versi\u00f3n UNO. En la imagen siguiente tenemos el detalle de conexionado de la alimentaci\u00f3n para ambas placas que debemos realizar de forma cuidadosa en especial y no cambiar la polaridad de la alimentaci\u00f3n que se ha marcado y dibujado con los colores normalizados de la misma. Conexionado de alimentaci\u00f3n La forma m\u00e1s sencilla de conectar los elementos es utilizando un jack de alimentaci\u00f3n con clema como el que se ve en la imagen anterior aunque tambi\u00e9n podemos utilizar un jack normal realizando las correspondientes soldaduras. Se recomienda que una vez finalizadas las conexiones se revisen estas cuidadosamente, tanto en las conexiones en si mismas como en la polaridad, antes de alimentar el sistema o conectar el USB para grabar alg\u00fan programa, as\u00ed evitaremos en lo posible romper algo por mal conexionado. Motores DC 3 a 6V \u00b6 Procedemos a conectar los motores en las bornas del driver L298 de forma que el motor izquierdo quede conectado a OUT1 - OUT2 y el derecho a OUT3 - OUT4. En la imagen siguiente tenemos el conexionado de forma gr\u00e1fica. Conexionado de motores Los pines de control de cada motor se conectan como se indica en la imagen anterior y de id\u00e9ntica forma a la descrita en la versi\u00f3n UNO. Zumbador \u00b6 Al igual que en la versi\u00f3n UNO podemos usar el pin D1 o TxD y su Vcc asociado para conectarlo o alternativamente conectarlo a alguno de los pines reservados para Bluetooth en caso de no usar esta funcionalidad asignada en el pinout. En la imagen siguiente podemos ver el conexionado de estos elementos de forma gr\u00e1fica junto con los conectados anteriormente. Conexionado de conjunto incluyendo zumbador Pines de entrada anal\u00f3gica A0-A5 \u00b6 Antes de conectar los sensores de infrarrojos, que ir\u00e1n a los pines anal\u00f3gicos (aunque su salida es digital), vamos a explicar como usar los pines anal\u00f3gicos como pines digitales en las placas Arduino. La explicaci\u00f3n original en ingl\u00e9s la podemos encontrar en el enlace \"Analog Input Pins\" . Convertidor A/D Los controladores ATmega utilizados para Arduino contienen un convertidor de anal\u00f3gico a digital integrado de 6 canales (8 canales en el Mini y Nano y 16 en el Mega) con una resoluci\u00f3n de 10 bits, devolviendo n\u00fameros enteros de 0 a 1023. Si bien la funci\u00f3n principal de los pines anal\u00f3gicos para la mayor\u00eda de los usuarios es leer sensores anal\u00f3gicos, los pines anal\u00f3gicos tambi\u00e9n tienen toda la funcionalidad de los pines de entrada/salida de prop\u00f3sito general (GPIO) (lo mismo que los pines digitales 0-13). Por tanto, si necesitamos m\u00e1s pines de entrada y salida de prop\u00f3sito general, y todos los pines anal\u00f3gicos no est\u00e1n en uso, estos pueden usarse para GPIO. Mapeo de pines Los pines anal\u00f3gicos, excepto A6 y A7, se pueden usar de manera id\u00e9ntica a los pines digitales, usando los alias A0 (para la entrada anal\u00f3gica 0), A1, etc. Por ejemplo, el c\u00f3digo para configurar el pin A0 como salida y poner en alto ser\u00eda: pinMode(A0, OUTPUT); //Solo pines A0 a A5 digitalWrite(A0, HIGH); Resistencias de pull-up Los pines anal\u00f3gicos tambi\u00e9n tienen resistencias pull-up, que funcionan de manera id\u00e9ntica a las de los pines digitales. Se habilitan emitiendo un comando del tipo: pinMode(A0, INPUT_PULLUP); // set pull-up on analog pin 0 . Hay que tener en cuenta que activar un pull-up afectar\u00e1 a los valores entregados por analogRead() . Advertencias El comando analogRead() no funcionar\u00e1 correctamente si el pin lo hemos configurado previamente como salida. Si hemos puesto el pin en estado alto estando configurado como salida, la resistencia de pull-up se configurar\u00e1 de nuevo cuando se vuelva a cambiar a entrada. La hoja de datos de ATmega advierte que el cambio de pines anal\u00f3gicos a digitales puede introducir jitter o ruido no deseado en las lecturas anal\u00f3gicas del resto de pines. Se aconseja, despu\u00e9s de poner los pines anal\u00f3gicos en modo digital, agregar un retardo corto antes de usar analogRead() . Sensores de infrarrojos \u00b6 Una vez vista la explicaci\u00f3n sobre pines anal\u00f3gicos utilizados como digitales diremos que vamos a conectar el sensor de infrarrojos izquierdo al pin A0 y el derecho al pin A1. Hay que tener especial cuidado en que los pines marcados con VCC y GND se conecten a los pines V y G respectivamente de la shield. En la imagen siguiente podemos ver el conexionado de estos elementos de forma gr\u00e1fica junto con los conectados anteriormente. Conexionado del conjunto incluyendo los sensores de infrarrojos En la imagen siguiente vemos el detalle de conexionado de los sensores de infrarrojos. Detalle del conexionado de los sensores de infrarrojos Sensor de distancia HC-SR04 \u00b6 De nuevo utilizamos dos pines anal\u00f3gicos como digitales por lo que debemos tener en cuenta lo referido anteriormente sobre el tema. Vamos a conectar el Trigger del sensor al pin A2 que deberemos configurar como salida y el pin Echo a A3 que deberemos configurar como entrada. En caso de utilizar MasayloBlockly o la librer\u00eda descrita en este tutorial estas definiciones estar\u00e1n ya realizadas. En la imagen siguiente podemos ver el conexionado de estos elementos de forma gr\u00e1fica junto con los conectados anteriormente. Conexionado del conjunto incluyendo el sensor de ultrasonidos HC-SR04 En la imagen siguiente vemos el detalle de conexionado del sensor de ultrasonidos HC-SR04. Detalle del conexionado del sensor de ultrasonidos HC-SR04 Servomotores \u00b6 En este caso los pines que utilizaremos son los digitales 4 y 5, el primero para el brazo y el segundo para la cabeza. En la imagen siguiente podemos ver el conexionado de estos elementos de forma gr\u00e1fica junto con los conectados anteriormente. Conexionado del conjunto incluyendo los servos de brazo y cabeza En la imagen siguiente vemos el detalle de conexionado de los dos servos SG90. Detalle del conexionado de los servos de brazo y cabeza Encoder infrarrojos FC-03 \u00b6 En este caso los pines que utilizaremos son los digitales 2 y 3, que son los pines que admiten interrupciones en las placas tipo UNO, Nano, Mega, Mini y Leonardo. En la imagen siguiente podemos ver el conexionado de estos elementos de forma gr\u00e1fica junto con los conectados anteriormente. Conexionado del conjunto incluyendo los encoders En la imagen siguiente vemos el detalle de conexionado de los dos encoder FC-03. Detalle del conexionado de los encoder FC-03","title":"Conexionado"},{"location":"conexionado-pruebas/NANO/conex-N/#conexionado-de-los-distintos-elementos","text":"B\u00e1sicamente el conexionado es el mismo que el visto en la versi\u00f3n UNO salvo en lo referente al zumbador que ahora se va a conectar a un pin anal\u00f3gico, por ejemplo el A0, y el sensor de infrarrojos para detecci\u00f3n de l\u00ednea izquierdo lo llevaremos a uno de los dos extra que nos ofrece la placa Nano, por ejemplo el A6. Cabr\u00eda pensar en la posibilidad de conectar el buzzer en el pin A6 o A7, pero estos pines no se pueden configurar como salida ya que son de lectura anal\u00f3gica exclusivamente. No obstante, describimos gr\u00e1ficamente el conexionado que debemos realizar entre los distintos elementos. En este caso vamos a utilizar el pinout mostrado en la imagen siguiente. La fuente de esta imagen la tenemos en este archivo svg Masaylo-CRG NANO pinout","title":"Conexionado de los distintos elementos"},{"location":"conexionado-pruebas/NANO/conex-N/#alimentacion","text":"Seguimos el mismo procedimiento que en la versi\u00f3n UNO. En la imagen siguiente tenemos el detalle de conexionado de la alimentaci\u00f3n para ambas placas que debemos realizar de forma cuidadosa en especial y no cambiar la polaridad de la alimentaci\u00f3n que se ha marcado y dibujado con los colores normalizados de la misma. Conexionado de alimentaci\u00f3n La forma m\u00e1s sencilla de conectar los elementos es utilizando un jack de alimentaci\u00f3n con clema como el que se ve en la imagen anterior aunque tambi\u00e9n podemos utilizar un jack normal realizando las correspondientes soldaduras. Se recomienda que una vez finalizadas las conexiones se revisen estas cuidadosamente, tanto en las conexiones en si mismas como en la polaridad, antes de alimentar el sistema o conectar el USB para grabar alg\u00fan programa, as\u00ed evitaremos en lo posible romper algo por mal conexionado.","title":"Alimentaci\u00f3n"},{"location":"conexionado-pruebas/NANO/conex-N/#motores-dc-3-a-6v","text":"Procedemos a conectar los motores en las bornas del driver L298 de forma que el motor izquierdo quede conectado a OUT1 - OUT2 y el derecho a OUT3 - OUT4. En la imagen siguiente tenemos el conexionado de forma gr\u00e1fica. Conexionado de motores Los pines de control de cada motor se conectan como se indica en la imagen anterior y de id\u00e9ntica forma a la descrita en la versi\u00f3n UNO.","title":"Motores DC 3 a 6V"},{"location":"conexionado-pruebas/NANO/conex-N/#zumbador","text":"Al igual que en la versi\u00f3n UNO podemos usar el pin D1 o TxD y su Vcc asociado para conectarlo o alternativamente conectarlo a alguno de los pines reservados para Bluetooth en caso de no usar esta funcionalidad asignada en el pinout. En la imagen siguiente podemos ver el conexionado de estos elementos de forma gr\u00e1fica junto con los conectados anteriormente. Conexionado de conjunto incluyendo zumbador","title":"Zumbador"},{"location":"conexionado-pruebas/NANO/conex-N/#pines-de-entrada-analogica-a0-a5","text":"Antes de conectar los sensores de infrarrojos, que ir\u00e1n a los pines anal\u00f3gicos (aunque su salida es digital), vamos a explicar como usar los pines anal\u00f3gicos como pines digitales en las placas Arduino. La explicaci\u00f3n original en ingl\u00e9s la podemos encontrar en el enlace \"Analog Input Pins\" . Convertidor A/D Los controladores ATmega utilizados para Arduino contienen un convertidor de anal\u00f3gico a digital integrado de 6 canales (8 canales en el Mini y Nano y 16 en el Mega) con una resoluci\u00f3n de 10 bits, devolviendo n\u00fameros enteros de 0 a 1023. Si bien la funci\u00f3n principal de los pines anal\u00f3gicos para la mayor\u00eda de los usuarios es leer sensores anal\u00f3gicos, los pines anal\u00f3gicos tambi\u00e9n tienen toda la funcionalidad de los pines de entrada/salida de prop\u00f3sito general (GPIO) (lo mismo que los pines digitales 0-13). Por tanto, si necesitamos m\u00e1s pines de entrada y salida de prop\u00f3sito general, y todos los pines anal\u00f3gicos no est\u00e1n en uso, estos pueden usarse para GPIO. Mapeo de pines Los pines anal\u00f3gicos, excepto A6 y A7, se pueden usar de manera id\u00e9ntica a los pines digitales, usando los alias A0 (para la entrada anal\u00f3gica 0), A1, etc. Por ejemplo, el c\u00f3digo para configurar el pin A0 como salida y poner en alto ser\u00eda: pinMode(A0, OUTPUT); //Solo pines A0 a A5 digitalWrite(A0, HIGH); Resistencias de pull-up Los pines anal\u00f3gicos tambi\u00e9n tienen resistencias pull-up, que funcionan de manera id\u00e9ntica a las de los pines digitales. Se habilitan emitiendo un comando del tipo: pinMode(A0, INPUT_PULLUP); // set pull-up on analog pin 0 . Hay que tener en cuenta que activar un pull-up afectar\u00e1 a los valores entregados por analogRead() . Advertencias El comando analogRead() no funcionar\u00e1 correctamente si el pin lo hemos configurado previamente como salida. Si hemos puesto el pin en estado alto estando configurado como salida, la resistencia de pull-up se configurar\u00e1 de nuevo cuando se vuelva a cambiar a entrada. La hoja de datos de ATmega advierte que el cambio de pines anal\u00f3gicos a digitales puede introducir jitter o ruido no deseado en las lecturas anal\u00f3gicas del resto de pines. Se aconseja, despu\u00e9s de poner los pines anal\u00f3gicos en modo digital, agregar un retardo corto antes de usar analogRead() .","title":"Pines de entrada anal\u00f3gica A0-A5"},{"location":"conexionado-pruebas/NANO/conex-N/#sensores-de-infrarrojos","text":"Una vez vista la explicaci\u00f3n sobre pines anal\u00f3gicos utilizados como digitales diremos que vamos a conectar el sensor de infrarrojos izquierdo al pin A0 y el derecho al pin A1. Hay que tener especial cuidado en que los pines marcados con VCC y GND se conecten a los pines V y G respectivamente de la shield. En la imagen siguiente podemos ver el conexionado de estos elementos de forma gr\u00e1fica junto con los conectados anteriormente. Conexionado del conjunto incluyendo los sensores de infrarrojos En la imagen siguiente vemos el detalle de conexionado de los sensores de infrarrojos. Detalle del conexionado de los sensores de infrarrojos","title":"Sensores de infrarrojos"},{"location":"conexionado-pruebas/NANO/conex-N/#sensor-de-distancia-hc-sr04","text":"De nuevo utilizamos dos pines anal\u00f3gicos como digitales por lo que debemos tener en cuenta lo referido anteriormente sobre el tema. Vamos a conectar el Trigger del sensor al pin A2 que deberemos configurar como salida y el pin Echo a A3 que deberemos configurar como entrada. En caso de utilizar MasayloBlockly o la librer\u00eda descrita en este tutorial estas definiciones estar\u00e1n ya realizadas. En la imagen siguiente podemos ver el conexionado de estos elementos de forma gr\u00e1fica junto con los conectados anteriormente. Conexionado del conjunto incluyendo el sensor de ultrasonidos HC-SR04 En la imagen siguiente vemos el detalle de conexionado del sensor de ultrasonidos HC-SR04. Detalle del conexionado del sensor de ultrasonidos HC-SR04","title":"Sensor de distancia HC-SR04"},{"location":"conexionado-pruebas/NANO/conex-N/#servomotores","text":"En este caso los pines que utilizaremos son los digitales 4 y 5, el primero para el brazo y el segundo para la cabeza. En la imagen siguiente podemos ver el conexionado de estos elementos de forma gr\u00e1fica junto con los conectados anteriormente. Conexionado del conjunto incluyendo los servos de brazo y cabeza En la imagen siguiente vemos el detalle de conexionado de los dos servos SG90. Detalle del conexionado de los servos de brazo y cabeza","title":"Servomotores"},{"location":"conexionado-pruebas/NANO/conex-N/#encoder-infrarrojos-fc-03","text":"En este caso los pines que utilizaremos son los digitales 2 y 3, que son los pines que admiten interrupciones en las placas tipo UNO, Nano, Mega, Mini y Leonardo. En la imagen siguiente podemos ver el conexionado de estos elementos de forma gr\u00e1fica junto con los conectados anteriormente. Conexionado del conjunto incluyendo los encoders En la imagen siguiente vemos el detalle de conexionado de los dos encoder FC-03. Detalle del conexionado de los encoder FC-03","title":"Encoder infrarrojos FC-03"},{"location":"conexionado-pruebas/NANO/elementos-N/","text":"Descripci\u00f3n de placas y sensores \u00b6 En este apartado vamos a realizar una descripci\u00f3n b\u00e1sica de las distintas placas que se utilizan para esta versi\u00f3n del robot y que sean diferentes a los elementos ya descritos en la entrada de \u00edndice correspondiente a la versi\u00f3n UNO. Indicar tambi\u00e9n que el montaje del robot sigue las mismas pautas que las descritas en los ensamblados y que se utilizan exactamente las mismas piezas 3D. Placa Shield para Nano V3.0 \u00b6 Se trata de una placa que b\u00e1sicamente lo que hace es transformar a formato UNO la versi\u00f3n de placa Nano V3. La placa incorpora conectores de 3 pines que incluyen la patilla asociada y la alimentaci\u00f3n y que facilita el conexionado de elementos sin necesidad de utilizar protoboard. En la imagen siguiente podemos ver esta placa con sus descripciones b\u00e1sicas y este es el enlace al archivo fuente . Placa Shield Nano V3.0 Tambi\u00e9n es importante tener disponible un gr\u00e1fico con la funcionalidad de cada pin o diagrama pinout como el que vemos en la imagen siguiente correspondiente a la placa Nano. En este enlace tenemos su archivo fuente Pinout de la Placa Nano V3.0 En la imagen siguiente podemos observar la shield con la placa Nano montada y vemos como tiene el mismo formato que una placa UNO. Shield para la placa Nano V3.0 Elementos descritos en la versi\u00f3n UNO \u00b6 Los elementos que se relacionan a continuaci\u00f3n son exactamente los mismo que los usados en la versi\u00f3n UNO: Placa Drivers L298 Motores DC 3 a 6V Zumbador Sensores de infrarrojos Sensor de distancia HC-SR04 Servomotores Encoder infrarrojos FC-03","title":"An\u00e1lisis de elementos"},{"location":"conexionado-pruebas/NANO/elementos-N/#descripcion-de-placas-y-sensores","text":"En este apartado vamos a realizar una descripci\u00f3n b\u00e1sica de las distintas placas que se utilizan para esta versi\u00f3n del robot y que sean diferentes a los elementos ya descritos en la entrada de \u00edndice correspondiente a la versi\u00f3n UNO. Indicar tambi\u00e9n que el montaje del robot sigue las mismas pautas que las descritas en los ensamblados y que se utilizan exactamente las mismas piezas 3D.","title":"Descripci\u00f3n de placas y sensores"},{"location":"conexionado-pruebas/NANO/elementos-N/#placa-shield-para-nano-v30","text":"Se trata de una placa que b\u00e1sicamente lo que hace es transformar a formato UNO la versi\u00f3n de placa Nano V3. La placa incorpora conectores de 3 pines que incluyen la patilla asociada y la alimentaci\u00f3n y que facilita el conexionado de elementos sin necesidad de utilizar protoboard. En la imagen siguiente podemos ver esta placa con sus descripciones b\u00e1sicas y este es el enlace al archivo fuente . Placa Shield Nano V3.0 Tambi\u00e9n es importante tener disponible un gr\u00e1fico con la funcionalidad de cada pin o diagrama pinout como el que vemos en la imagen siguiente correspondiente a la placa Nano. En este enlace tenemos su archivo fuente Pinout de la Placa Nano V3.0 En la imagen siguiente podemos observar la shield con la placa Nano montada y vemos como tiene el mismo formato que una placa UNO. Shield para la placa Nano V3.0","title":"Placa Shield para Nano V3.0"},{"location":"conexionado-pruebas/NANO/elementos-N/#elementos-descritos-en-la-version-uno","text":"Los elementos que se relacionan a continuaci\u00f3n son exactamente los mismo que los usados en la versi\u00f3n UNO: Placa Drivers L298 Motores DC 3 a 6V Zumbador Sensores de infrarrojos Sensor de distancia HC-SR04 Servomotores Encoder infrarrojos FC-03","title":"Elementos descritos en la versi\u00f3n UNO"},{"location":"conexionado-pruebas/NANO/leer-antes/","text":"Aclaraciones sobre placas Nano \u00b6 Vamos a analizar y establecer las diferencias entre un Arduino Nano original y las versiones econ\u00f3micas de este, al menos en dos versiones de estas. Si vamos a trabajar con placas Arduino Nano originales podemos omitir la lectura de este apartado, pero si vamos a trabajar con clones (las conocidas como nanos chinos) es MUY IMPORTANTE que leamos detenidamente este apartado con el fin de averiguar que placa nano es la que tenemos en nuestras manos y as\u00ed poder actuar en consecuencia. Si hay que aclarar que este estudio se realiza para la versi\u00f3n nano convencional implementada con microcontroladores ATMega y no para la nueva l\u00ednea de productos cuyo cerebro se implementa con dispositivos microcontroladores SAMD21G18A. An\u00e1lisis del problema \u00b6 Conocemos que la alimentaci\u00f3n de la placas nano se puede hacer por mini-USB, por el conector 5V o por la entrada de alimentaci\u00f3n externa VIN, que se aconseja que est\u00e9 entre 7V y 12V de corriente continua. Aconsejamos consultar el tutorial Alimentar el Arduino: La gu\u00eda definitiva de Geek factory si no sabes bien de lo que estamos hablando. Cuando descendemos a nivel de esquema, las placas tipo Nano utilizan un diodo Schottky (diodo semiconductor que proporciona conmutaciones de menos de 1ns entre los estados de conducci\u00f3n directa e inversa) entre la alimentaci\u00f3n USB y Vcc que tiene como misi\u00f3n evitar que pueda pasar corriente desde la placa Nano al ordenador al que la tengamos conectada a trav\u00e9s del puerto USB cuando alimentamos con una fuente externa 6 a 12V en el pin VIN, que podr\u00eda provocar da\u00f1os en el mismo. En la imagen siguiente podemos ver este diodo en el esquema de un Arduino Nano original Diodo Schottky USB en Arduino Nano original Imagen obtenida a partir del esquema encontrado en arduino.cc En la imagen anterior vemos que el diodo es un SS1P3L, en algunas versiones podemos encontrar que el diodo es un MBR0520 (ya obsoleto) y en una placa real como la de la imagen siguiente que este diodo es un SKL14 de Diotec. Diodo Schottky USB SKL14 en Arduino Nano original Si consultamos los datasheet de estos diodos nos vamos a encontrar con los valores de corriente directa media que vemos en la tabla siguiente: Par\u00e1metro SS1P3L MBR0520 SKL14 Average Forward Rectified Current 1A 500mA 1A Si hacemos el mismo an\u00e1lisis para un clon como el de AZ-Delivery nos encontramos que ese diodo es un SD101CWS, tal y como vemos en la imagen siguiente: Diodo Schottky USB en Nano clon Imagen obtenida a partir del esquema encontrado en AZ-Delivery Si consultamos el datasheet de este diodo nos vamos a encontrar con el valor de corriente directa media que vemos en la tabla siguiente: Par\u00e1metro SD101CWS Average Forward Current 30mA Un poco mas de investigaci\u00f3n la podemos ver en la imagen siguiente, que se corresponde con la fotograf\u00eda de una placa Nano de AZ-Delivery. Diodo Schottky USB S4 en una Nano de AZ-Delivery Una b\u00fasqueda del datasheet de este componente nos lleva a obtenerla de Diodes y en este pdf obtenemos los datos que vemos en la imagen siguiente: Datasheet del diodo S4 Imagen obtenida a partir del datasheet de Diodes Observamos claramente que la corriente directa del diodo est\u00e1 por debajo de las especificaciones requeridas para una placa Nano por lo que debemos asegurarnos, cuando adquirimos este tipo de placas, del diodo que llevan y que al menos presente las especificaciones de 500mA en adelante. La experiencia indica que, aunque con estas placas podemos trabajar grabando el firmware, desconectando el USB y aliment\u00e1ndola con una fuente externa, tarde o temprano dejaremos conectado el USB, accionaremos la alimentaci\u00f3n externa y provocaremos una circulaci\u00f3n de corriente (si tenemos conectados suficientes dispositivos a la placa) mayor a la que soporta el diodo que se quemar\u00e1 y dejar\u00e1 la placa inservible. Recomendaciones \u00b6 L\u00f3gicamente la primera va a ser trabajar con placas originales que nos ofrecer\u00e1n todas las garant\u00edas por su contrastada calidad y su precio tampoco es demasiado elevado. Por ejemplo BricoGeek es un distribuidor que env\u00eda con bastante rapidez a precios muy razonables. En segundo lugar la recomendaci\u00f3n ser\u00eda la placa de Keyestudio ks0173 que distribuye oficialmente para Espa\u00f1a Innova Didactic por un precio de unos 7\u20ac y que tambi\u00e9n tiene una distribuci\u00f3n muy r\u00e1pida. En tercer lugar, aunque l\u00f3gicamente existen otros muchos fabricantes de clones, ser\u00eda Elegoo que en Espa\u00f1a podemos comprar a trav\u00e9s de Amazon un kit de tres placas muy bien embaladas y por unos 14\u20ac. Las versiones de Keyestudio (derecha) y Elegoo (izquierda) se construyen con un diodo tipo B2 tal y como vemos destacado en la imagen siguiente: Placas con diodo B2 B2 es el c\u00f3digo de dispositivo de los diodos tipo MBR0520LT1G, SBR80520LT1G, MBR0520LT3G, SBR80520LT3G tal y como podemos observar en la siguiente imagen: Datasheet diodo tipo B2 Imagen obtenida a partir del datasheet de On Semiconductor En esta hoja de datos podemos comprobar que la corriente directa de este diodo es la que se indica a continuaci\u00f3n: Par\u00e1metro MBR0520LT1G B2 Average Forward Current 500mA Es decir, la recomendaci\u00f3n final ser\u00eda que antes de comprar a la ligera este tipo de producto no nos guiemos solamente por su precio y miremos tambi\u00e9n la calidad.","title":"\u00a1MUY IMPORTANTE! Leer antes de seguir"},{"location":"conexionado-pruebas/NANO/leer-antes/#aclaraciones-sobre-placas-nano","text":"Vamos a analizar y establecer las diferencias entre un Arduino Nano original y las versiones econ\u00f3micas de este, al menos en dos versiones de estas. Si vamos a trabajar con placas Arduino Nano originales podemos omitir la lectura de este apartado, pero si vamos a trabajar con clones (las conocidas como nanos chinos) es MUY IMPORTANTE que leamos detenidamente este apartado con el fin de averiguar que placa nano es la que tenemos en nuestras manos y as\u00ed poder actuar en consecuencia. Si hay que aclarar que este estudio se realiza para la versi\u00f3n nano convencional implementada con microcontroladores ATMega y no para la nueva l\u00ednea de productos cuyo cerebro se implementa con dispositivos microcontroladores SAMD21G18A.","title":"Aclaraciones sobre placas Nano"},{"location":"conexionado-pruebas/NANO/leer-antes/#analisis-del-problema","text":"Conocemos que la alimentaci\u00f3n de la placas nano se puede hacer por mini-USB, por el conector 5V o por la entrada de alimentaci\u00f3n externa VIN, que se aconseja que est\u00e9 entre 7V y 12V de corriente continua. Aconsejamos consultar el tutorial Alimentar el Arduino: La gu\u00eda definitiva de Geek factory si no sabes bien de lo que estamos hablando. Cuando descendemos a nivel de esquema, las placas tipo Nano utilizan un diodo Schottky (diodo semiconductor que proporciona conmutaciones de menos de 1ns entre los estados de conducci\u00f3n directa e inversa) entre la alimentaci\u00f3n USB y Vcc que tiene como misi\u00f3n evitar que pueda pasar corriente desde la placa Nano al ordenador al que la tengamos conectada a trav\u00e9s del puerto USB cuando alimentamos con una fuente externa 6 a 12V en el pin VIN, que podr\u00eda provocar da\u00f1os en el mismo. En la imagen siguiente podemos ver este diodo en el esquema de un Arduino Nano original Diodo Schottky USB en Arduino Nano original Imagen obtenida a partir del esquema encontrado en arduino.cc En la imagen anterior vemos que el diodo es un SS1P3L, en algunas versiones podemos encontrar que el diodo es un MBR0520 (ya obsoleto) y en una placa real como la de la imagen siguiente que este diodo es un SKL14 de Diotec. Diodo Schottky USB SKL14 en Arduino Nano original Si consultamos los datasheet de estos diodos nos vamos a encontrar con los valores de corriente directa media que vemos en la tabla siguiente: Par\u00e1metro SS1P3L MBR0520 SKL14 Average Forward Rectified Current 1A 500mA 1A Si hacemos el mismo an\u00e1lisis para un clon como el de AZ-Delivery nos encontramos que ese diodo es un SD101CWS, tal y como vemos en la imagen siguiente: Diodo Schottky USB en Nano clon Imagen obtenida a partir del esquema encontrado en AZ-Delivery Si consultamos el datasheet de este diodo nos vamos a encontrar con el valor de corriente directa media que vemos en la tabla siguiente: Par\u00e1metro SD101CWS Average Forward Current 30mA Un poco mas de investigaci\u00f3n la podemos ver en la imagen siguiente, que se corresponde con la fotograf\u00eda de una placa Nano de AZ-Delivery. Diodo Schottky USB S4 en una Nano de AZ-Delivery Una b\u00fasqueda del datasheet de este componente nos lleva a obtenerla de Diodes y en este pdf obtenemos los datos que vemos en la imagen siguiente: Datasheet del diodo S4 Imagen obtenida a partir del datasheet de Diodes Observamos claramente que la corriente directa del diodo est\u00e1 por debajo de las especificaciones requeridas para una placa Nano por lo que debemos asegurarnos, cuando adquirimos este tipo de placas, del diodo que llevan y que al menos presente las especificaciones de 500mA en adelante. La experiencia indica que, aunque con estas placas podemos trabajar grabando el firmware, desconectando el USB y aliment\u00e1ndola con una fuente externa, tarde o temprano dejaremos conectado el USB, accionaremos la alimentaci\u00f3n externa y provocaremos una circulaci\u00f3n de corriente (si tenemos conectados suficientes dispositivos a la placa) mayor a la que soporta el diodo que se quemar\u00e1 y dejar\u00e1 la placa inservible.","title":"An\u00e1lisis del problema"},{"location":"conexionado-pruebas/NANO/leer-antes/#recomendaciones","text":"L\u00f3gicamente la primera va a ser trabajar con placas originales que nos ofrecer\u00e1n todas las garant\u00edas por su contrastada calidad y su precio tampoco es demasiado elevado. Por ejemplo BricoGeek es un distribuidor que env\u00eda con bastante rapidez a precios muy razonables. En segundo lugar la recomendaci\u00f3n ser\u00eda la placa de Keyestudio ks0173 que distribuye oficialmente para Espa\u00f1a Innova Didactic por un precio de unos 7\u20ac y que tambi\u00e9n tiene una distribuci\u00f3n muy r\u00e1pida. En tercer lugar, aunque l\u00f3gicamente existen otros muchos fabricantes de clones, ser\u00eda Elegoo que en Espa\u00f1a podemos comprar a trav\u00e9s de Amazon un kit de tres placas muy bien embaladas y por unos 14\u20ac. Las versiones de Keyestudio (derecha) y Elegoo (izquierda) se construyen con un diodo tipo B2 tal y como vemos destacado en la imagen siguiente: Placas con diodo B2 B2 es el c\u00f3digo de dispositivo de los diodos tipo MBR0520LT1G, SBR80520LT1G, MBR0520LT3G, SBR80520LT3G tal y como podemos observar en la siguiente imagen: Datasheet diodo tipo B2 Imagen obtenida a partir del datasheet de On Semiconductor En esta hoja de datos podemos comprobar que la corriente directa de este diodo es la que se indica a continuaci\u00f3n: Par\u00e1metro MBR0520LT1G B2 Average Forward Current 500mA Es decir, la recomendaci\u00f3n final ser\u00eda que antes de comprar a la ligera este tipo de producto no nos guiemos solamente por su precio y miremos tambi\u00e9n la calidad.","title":"Recomendaciones"},{"location":"conexionado-pruebas/NANO/test-N/","text":"Pruebas b\u00e1sicas de funcionamiento \u00b6 B\u00e1sicamente los ejemplos que utilizaremos para esta versi\u00f3n Nano son los mismos que los utilizados para la versi\u00f3n UNO realizando los cambios a la placa adecuada, que en nuestro caso va a ser una Nano con Old bootloader. Alimentaci\u00f3n \u00b6 Colocamos las pilas AA en su lugar respetando la polaridad de las mismas y accionamos el interruptor. Si todo es correcto en la placa shield y en la del driver L298 se debe encender un diodo LED rojo y en la placa Nano un LED verde, todos ellos indicativos de que est\u00e1n alimentadas, tal y como observamos en la imagen siguiente: Primer encendido Reutilizamos el programa blink.bloc para probar tambi\u00e9n que se graba correctamente firmware en la placa NANO. Para ello debemos seleccionar la placa adecuada, tal y como vemos en la imagen siguiente. Programa blink.bloc Si cargamos el programa y dejamos sin accionar el interruptor observaremos como parpadea el LED asociado al pin 13, de color rojo, en la placa Nano pero la placa del driver no est\u00e1 alimentada y por tanto su LED permanece apagado. En la animaci\u00f3n siguiente vemos el parpadeo del LED y el resultado de accionar el interruptor. Animaci\u00f3n que muestra el funcionamiento del programa blink.bloc y del interruptor Este GIF se ha creado a partir de un video en formato mp4 utilizando FFMPEG y GIMP y la informaci\u00f3n obtenida en este enlace . Pruebas id\u00e9nticas a las realizadas en la versi\u00f3n UNO \u00b6 Para las pruebas siguientes podemos simplemente cargar los ejemplos dados para la versi\u00f3n UNO y simplemente cambiando el tipo de placa ya podemos proceder a cargarlos y comprobar el funcionamiento de los elementos en cuesti\u00f3n. Motores Zumbador Sensores de infrarrojos Sensor de distancia HC-SR04 Servomotores Encoder infrarrojos FC-03","title":"Pruebas b\u00e1sicas de funcionamiento"},{"location":"conexionado-pruebas/NANO/test-N/#pruebas-basicas-de-funcionamiento","text":"B\u00e1sicamente los ejemplos que utilizaremos para esta versi\u00f3n Nano son los mismos que los utilizados para la versi\u00f3n UNO realizando los cambios a la placa adecuada, que en nuestro caso va a ser una Nano con Old bootloader.","title":"Pruebas b\u00e1sicas de funcionamiento"},{"location":"conexionado-pruebas/NANO/test-N/#alimentacion","text":"Colocamos las pilas AA en su lugar respetando la polaridad de las mismas y accionamos el interruptor. Si todo es correcto en la placa shield y en la del driver L298 se debe encender un diodo LED rojo y en la placa Nano un LED verde, todos ellos indicativos de que est\u00e1n alimentadas, tal y como observamos en la imagen siguiente: Primer encendido Reutilizamos el programa blink.bloc para probar tambi\u00e9n que se graba correctamente firmware en la placa NANO. Para ello debemos seleccionar la placa adecuada, tal y como vemos en la imagen siguiente. Programa blink.bloc Si cargamos el programa y dejamos sin accionar el interruptor observaremos como parpadea el LED asociado al pin 13, de color rojo, en la placa Nano pero la placa del driver no est\u00e1 alimentada y por tanto su LED permanece apagado. En la animaci\u00f3n siguiente vemos el parpadeo del LED y el resultado de accionar el interruptor. Animaci\u00f3n que muestra el funcionamiento del programa blink.bloc y del interruptor Este GIF se ha creado a partir de un video en formato mp4 utilizando FFMPEG y GIMP y la informaci\u00f3n obtenida en este enlace .","title":"Alimentaci\u00f3n"},{"location":"conexionado-pruebas/NANO/test-N/#pruebas-identicas-a-las-realizadas-en-la-version-uno","text":"Para las pruebas siguientes podemos simplemente cargar los ejemplos dados para la versi\u00f3n UNO y simplemente cambiando el tipo de placa ya podemos proceder a cargarlos y comprobar el funcionamiento de los elementos en cuesti\u00f3n. Motores Zumbador Sensores de infrarrojos Sensor de distancia HC-SR04 Servomotores Encoder infrarrojos FC-03","title":"Pruebas id\u00e9nticas a las realizadas en la versi\u00f3n UNO"},{"location":"conexionado-pruebas/UNO/conex/","text":"Conexionado de los distintos elementos \u00b6 Describimos el conexionado que debemos realizar entre los distintos elementos, y lo haremos fundamentalmente en forma de gr\u00e1fico y utilizando el pinout mostrado en la imagen siguiente. La fuente de esta imagen la tenemos en este archivo svg Masaylo-CRG UNO pinout Alimentaci\u00f3n \u00b6 Antes de nada vamos a resolver las conexiones de alimentaci\u00f3n de nuestra placa UNO y del driver de motores L298 junto con el portapilas y el interruptor. El resto de elementos se alimentar\u00e1n directamente de la placa UNO. El conexionado es v\u00e1lido si sustituimos las cinco (o seis) pilas AA por dos bater\u00edas tipo 18650. Para que la placa UNO y el driver queden conectados con el interruptor utilizaremos una clema de la que sacaremos un cable para el jack de alimentaci\u00f3n del UNO y otro para el positivo del driver, siendo este cable el que previamente pasa por el interruptor procedente del portapilas. El negativo es un cable doble que va al UNO y al driver sin pasar por el interruptor. En estas condiciones el jumper Regulador del driver debe estar colocado en su lugar y debemos tener en cuenta que la tensi\u00f3n de entrada caer\u00e1 en 0.7V debido al diodo protector de inversi\u00f3n de polaridad que lleva la placa. Esto lo podemos evitar utilizando el pin Vin de la tira de pines de alimentaci\u00f3n, pero debemos tener en cuenta que as\u00ed no hay protecci\u00f3n y que se recomienda no usar tensiones superiores a 6V. En nuestro caso usamos 5 pilas AA con lo que partimos de una tensi\u00f3n de 7.5V que bajar\u00e1 aproximadamente a 6.8V y si usamos 2x18650 tendremos 7.2V que se quedar\u00e1n en 6.5V. En la imagen siguiente tenemos el detalle de conexionado de la alimentaci\u00f3n para ambas placas que debemos realizar de forma cuidadosa en especial y no cambiar la polaridad de la alimentaci\u00f3n que se ha marcado y dibujado con los colores normalizados de la misma. Conexionado de alimentaci\u00f3n La forma m\u00e1s sencilla de conectar los elementos es utilizando un jack de alimentaci\u00f3n con clema como el que se ve en la imagen anterior aunque tambi\u00e9n podemos utilizar un jack normal realizando las correspondientes soldaduras. Se recomienda que una vez finalizadas las conexiones se revisen estas cuidadosamente, tanto en las conexiones en si mismas como en la polaridad, antes de alimentar el sistema o conectar el USB para grabar alg\u00fan programa, as\u00ed evitaremos en lo posible romper algo por mal conexionado. Motores DC 3 a 6V \u00b6 Procedemos a conectar los motores en las bornas del driver L298 de forma que el motor izquierdo quede conectado a OUT1 - OUT2 y el derecho a OUT3 - OUT4 que son los pines encargados de entregar energ\u00eda a los motores. Por ahora no nos preocupamos de la polaridad ya que lo haremos en las pruebas y si alg\u00fan motor girar en sentido contrario al esperado bastar\u00e1 con intercambiar sus conexiones de posici\u00f3n. En la imagen siguiente tenemos el conexionado de forma gr\u00e1fica. Conexionado de motores Los pines de control de cada motor se conectan como se indica en la gr\u00e1fica, de forma que ENA ser\u00e1 el control PWM del motor izquierdo que se har\u00e1 en el pin 6, e IN1 e IN2 los conectamos seg\u00fan el sentido de giro adecuado a los pines 7 y 8. Para el motor derecho el pin PWM es el 11 que ir\u00e1 a ENB y los IN3 e IN4 a los pines 12 y 13. Zumbador \u00b6 Usamos el pin D1 o TxD y su Vcc asociado para conectarlo. En principio esta conexi\u00f3n no debe interferir en la grabaci\u00f3n de programas en la placa que siempre se realiza utilizando los pines D0 y D1 de la misma, pero si nos da alg\u00fan problema basta con que desconectemos el pin D0 del sensor en uno de sus extremos, procedamos a grabar el programa correspondiente y una vez cargado este volvemos a conectar el pin en su lugar. Si no queremos estar escuchando pitidos de manera continuada cuando subimos c\u00f3digo a la placa o cuando usamos el monitor serie tambi\u00e9n debemos desconectar esta patilla. Alternativamente y en caso de no usar la funcionalidad Bluetooth podemos conectar el buzzer a uno de los pines reservados para esta funcionalidad en el pinout. En la imagen siguiente podemos ver el conexionado de estos elementos de forma gr\u00e1fica junto con los conectados anteriormente. Conexionado de conjunto incluyendo zumbador En la imagen siguiente observamos una pareja de cables, uno blanco que va al pin D1 y uno negro que va a GND. Conexionado del zumbador Pines de entrada anal\u00f3gica \u00b6 Antes de conectar los sensores de infrarrojos, que ir\u00e1n a los pines anal\u00f3gicos (aunque su salida es digital), vamos a explicar c\u00f3mo usar los pines anal\u00f3gicos como pines digitales en las placas Arduino. La explicaci\u00f3n original en ingl\u00e9s la podemos encontrar en el enlace \"Analog Input Pins\" . Convertidor A/D Los controladores ATmega utilizados para Arduino contienen un convertidor de anal\u00f3gico a digital integrado de 6 canales (8 canales en el Mini y Nano y 16 en el Mega) con una resoluci\u00f3n de 10 bits, devolviendo n\u00fameros enteros de 0 a 1023. Si bien la funci\u00f3n principal de los pines anal\u00f3gicos para la mayor\u00eda de los usuarios es leer sensores anal\u00f3gicos, los pines anal\u00f3gicos tambi\u00e9n tienen toda la funcionalidad de los pines de entrada/salida de prop\u00f3sito general (GPIO) (lo mismo que los pines digitales 0-13). Por tanto, si necesitamos m\u00e1s pines de entrada y salida de prop\u00f3sito general, y todos los pines anal\u00f3gicos no est\u00e1n en uso, estos pueden usarse para GPIO. Mapeo de pines Los pines anal\u00f3gicos se pueden usar de manera id\u00e9ntica a los pines digitales, usando los alias A0 (para la entrada anal\u00f3gica 0), A1, etc. Por ejemplo, el c\u00f3digo para configurar el pin A0 como salida y poner en alto ser\u00eda: pinMode(A0, OUTPUT); digitalWrite(A0, HIGH); Resistencias de pull-up Los pines anal\u00f3gicos tambi\u00e9n tienen resistencias pull-up, que funcionan de manera id\u00e9ntica a las de los pines digitales. Se habilitan emitiendo un comando del tipo: pinMode(A0, INPUT_PULLUP); // set pull-up on analog pin 0 . Hay que tener en cuenta que activar un pull-up afectar\u00e1 a los valores entregados por analogRead() . Advertencias El comando analogRead() no funcionar\u00e1 correctamente si el pin lo hemos configurado previamente como salida. Si hemos puesto el pin en estado alto estando configurado como salida, la resistencia de pull-up se configurar\u00e1 de nuevo cuando se vuelva a cambiar a entrada. La hoja de datos de ATmega advierte que el cambio de pines anal\u00f3gicos a digitales puede introducir jitter o ruido no deseado en las lecturas anal\u00f3gicas del resto de pines. Se aconseja, despu\u00e9s de poner los pines anal\u00f3gicos en modo digital, agregar un retardo corto antes de usar analogRead() . Sensores de infrarrojos \u00b6 Una vez vista la explicaci\u00f3n sobre pines anal\u00f3gicos utilizados como digitales diremos que vamos a conectar el sensor de infrarrojos izquierdo al pin A0 y el derecho al pin A1. Hay que tener especial cuidado en que los pines marcados con VCC y GND se conecten a los pines V y G respectivamente de la placa UNO. En la imagen siguiente podemos ver el conexionado de estos elementos de forma gr\u00e1fica junto con los conectados anteriormente. Conexionado del conjunto incluyendo los sensores de infrarrojos En la imagen siguiente vemos el detalle de conexionado de los sensores de infrarrojos. Detalle del conexionado de los sensores de infrarrojos Una fotograf\u00eda del detalle del conexionado en el robot la vemos a continuaci\u00f3n. Fotograf\u00eda del conexionado de los sensores de infrarrojos Sensor de distancia HC-SR04 \u00b6 De nuevo utilizamos dos pines anal\u00f3gicos como digitales por lo que debemos tener en cuenta lo referido anteriormente sobre el tema. Vamos a conectar el Trigger del sensor al pin A2 que deberemos configurar como salida y el pin Echo a A3 que deberemos configurar como entrada. En caso de utilizar MasayloBlockly o la librer\u00eda descrita en este tutorial estas definiciones estar\u00e1n ya realizadas. En la imagen siguiente podemos ver el conexionado de estos elementos de forma gr\u00e1fica junto con los conectados anteriormente. Se han omitido intencionadamente los cables de alimentaci\u00f3n del sensor para mayor claridad de la imagen. Conexionado del conjunto incluyendo el sensor de ultrasonidos HC-SR04 En la imagen siguiente vemos el detalle de conexionado del sensor de ultrasonidos HC-SR04 incluidos los pines de alimentaci\u00f3n. Detalle del conexionado del sensor de ultrasonidos HC-SR04 Una fotograf\u00eda del detalle del conexionado en el robot la vemos a continuaci\u00f3n. Fotograf\u00eda del conexionado del sensor de ultrasonidos HC-SR04 Servomotores \u00b6 En este caso los pines que utilizaremos son los digitales 4 y 5, el primero para el brazo y el segundo para la cabeza. En la imagen siguiente podemos ver el conexionado de estos elementos de forma gr\u00e1fica junto con los conectados anteriormente. Se han omitido de nuevo las conexiones de alimentaci\u00f3n. Conexionado del conjunto incluyendo los servos de brazo y cabeza En la imagen siguiente vemos el detalle de conexionado de los dos servos SG90. Detalle del conexionado de los servos de brazo y cabeza Una fotograf\u00eda del detalle del conexionado en el robot la vemos a continuaci\u00f3n. Fotograf\u00eda del conexionado de los servos de brazo y cabeza Encoder infrarrojos FC-03 \u00b6 En este caso los pines que utilizaremos son los digitales 2 y 3, que son los pines que admiten interrupciones en las placas tipo UNO, Nano, Mega, Mini y Leonardo. En la imagen siguiente (se omiten los cables de alimentaci\u00f3n para mayor claridad) podemos ver el conexionado de estos elementos de forma gr\u00e1fica junto con los conectados anteriormente. Conexionado del conjunto incluyendo los encoders En la imagen siguiente vemos el detalle de conexionado de los dos encoder FC-03. Detalle del conexionado de los encoder FC-03 Una fotograf\u00eda del detalle del conexionado en el robot la vemos a continuaci\u00f3n. Fotograf\u00eda del conexionado de los encoder FC-03","title":"Conexionado"},{"location":"conexionado-pruebas/UNO/conex/#conexionado-de-los-distintos-elementos","text":"Describimos el conexionado que debemos realizar entre los distintos elementos, y lo haremos fundamentalmente en forma de gr\u00e1fico y utilizando el pinout mostrado en la imagen siguiente. La fuente de esta imagen la tenemos en este archivo svg Masaylo-CRG UNO pinout","title":"Conexionado de los distintos elementos"},{"location":"conexionado-pruebas/UNO/conex/#alimentacion","text":"Antes de nada vamos a resolver las conexiones de alimentaci\u00f3n de nuestra placa UNO y del driver de motores L298 junto con el portapilas y el interruptor. El resto de elementos se alimentar\u00e1n directamente de la placa UNO. El conexionado es v\u00e1lido si sustituimos las cinco (o seis) pilas AA por dos bater\u00edas tipo 18650. Para que la placa UNO y el driver queden conectados con el interruptor utilizaremos una clema de la que sacaremos un cable para el jack de alimentaci\u00f3n del UNO y otro para el positivo del driver, siendo este cable el que previamente pasa por el interruptor procedente del portapilas. El negativo es un cable doble que va al UNO y al driver sin pasar por el interruptor. En estas condiciones el jumper Regulador del driver debe estar colocado en su lugar y debemos tener en cuenta que la tensi\u00f3n de entrada caer\u00e1 en 0.7V debido al diodo protector de inversi\u00f3n de polaridad que lleva la placa. Esto lo podemos evitar utilizando el pin Vin de la tira de pines de alimentaci\u00f3n, pero debemos tener en cuenta que as\u00ed no hay protecci\u00f3n y que se recomienda no usar tensiones superiores a 6V. En nuestro caso usamos 5 pilas AA con lo que partimos de una tensi\u00f3n de 7.5V que bajar\u00e1 aproximadamente a 6.8V y si usamos 2x18650 tendremos 7.2V que se quedar\u00e1n en 6.5V. En la imagen siguiente tenemos el detalle de conexionado de la alimentaci\u00f3n para ambas placas que debemos realizar de forma cuidadosa en especial y no cambiar la polaridad de la alimentaci\u00f3n que se ha marcado y dibujado con los colores normalizados de la misma. Conexionado de alimentaci\u00f3n La forma m\u00e1s sencilla de conectar los elementos es utilizando un jack de alimentaci\u00f3n con clema como el que se ve en la imagen anterior aunque tambi\u00e9n podemos utilizar un jack normal realizando las correspondientes soldaduras. Se recomienda que una vez finalizadas las conexiones se revisen estas cuidadosamente, tanto en las conexiones en si mismas como en la polaridad, antes de alimentar el sistema o conectar el USB para grabar alg\u00fan programa, as\u00ed evitaremos en lo posible romper algo por mal conexionado.","title":"Alimentaci\u00f3n"},{"location":"conexionado-pruebas/UNO/conex/#motores-dc-3-a-6v","text":"Procedemos a conectar los motores en las bornas del driver L298 de forma que el motor izquierdo quede conectado a OUT1 - OUT2 y el derecho a OUT3 - OUT4 que son los pines encargados de entregar energ\u00eda a los motores. Por ahora no nos preocupamos de la polaridad ya que lo haremos en las pruebas y si alg\u00fan motor girar en sentido contrario al esperado bastar\u00e1 con intercambiar sus conexiones de posici\u00f3n. En la imagen siguiente tenemos el conexionado de forma gr\u00e1fica. Conexionado de motores Los pines de control de cada motor se conectan como se indica en la gr\u00e1fica, de forma que ENA ser\u00e1 el control PWM del motor izquierdo que se har\u00e1 en el pin 6, e IN1 e IN2 los conectamos seg\u00fan el sentido de giro adecuado a los pines 7 y 8. Para el motor derecho el pin PWM es el 11 que ir\u00e1 a ENB y los IN3 e IN4 a los pines 12 y 13.","title":"Motores DC 3 a 6V"},{"location":"conexionado-pruebas/UNO/conex/#zumbador","text":"Usamos el pin D1 o TxD y su Vcc asociado para conectarlo. En principio esta conexi\u00f3n no debe interferir en la grabaci\u00f3n de programas en la placa que siempre se realiza utilizando los pines D0 y D1 de la misma, pero si nos da alg\u00fan problema basta con que desconectemos el pin D0 del sensor en uno de sus extremos, procedamos a grabar el programa correspondiente y una vez cargado este volvemos a conectar el pin en su lugar. Si no queremos estar escuchando pitidos de manera continuada cuando subimos c\u00f3digo a la placa o cuando usamos el monitor serie tambi\u00e9n debemos desconectar esta patilla. Alternativamente y en caso de no usar la funcionalidad Bluetooth podemos conectar el buzzer a uno de los pines reservados para esta funcionalidad en el pinout. En la imagen siguiente podemos ver el conexionado de estos elementos de forma gr\u00e1fica junto con los conectados anteriormente. Conexionado de conjunto incluyendo zumbador En la imagen siguiente observamos una pareja de cables, uno blanco que va al pin D1 y uno negro que va a GND. Conexionado del zumbador","title":"Zumbador"},{"location":"conexionado-pruebas/UNO/conex/#pines-de-entrada-analogica","text":"Antes de conectar los sensores de infrarrojos, que ir\u00e1n a los pines anal\u00f3gicos (aunque su salida es digital), vamos a explicar c\u00f3mo usar los pines anal\u00f3gicos como pines digitales en las placas Arduino. La explicaci\u00f3n original en ingl\u00e9s la podemos encontrar en el enlace \"Analog Input Pins\" . Convertidor A/D Los controladores ATmega utilizados para Arduino contienen un convertidor de anal\u00f3gico a digital integrado de 6 canales (8 canales en el Mini y Nano y 16 en el Mega) con una resoluci\u00f3n de 10 bits, devolviendo n\u00fameros enteros de 0 a 1023. Si bien la funci\u00f3n principal de los pines anal\u00f3gicos para la mayor\u00eda de los usuarios es leer sensores anal\u00f3gicos, los pines anal\u00f3gicos tambi\u00e9n tienen toda la funcionalidad de los pines de entrada/salida de prop\u00f3sito general (GPIO) (lo mismo que los pines digitales 0-13). Por tanto, si necesitamos m\u00e1s pines de entrada y salida de prop\u00f3sito general, y todos los pines anal\u00f3gicos no est\u00e1n en uso, estos pueden usarse para GPIO. Mapeo de pines Los pines anal\u00f3gicos se pueden usar de manera id\u00e9ntica a los pines digitales, usando los alias A0 (para la entrada anal\u00f3gica 0), A1, etc. Por ejemplo, el c\u00f3digo para configurar el pin A0 como salida y poner en alto ser\u00eda: pinMode(A0, OUTPUT); digitalWrite(A0, HIGH); Resistencias de pull-up Los pines anal\u00f3gicos tambi\u00e9n tienen resistencias pull-up, que funcionan de manera id\u00e9ntica a las de los pines digitales. Se habilitan emitiendo un comando del tipo: pinMode(A0, INPUT_PULLUP); // set pull-up on analog pin 0 . Hay que tener en cuenta que activar un pull-up afectar\u00e1 a los valores entregados por analogRead() . Advertencias El comando analogRead() no funcionar\u00e1 correctamente si el pin lo hemos configurado previamente como salida. Si hemos puesto el pin en estado alto estando configurado como salida, la resistencia de pull-up se configurar\u00e1 de nuevo cuando se vuelva a cambiar a entrada. La hoja de datos de ATmega advierte que el cambio de pines anal\u00f3gicos a digitales puede introducir jitter o ruido no deseado en las lecturas anal\u00f3gicas del resto de pines. Se aconseja, despu\u00e9s de poner los pines anal\u00f3gicos en modo digital, agregar un retardo corto antes de usar analogRead() .","title":"Pines de entrada anal\u00f3gica"},{"location":"conexionado-pruebas/UNO/conex/#sensores-de-infrarrojos","text":"Una vez vista la explicaci\u00f3n sobre pines anal\u00f3gicos utilizados como digitales diremos que vamos a conectar el sensor de infrarrojos izquierdo al pin A0 y el derecho al pin A1. Hay que tener especial cuidado en que los pines marcados con VCC y GND se conecten a los pines V y G respectivamente de la placa UNO. En la imagen siguiente podemos ver el conexionado de estos elementos de forma gr\u00e1fica junto con los conectados anteriormente. Conexionado del conjunto incluyendo los sensores de infrarrojos En la imagen siguiente vemos el detalle de conexionado de los sensores de infrarrojos. Detalle del conexionado de los sensores de infrarrojos Una fotograf\u00eda del detalle del conexionado en el robot la vemos a continuaci\u00f3n. Fotograf\u00eda del conexionado de los sensores de infrarrojos","title":"Sensores de infrarrojos"},{"location":"conexionado-pruebas/UNO/conex/#sensor-de-distancia-hc-sr04","text":"De nuevo utilizamos dos pines anal\u00f3gicos como digitales por lo que debemos tener en cuenta lo referido anteriormente sobre el tema. Vamos a conectar el Trigger del sensor al pin A2 que deberemos configurar como salida y el pin Echo a A3 que deberemos configurar como entrada. En caso de utilizar MasayloBlockly o la librer\u00eda descrita en este tutorial estas definiciones estar\u00e1n ya realizadas. En la imagen siguiente podemos ver el conexionado de estos elementos de forma gr\u00e1fica junto con los conectados anteriormente. Se han omitido intencionadamente los cables de alimentaci\u00f3n del sensor para mayor claridad de la imagen. Conexionado del conjunto incluyendo el sensor de ultrasonidos HC-SR04 En la imagen siguiente vemos el detalle de conexionado del sensor de ultrasonidos HC-SR04 incluidos los pines de alimentaci\u00f3n. Detalle del conexionado del sensor de ultrasonidos HC-SR04 Una fotograf\u00eda del detalle del conexionado en el robot la vemos a continuaci\u00f3n. Fotograf\u00eda del conexionado del sensor de ultrasonidos HC-SR04","title":"Sensor de distancia HC-SR04"},{"location":"conexionado-pruebas/UNO/conex/#servomotores","text":"En este caso los pines que utilizaremos son los digitales 4 y 5, el primero para el brazo y el segundo para la cabeza. En la imagen siguiente podemos ver el conexionado de estos elementos de forma gr\u00e1fica junto con los conectados anteriormente. Se han omitido de nuevo las conexiones de alimentaci\u00f3n. Conexionado del conjunto incluyendo los servos de brazo y cabeza En la imagen siguiente vemos el detalle de conexionado de los dos servos SG90. Detalle del conexionado de los servos de brazo y cabeza Una fotograf\u00eda del detalle del conexionado en el robot la vemos a continuaci\u00f3n. Fotograf\u00eda del conexionado de los servos de brazo y cabeza","title":"Servomotores"},{"location":"conexionado-pruebas/UNO/conex/#encoder-infrarrojos-fc-03","text":"En este caso los pines que utilizaremos son los digitales 2 y 3, que son los pines que admiten interrupciones en las placas tipo UNO, Nano, Mega, Mini y Leonardo. En la imagen siguiente (se omiten los cables de alimentaci\u00f3n para mayor claridad) podemos ver el conexionado de estos elementos de forma gr\u00e1fica junto con los conectados anteriormente. Conexionado del conjunto incluyendo los encoders En la imagen siguiente vemos el detalle de conexionado de los dos encoder FC-03. Detalle del conexionado de los encoder FC-03 Una fotograf\u00eda del detalle del conexionado en el robot la vemos a continuaci\u00f3n. Fotograf\u00eda del conexionado de los encoder FC-03","title":"Encoder infrarrojos FC-03"},{"location":"conexionado-pruebas/UNO/elementos/","text":"Descripci\u00f3n de placas y sensores \u00b6 En este apartado vamos a realizar una descripci\u00f3n b\u00e1sica de las distintas placas, sensores y elementos que se utilizan en la construcci\u00f3n del robot. Placa Keyestudio UNO Ks0172 \u00b6 Se trata de la placa Ks0172 basada en Arduino UNO con el microcontrolador ATmega328P que incorpora conectores de 3 pines que incluyen la patilla asociada y la alimentaci\u00f3n y que facilita el conexionado de elementos sin necesidad de utilizar protoboard. En la imagen siguiente podemos ver esta placa con sus descripciones b\u00e1sicas y este es el enlace al archivo fuente . Placa Keyestudio UNO Ks0172 IMPORTANTE: El interruptor deslizante permite escoger entre las alimentaciones de 5V o 3.3V. En nuestro caso nos aseguraremos de que est\u00e1 en la posici\u00f3n 5V . Tambi\u00e9n es importante tener disponible un gr\u00e1fico con la funcionalidad de cada pin o diagrama pinout como el que vemos en la imagen siguiente y este es el enlace a su archivo fuente Pinout de la Placa Keyestudio UNO Ks0172 Placa Drivers L298 \u00b6 Esta placa est\u00e1 basada en el chip L298N y permite controlar la velocidad y el sentido de giro de dos motores de corriente continua o un motor paso a paso bipolar con un consumo m\u00e1ximo de dos amperios. Cuenta con diodos de protecci\u00f3n y un regulador LM7805 que suministra 5V a la parte l\u00f3gica del integrado L298N. Se disponen jumpers de selecci\u00f3n para habilitar cada una de las salidas del m\u00f3dulo (A y B). La salida A esta conformada por OUT1 y OUT2 y la salida B por OUT3 y OUT4. Los pines de habilitaci\u00f3n son ENA y ENB (Enable A y Enable B) respectivamente. En la siguiente imagen vemos esta placa con sus descripciones b\u00e1sicas y este es el enlace al archivo fuente . Placa L298 Este m\u00f3dulo con el L298N nos permite alimentar nuestro Arduino a partir de la salida de 5V con un l\u00edmite de 500 mA. Debemos tambi\u00e9n tener presente que el m\u00f3dulo entrega una tensi\u00f3n a los motores en torno a 3V menor que la tensi\u00f3n a la que lo alimentamos. Los pines Vin y GND son los de alimentaci\u00f3n del m\u00f3dulo con una tensi\u00f3n que puede ir de 3V a 35V. El pin Vlog (Vl\u00f3gico) tiene dos modos de funcionamiento dependiendo de que el jumper Regulador est\u00e9 o no colocado. Las condiciones de funcionamiento son: Jumper colocado: El regulador LM7805 est\u00e1 activado y en Vlog habr\u00e1 una tensi\u00f3n de 5V siempre que el m\u00f3dulo est\u00e9 alimentado con una tensi\u00f3n m\u00e1xima de hasta 12V. Si lo alimentamos con una tensi\u00f3n superior tendremos que quitar el jumper y alimentar con 5V la l\u00f3gica del m\u00f3dulo a trav\u00e9s de este pin. Jumper sin colocar: El regulador LM7805 est\u00e1 desactivado y tenemos que alimentar la l\u00f3gica del m\u00f3dulo a trav\u00e9s de Vlog. Debemos tener \u00a1Cuidado! si introducimos corriente por Vlog con el jumper de regulaci\u00f3n colocado podemos provocar da\u00f1os en el m\u00f3dulo. El resto de conexiones se utilizan para el control de motores y para el caso de motores DC su utilizaci\u00f3n es la siguiente: Salidas para motores: Entregan la energ\u00eda para mover los motores y debemos conectarlo de forma que cuando marquemos, por ejemplo, mover adelante ambos motores giren en el mismo sentido. Si no lo hacen basta con invertir la polaridad de la conexi\u00f3n. Pines IN1 a IN4: IN1 e IN2 permiten controlar el sentido de giro del motor A mientras que IN3 e IN4 lo hacen con el del motor B. En la tabla siguiente se resume el funcionamiento de estos pines. IN1 IN2 IN3 IN4 Sentido de Giro High Low High Low Directo Low High Low High Inverso Low Low Low Low Paro Velocidad de giro: Tenemos que quitar los jumpers y usar los pines ENA y ENB. Estos pines debemos conectarlos a dos salidas PWM de la placa Arduino para poder enviarle un valor entre 0 y 255 que controle la velocidad de giro. Con los jumpers colocados, los motores girar\u00e1n siempre a la misma velocidad. Motores DC 3 a 6V \u00b6 Motor de continua de 3V a 6V con doble eje y caja reductora. El doble eje facilita la colocaci\u00f3n de un encoder \u00f3ptico para realizar un control de velocidad en lazo cerrado. En la tabla siguiente se resumen los principales par\u00e1metros de estos motores con una reductora 48:1 para distintas tensiones de alimentaci\u00f3n. 3V 5V 6V Velocidad sin carga 125 rpm 200 rpm 230 rpm velocidad con carga 95 rpm 160 rpm 175 rpm Torque 7.8 Ncm 9.8 Ncm 10.8 Ncm Consumo 100 a 130 mA 120 a 140 mA 130 a 150 mA El aspecto f\u00edsico de estos motores lo vemos en la imagen siguiente. Motores DC 3 a 6V Zumbador \u00b6 Si queremos reproducir sonidos de forma sencilla y econ\u00f3mica podemos utilizar un zumbador o buzzer pasivo como el que vemos en la imagen siguiente. Zumbador pasivo El dispositivo suele venir con una pegatina que debemos retirar para que el sonido salga con toda su potencia del mismo. Esta pegatina tiene utilidad en procesos de fabricaci\u00f3n automatizada para proteger al buzzer en la fase de lavado. Normalmente no tienen polaridad, pero si est\u00e1 marcada en la carcasa o es distinguible por la diferente longitud de los pines lo mejor es respetarla, siendo normalmente el pin marcado el positivo o patilla mas larga. El buzzer pasivo, a diferencia del activo, no tiene un oscilador interno y esto obliga a generar la frecuencia desde Arduino, para ello disponemos de la funci\u00f3n tone() que implementa el IDE. Sensores de infrarrojos \u00b6 Hemos optado por poner al robot una pareja de sensores de reflexi\u00f3n fotoel\u00e9ctrica con distancia de detecci\u00f3n ajustable entre 2 y 30cm (20 y 300mm), conocido como sensor de infrarrojos FC-51, como el que vemos en la imagen siguiente, donde se indica el potenci\u00f3metro de ajuste de distancia, el diodo emisor de IR y el fototransistor o detector de reflexi\u00f3n. Respecto a la distancia de detecci\u00f3n indicar que la citada anteriormente es la que la inmensa mayor\u00eda de vendedores ponen y, aunque hay algunos que reducen esta distancia bastante, es algo que debemos experimentar nosotros mismos teniendo en cuenta las condiciones de luminosidad en las que estemos trabajando. Modelo de sensor IR escogido Recordemos el funcionamiento b\u00e1sico del sistema. El LED infrarrojo emite luz infrarroja, o sea, de menor frecuencia (o mayor longitud de onda) que la que nuestros ojos nos permiten ver, es decir, para nosotros es invisible. El sensor que hemos elegido funciona cuando esta luz choca contra una superficie negra que la reflejar\u00e1 y llegar\u00e1 al fototransistor. Existen muchas clases de sensores de este tipo y hemos escogido este por su amplio rango de ajuste y su posibilidad de montaje vertical. Utilizando un par de estos sensores podemos seguir una linea detectando si se sale por la derecha o por la izquierda de la misma y rectificar la direcci\u00f3n de avance hasta conseguir estar de nuevo en la l\u00ednea. Este sensor tiene 3 pines de conexi\u00f3n, Vcc o 5V y GND para la alimentaci\u00f3n y D0 u OUT como salida de se\u00f1al que indicar\u00e1 si est\u00e1 llegando o no el reflejo del LED al fototransistor. En el esquema de la imagen siguiente se puede estudiar el funcionamiento electr\u00f3nico de esta plaquita. Esquema sensor infrarrojos El LM393 est\u00e1 configurado como comparador entre el nivel de tensi\u00f3n ajustado mediante VR1 que es entregado al terminal inversor y el nivel de entrada en el terminal no inversor, que va a depender de si el fototransistor recibe o no reflexi\u00f3n del infrarrojo emitido por el LED, si est\u00e1 recibiendo reflexi\u00f3n el fototransistor se encender\u00e1 el LED indicador de estado y tenemos el estado bajo o LOW en D0. Si no se recibe reflexi\u00f3n el LED no se iluminar\u00e1 y se env\u00eda un estado alto o HIGH a D0. Mediante el potenci\u00f3metro ajustamos la sensibilidad del fotorreceptor. Sensor de distancia HC-SR04 \u00b6 El sensor genera y emite una serie de tonos de ultrasonidos a una frecuencia de 40 kHz (no perceptibles al o\u00eddo humano) que si rebotan en una superficie vuelven y son captados por un micr\u00f3fono receptor de ultrasonidos que incorpora el propio sensor. Midiendo el tiempo que tardan en volver los tonos enviados podemos calcular la distancia a la que se encuentra el objeto sobre el que han rebotado. El propio circuito realiza los c\u00e1lculos necesarios para determinar la distancia a la que est\u00e1 la superficie. El sistema es similar al que usan algunos animales como ballenas, murci\u00e9lagos y delfines, para localizar obst\u00e1culos y presas. El HC-SR04 es un sensor de distancia de baja precisi\u00f3n, en teor\u00eda con un rango de medici\u00f3n de 2cm a 400 cm, con una resoluci\u00f3n de 0.3cm, pero en la pr\u00e1ctica se limita a un rango entre 20cm y 2 metros. El aspecto del HC-SR04 es muy caracter\u00edstico y se reconoce con facilidad porque tiene dos \"ojos\" que realmente son los dispositivos de emisi\u00f3n y recepci\u00f3n de ultrasonidos que integra este m\u00f3dulo, y es justo por esto por lo que hemos dotado al robot de una cabeza giratoria que en el funcionamiento parecer\u00e1 que el robot mira a un lado y otro. En la imagen siguiente vemos el aspecto real del sensor y el principio de funcionamiento de forma gr\u00e1fica. Aspecto del HC-SR04 y principio de funcionamiento Las caracter\u00edsticas t\u00e9cnicas m\u00e1s relevantes del HC-SR04 son: Dispone de 4 pines, dos son para alimentaci\u00f3n (Vcc) y masa (GND), disparador (Trigger) y receptor (Echo). En la imagen siguiente se aprecian claramente como est\u00e1n distribuidos estos pines en el sensor. Pinout del HC-SR04 Imagen basada en la publicada en theengineeringprojects Alimentaci\u00f3n: 5v Frecuencia de ultrasonidos: 40 Khz Consumos: en stand-by menor de 2mA y trabajando en torno a 15mA \u00c1ngulo: menor de 15\u00ba Veamos ahora en que se basan los c\u00e1lculos que realiza el sensor. En principio lo que hace, como ya se ha indicado, es contar el tiempo desde que se envia el pulso hasta que se recibe respuesta con lo que se puede determinar la distancia. Recordemos que: velocidad=\\dfrac{espacio}{tiempo}\\Rightarrow espacio=velocidad\\cdot tiempo velocidad=\\dfrac{espacio}{tiempo}\\Rightarrow espacio=velocidad\\cdot tiempo La velocidad es la del sonido es de 343 m/s a 20 \u00baC y un 50% de humedad relativa. A nosotros nos va a interesar expresar esta velocidad en cm/us, para lo que hacemos lo siguiente: 343\\dfrac{m}{s}\\cdot 100\\dfrac{cm}{m}\\cdot \\dfrac{1}{1000000}\\dfrac{s}{\\mu s}=0.0343\\dfrac{cm}{\\mu s}\\Rightarrow espacio-ida=0.0343\\cdot tiempo 343\\dfrac{m}{s}\\cdot 100\\dfrac{cm}{m}\\cdot \\dfrac{1}{1000000}\\dfrac{s}{\\mu s}=0.0343\\dfrac{cm}{\\mu s}\\Rightarrow espacio-ida=0.0343\\cdot tiempo Es decir, el sonido tarda 0.0343 microsegundos en recorrer un cent\u00edmetro, que ser\u00e1 el tiempo que tarda el sonido en ir desde el amisor al objeto en el que rebota. Teniendo en cuenta que desde que se emite el pulso, rebota y es recibido el espacio recorrido ser\u00e1 aproximadamente el doble que el calculado podemos expresar la distancia o espacio recorrido como: espacio=\\dfrac{espacio-ida}{2}=0.01715\\cdot tiempo espacio=\\dfrac{espacio-ida}{2}=0.01715\\cdot tiempo Ecuaci\u00f3n que nos permite saber la distancia a la que se encuentra un determinado objeto. Servomotores \u00b6 Los servomotores, abreviado servos, son motores de corriente continua que adem\u00e1s tienen una reductora con el fin de disminuir su velocidad de giro y aumentar el par motor en el eje. Tambi\u00e9n incorporan sistema electr\u00f3nico de control que permite hacerlos girar un determinado \u00e1ngulo. Esa electr\u00f3nica permite al servo saber en todo momento cual es su posici\u00f3n. Generalmente giran menos de una vuelta completa, 180\u00ba es bastante com\u00fan, aunque tienen un \u00e1ngulo variable seg\u00fan el modelo, pero existen ya servos de rotaci\u00f3n continua que giran 360 grados. Existen infinidad de modelos de servomotor y en nuestro caso vamos a utilizar Micro Servos del tipo 9g SG90. En la imagen siguiente vemos el aspecto y los elementos que incorporan este tipo de servos. Aspecto y elementos de los servos 9g SG90 Los servos tienen un funcionamiento muy parecido y la programaci\u00f3n suele variar muy poco de unos a otros, aunque siempre es conveniente mirar el datasheet del que vamos a utilizar para mayor seguridad. Debido a que la resoluci\u00f3n de la se\u00f1al PWM que podemos conseguir con una placa tipo UNO el \u00e1ngulo de giro que podremos mover un servo ser\u00e1 mayor de un grado, aunque el servo puede moverse con una resoluci\u00f3n mayor. Las caracter\u00edsticas de la se\u00f1al PWM nos indican que debemos generar un pulso de trabajo entre 1 ms y 2 ms y con un periodo de 20 ms (50 Hz), es decir, solamente podremos cambiar de posici\u00f3n del servo cada 20 ms. Los microservos se pueden alimentar directamente de la placa UNO dado que su consumo es lo suficientemente bajo para ello, pero si es necesario, dependiendo del modelo de servo, habr\u00e1 que alimentarlo con una fuente externa teniendo siempre la precauci\u00f3n de que las GNDs de la placa UNO y del servo queden interconectadas. Los colores usuales de los tres cables que salen del servo son los siguientes: Negro o Marr\u00f3n: GND Rojo: Alimentaci\u00f3n Blanco o Naranja: Se\u00f1al de control del servo (pulso enviado al servomotor) En la imagen siguiente se corrobora esta informaci\u00f3n. Colores de los cables en los servos 9g SG90 Encoder infrarrojos FC-03 \u00b6 Se trata de elementos basados en fotointerruptores de ranura como los que vemos en la imagen izquierda siguiente. A partir de estos se fabrican placas preparadas para conectar a Arduino como las que se ven en la imagen de la derecha siguiente. Izquierda: fotointerruptor de ranura - Derecha: sensor FC-03 Los dispositivos basados en optointerruptores son ampliamente utilizados como encoders para detectar la velocidad de giro y la posici\u00f3n del eje de motores. Para realizar esta tarea se emplean discos opacos ranurados que se acoplan al eje del motor, aunque tambi\u00e9n se pueden emplear elementos translucidos sobre los que se dibujan franjas negras. En la imagen siguiente vemos algunos de estos discos. Diferentes tipos de discos para encoder \u00f3ptico Con el sensor FC-03, que incluye comparador LM393 , podemos calcular la velocidad de rotaci\u00f3n de las ruedas de un robot. El funcionamiento b\u00e1sico del sensor es el siguiente; Si hacemos pasar una rueda dentada entre la ranura del sensor, este crea un pulso digital TTL en el pin D0, que podemos leer sin ning\u00fan problema en nuestra placa UNO. En la imagen siguiente vemos detalladas las diferentes partes del encoder. Pinout y partes del sensor FC-03 Los pines de conexi\u00f3n del encoder FC-03 de la imagen anterior los podemos describir de la siguiente forma: Vcc: Tensi\u00f3n de alimentaci\u00f3n del m\u00f3dulo de 3,3V a 12V. Se recomienda 3,3V GND: Masa o referencia 0V D0: Salida de se\u00f1al digital de pulsos TTL A0: Salida de se\u00f1al anal\u00f3gica de los pulsos de salida. Se trata de la se\u00f1al de salida en tiempo real que usualmente no se utiliza Como principales caracter\u00edsticas t\u00e9cnicas definimos las siguientes: Anchura de la ranura: 5mm LED indicador de alimentaci\u00f3n LED indicador de los pulsos de salida del pin D0. Este tipo de encoder suele dar problemas a la hora de leer los pulsos digitales generados por el comparador LM393, y estos consisten en que la placa UNO lee m\u00e1s pulsos de los que se generan realmente, en la pr\u00e1ctica del orden de cuatro veces m\u00e1s. En la imagen siguiente vemos el esquema del circuito que monta este encoder FC-03. Esquema interno del sensor FC-03 Podemos observar en este esquema como el comparador LM393 est\u00e1 configurado como de lazo abierto (no existe realimentaci\u00f3n) lo que hace que el mismo sea extremadamente sensible a los cambios que se producen en la entrada, bien sean provocados por el sensor de ranura (los deseados) o bien por ruidos generados por la propia alimentaci\u00f3n del sensor, los motores u otros elementos (pulsos no deseados) que puedan afectar a la se\u00f1al de salida. Es decir, que la se\u00f1al TTL presentar\u00e1 tanto en los flancos de subida como de bajada una serie de pulsos o rebotes que la placa UNO es capaz de leer e interpretar. La soluci\u00f3n al problema de los pulsos no deseados puede implementarse por hardware o por software. Por hardware: Una primera soluci\u00f3n puede ser alimentar el FC-03 con 3,3V, pero no siempre es sencillo ni darnos una buena se\u00f1al. La otra opci\u00f3n, mucho m\u00e1s eficaz y definitiva, es soldar un condensador de entre 10 y 100 nF entre los pines D0 y GND que filtrar\u00e1 dichos pulsos no deseados. Por software: Lo normal cuando usamos este tipo de sensores es que empleemos las interrupciones de Arduino, de ah\u00ed que los pines reservados para estos sensores sean los digitales 2 y 3, que es donde se implementan las interrupciones en la placa UNO. El punto en contra de esto es que tendremos que implementar un sistema antirrebotes (debounce) para estas dos entradas. En lo que respecta a hacer funcionar al robot no debemos preocuparnos por el tema ya que la librer\u00eda incorpora la implementaci\u00f3n del debounce por software. Si queremos entender algo mejor el tema del debounce podemos recurrir a multitud de tutoriales existente en la red siendo el que recomendamos el que aparece en el blog de Luis Llamas .","title":"An\u00e1lisis de elementos"},{"location":"conexionado-pruebas/UNO/elementos/#descripcion-de-placas-y-sensores","text":"En este apartado vamos a realizar una descripci\u00f3n b\u00e1sica de las distintas placas, sensores y elementos que se utilizan en la construcci\u00f3n del robot.","title":"Descripci\u00f3n de placas y sensores"},{"location":"conexionado-pruebas/UNO/elementos/#placa-keyestudio-uno-ks0172","text":"Se trata de la placa Ks0172 basada en Arduino UNO con el microcontrolador ATmega328P que incorpora conectores de 3 pines que incluyen la patilla asociada y la alimentaci\u00f3n y que facilita el conexionado de elementos sin necesidad de utilizar protoboard. En la imagen siguiente podemos ver esta placa con sus descripciones b\u00e1sicas y este es el enlace al archivo fuente . Placa Keyestudio UNO Ks0172 IMPORTANTE: El interruptor deslizante permite escoger entre las alimentaciones de 5V o 3.3V. En nuestro caso nos aseguraremos de que est\u00e1 en la posici\u00f3n 5V . Tambi\u00e9n es importante tener disponible un gr\u00e1fico con la funcionalidad de cada pin o diagrama pinout como el que vemos en la imagen siguiente y este es el enlace a su archivo fuente Pinout de la Placa Keyestudio UNO Ks0172","title":"Placa Keyestudio UNO Ks0172"},{"location":"conexionado-pruebas/UNO/elementos/#placa-drivers-l298","text":"Esta placa est\u00e1 basada en el chip L298N y permite controlar la velocidad y el sentido de giro de dos motores de corriente continua o un motor paso a paso bipolar con un consumo m\u00e1ximo de dos amperios. Cuenta con diodos de protecci\u00f3n y un regulador LM7805 que suministra 5V a la parte l\u00f3gica del integrado L298N. Se disponen jumpers de selecci\u00f3n para habilitar cada una de las salidas del m\u00f3dulo (A y B). La salida A esta conformada por OUT1 y OUT2 y la salida B por OUT3 y OUT4. Los pines de habilitaci\u00f3n son ENA y ENB (Enable A y Enable B) respectivamente. En la siguiente imagen vemos esta placa con sus descripciones b\u00e1sicas y este es el enlace al archivo fuente . Placa L298 Este m\u00f3dulo con el L298N nos permite alimentar nuestro Arduino a partir de la salida de 5V con un l\u00edmite de 500 mA. Debemos tambi\u00e9n tener presente que el m\u00f3dulo entrega una tensi\u00f3n a los motores en torno a 3V menor que la tensi\u00f3n a la que lo alimentamos. Los pines Vin y GND son los de alimentaci\u00f3n del m\u00f3dulo con una tensi\u00f3n que puede ir de 3V a 35V. El pin Vlog (Vl\u00f3gico) tiene dos modos de funcionamiento dependiendo de que el jumper Regulador est\u00e9 o no colocado. Las condiciones de funcionamiento son: Jumper colocado: El regulador LM7805 est\u00e1 activado y en Vlog habr\u00e1 una tensi\u00f3n de 5V siempre que el m\u00f3dulo est\u00e9 alimentado con una tensi\u00f3n m\u00e1xima de hasta 12V. Si lo alimentamos con una tensi\u00f3n superior tendremos que quitar el jumper y alimentar con 5V la l\u00f3gica del m\u00f3dulo a trav\u00e9s de este pin. Jumper sin colocar: El regulador LM7805 est\u00e1 desactivado y tenemos que alimentar la l\u00f3gica del m\u00f3dulo a trav\u00e9s de Vlog. Debemos tener \u00a1Cuidado! si introducimos corriente por Vlog con el jumper de regulaci\u00f3n colocado podemos provocar da\u00f1os en el m\u00f3dulo. El resto de conexiones se utilizan para el control de motores y para el caso de motores DC su utilizaci\u00f3n es la siguiente: Salidas para motores: Entregan la energ\u00eda para mover los motores y debemos conectarlo de forma que cuando marquemos, por ejemplo, mover adelante ambos motores giren en el mismo sentido. Si no lo hacen basta con invertir la polaridad de la conexi\u00f3n. Pines IN1 a IN4: IN1 e IN2 permiten controlar el sentido de giro del motor A mientras que IN3 e IN4 lo hacen con el del motor B. En la tabla siguiente se resume el funcionamiento de estos pines. IN1 IN2 IN3 IN4 Sentido de Giro High Low High Low Directo Low High Low High Inverso Low Low Low Low Paro Velocidad de giro: Tenemos que quitar los jumpers y usar los pines ENA y ENB. Estos pines debemos conectarlos a dos salidas PWM de la placa Arduino para poder enviarle un valor entre 0 y 255 que controle la velocidad de giro. Con los jumpers colocados, los motores girar\u00e1n siempre a la misma velocidad.","title":"Placa Drivers L298"},{"location":"conexionado-pruebas/UNO/elementos/#motores-dc-3-a-6v","text":"Motor de continua de 3V a 6V con doble eje y caja reductora. El doble eje facilita la colocaci\u00f3n de un encoder \u00f3ptico para realizar un control de velocidad en lazo cerrado. En la tabla siguiente se resumen los principales par\u00e1metros de estos motores con una reductora 48:1 para distintas tensiones de alimentaci\u00f3n. 3V 5V 6V Velocidad sin carga 125 rpm 200 rpm 230 rpm velocidad con carga 95 rpm 160 rpm 175 rpm Torque 7.8 Ncm 9.8 Ncm 10.8 Ncm Consumo 100 a 130 mA 120 a 140 mA 130 a 150 mA El aspecto f\u00edsico de estos motores lo vemos en la imagen siguiente. Motores DC 3 a 6V","title":"Motores DC 3 a 6V"},{"location":"conexionado-pruebas/UNO/elementos/#zumbador","text":"Si queremos reproducir sonidos de forma sencilla y econ\u00f3mica podemos utilizar un zumbador o buzzer pasivo como el que vemos en la imagen siguiente. Zumbador pasivo El dispositivo suele venir con una pegatina que debemos retirar para que el sonido salga con toda su potencia del mismo. Esta pegatina tiene utilidad en procesos de fabricaci\u00f3n automatizada para proteger al buzzer en la fase de lavado. Normalmente no tienen polaridad, pero si est\u00e1 marcada en la carcasa o es distinguible por la diferente longitud de los pines lo mejor es respetarla, siendo normalmente el pin marcado el positivo o patilla mas larga. El buzzer pasivo, a diferencia del activo, no tiene un oscilador interno y esto obliga a generar la frecuencia desde Arduino, para ello disponemos de la funci\u00f3n tone() que implementa el IDE.","title":"Zumbador"},{"location":"conexionado-pruebas/UNO/elementos/#sensores-de-infrarrojos","text":"Hemos optado por poner al robot una pareja de sensores de reflexi\u00f3n fotoel\u00e9ctrica con distancia de detecci\u00f3n ajustable entre 2 y 30cm (20 y 300mm), conocido como sensor de infrarrojos FC-51, como el que vemos en la imagen siguiente, donde se indica el potenci\u00f3metro de ajuste de distancia, el diodo emisor de IR y el fototransistor o detector de reflexi\u00f3n. Respecto a la distancia de detecci\u00f3n indicar que la citada anteriormente es la que la inmensa mayor\u00eda de vendedores ponen y, aunque hay algunos que reducen esta distancia bastante, es algo que debemos experimentar nosotros mismos teniendo en cuenta las condiciones de luminosidad en las que estemos trabajando. Modelo de sensor IR escogido Recordemos el funcionamiento b\u00e1sico del sistema. El LED infrarrojo emite luz infrarroja, o sea, de menor frecuencia (o mayor longitud de onda) que la que nuestros ojos nos permiten ver, es decir, para nosotros es invisible. El sensor que hemos elegido funciona cuando esta luz choca contra una superficie negra que la reflejar\u00e1 y llegar\u00e1 al fototransistor. Existen muchas clases de sensores de este tipo y hemos escogido este por su amplio rango de ajuste y su posibilidad de montaje vertical. Utilizando un par de estos sensores podemos seguir una linea detectando si se sale por la derecha o por la izquierda de la misma y rectificar la direcci\u00f3n de avance hasta conseguir estar de nuevo en la l\u00ednea. Este sensor tiene 3 pines de conexi\u00f3n, Vcc o 5V y GND para la alimentaci\u00f3n y D0 u OUT como salida de se\u00f1al que indicar\u00e1 si est\u00e1 llegando o no el reflejo del LED al fototransistor. En el esquema de la imagen siguiente se puede estudiar el funcionamiento electr\u00f3nico de esta plaquita. Esquema sensor infrarrojos El LM393 est\u00e1 configurado como comparador entre el nivel de tensi\u00f3n ajustado mediante VR1 que es entregado al terminal inversor y el nivel de entrada en el terminal no inversor, que va a depender de si el fototransistor recibe o no reflexi\u00f3n del infrarrojo emitido por el LED, si est\u00e1 recibiendo reflexi\u00f3n el fototransistor se encender\u00e1 el LED indicador de estado y tenemos el estado bajo o LOW en D0. Si no se recibe reflexi\u00f3n el LED no se iluminar\u00e1 y se env\u00eda un estado alto o HIGH a D0. Mediante el potenci\u00f3metro ajustamos la sensibilidad del fotorreceptor.","title":"Sensores de infrarrojos"},{"location":"conexionado-pruebas/UNO/elementos/#sensor-de-distancia-hc-sr04","text":"El sensor genera y emite una serie de tonos de ultrasonidos a una frecuencia de 40 kHz (no perceptibles al o\u00eddo humano) que si rebotan en una superficie vuelven y son captados por un micr\u00f3fono receptor de ultrasonidos que incorpora el propio sensor. Midiendo el tiempo que tardan en volver los tonos enviados podemos calcular la distancia a la que se encuentra el objeto sobre el que han rebotado. El propio circuito realiza los c\u00e1lculos necesarios para determinar la distancia a la que est\u00e1 la superficie. El sistema es similar al que usan algunos animales como ballenas, murci\u00e9lagos y delfines, para localizar obst\u00e1culos y presas. El HC-SR04 es un sensor de distancia de baja precisi\u00f3n, en teor\u00eda con un rango de medici\u00f3n de 2cm a 400 cm, con una resoluci\u00f3n de 0.3cm, pero en la pr\u00e1ctica se limita a un rango entre 20cm y 2 metros. El aspecto del HC-SR04 es muy caracter\u00edstico y se reconoce con facilidad porque tiene dos \"ojos\" que realmente son los dispositivos de emisi\u00f3n y recepci\u00f3n de ultrasonidos que integra este m\u00f3dulo, y es justo por esto por lo que hemos dotado al robot de una cabeza giratoria que en el funcionamiento parecer\u00e1 que el robot mira a un lado y otro. En la imagen siguiente vemos el aspecto real del sensor y el principio de funcionamiento de forma gr\u00e1fica. Aspecto del HC-SR04 y principio de funcionamiento Las caracter\u00edsticas t\u00e9cnicas m\u00e1s relevantes del HC-SR04 son: Dispone de 4 pines, dos son para alimentaci\u00f3n (Vcc) y masa (GND), disparador (Trigger) y receptor (Echo). En la imagen siguiente se aprecian claramente como est\u00e1n distribuidos estos pines en el sensor. Pinout del HC-SR04 Imagen basada en la publicada en theengineeringprojects Alimentaci\u00f3n: 5v Frecuencia de ultrasonidos: 40 Khz Consumos: en stand-by menor de 2mA y trabajando en torno a 15mA \u00c1ngulo: menor de 15\u00ba Veamos ahora en que se basan los c\u00e1lculos que realiza el sensor. En principio lo que hace, como ya se ha indicado, es contar el tiempo desde que se envia el pulso hasta que se recibe respuesta con lo que se puede determinar la distancia. Recordemos que: velocidad=\\dfrac{espacio}{tiempo}\\Rightarrow espacio=velocidad\\cdot tiempo velocidad=\\dfrac{espacio}{tiempo}\\Rightarrow espacio=velocidad\\cdot tiempo La velocidad es la del sonido es de 343 m/s a 20 \u00baC y un 50% de humedad relativa. A nosotros nos va a interesar expresar esta velocidad en cm/us, para lo que hacemos lo siguiente: 343\\dfrac{m}{s}\\cdot 100\\dfrac{cm}{m}\\cdot \\dfrac{1}{1000000}\\dfrac{s}{\\mu s}=0.0343\\dfrac{cm}{\\mu s}\\Rightarrow espacio-ida=0.0343\\cdot tiempo 343\\dfrac{m}{s}\\cdot 100\\dfrac{cm}{m}\\cdot \\dfrac{1}{1000000}\\dfrac{s}{\\mu s}=0.0343\\dfrac{cm}{\\mu s}\\Rightarrow espacio-ida=0.0343\\cdot tiempo Es decir, el sonido tarda 0.0343 microsegundos en recorrer un cent\u00edmetro, que ser\u00e1 el tiempo que tarda el sonido en ir desde el amisor al objeto en el que rebota. Teniendo en cuenta que desde que se emite el pulso, rebota y es recibido el espacio recorrido ser\u00e1 aproximadamente el doble que el calculado podemos expresar la distancia o espacio recorrido como: espacio=\\dfrac{espacio-ida}{2}=0.01715\\cdot tiempo espacio=\\dfrac{espacio-ida}{2}=0.01715\\cdot tiempo Ecuaci\u00f3n que nos permite saber la distancia a la que se encuentra un determinado objeto.","title":"Sensor de distancia HC-SR04"},{"location":"conexionado-pruebas/UNO/elementos/#servomotores","text":"Los servomotores, abreviado servos, son motores de corriente continua que adem\u00e1s tienen una reductora con el fin de disminuir su velocidad de giro y aumentar el par motor en el eje. Tambi\u00e9n incorporan sistema electr\u00f3nico de control que permite hacerlos girar un determinado \u00e1ngulo. Esa electr\u00f3nica permite al servo saber en todo momento cual es su posici\u00f3n. Generalmente giran menos de una vuelta completa, 180\u00ba es bastante com\u00fan, aunque tienen un \u00e1ngulo variable seg\u00fan el modelo, pero existen ya servos de rotaci\u00f3n continua que giran 360 grados. Existen infinidad de modelos de servomotor y en nuestro caso vamos a utilizar Micro Servos del tipo 9g SG90. En la imagen siguiente vemos el aspecto y los elementos que incorporan este tipo de servos. Aspecto y elementos de los servos 9g SG90 Los servos tienen un funcionamiento muy parecido y la programaci\u00f3n suele variar muy poco de unos a otros, aunque siempre es conveniente mirar el datasheet del que vamos a utilizar para mayor seguridad. Debido a que la resoluci\u00f3n de la se\u00f1al PWM que podemos conseguir con una placa tipo UNO el \u00e1ngulo de giro que podremos mover un servo ser\u00e1 mayor de un grado, aunque el servo puede moverse con una resoluci\u00f3n mayor. Las caracter\u00edsticas de la se\u00f1al PWM nos indican que debemos generar un pulso de trabajo entre 1 ms y 2 ms y con un periodo de 20 ms (50 Hz), es decir, solamente podremos cambiar de posici\u00f3n del servo cada 20 ms. Los microservos se pueden alimentar directamente de la placa UNO dado que su consumo es lo suficientemente bajo para ello, pero si es necesario, dependiendo del modelo de servo, habr\u00e1 que alimentarlo con una fuente externa teniendo siempre la precauci\u00f3n de que las GNDs de la placa UNO y del servo queden interconectadas. Los colores usuales de los tres cables que salen del servo son los siguientes: Negro o Marr\u00f3n: GND Rojo: Alimentaci\u00f3n Blanco o Naranja: Se\u00f1al de control del servo (pulso enviado al servomotor) En la imagen siguiente se corrobora esta informaci\u00f3n. Colores de los cables en los servos 9g SG90","title":"Servomotores"},{"location":"conexionado-pruebas/UNO/elementos/#encoder-infrarrojos-fc-03","text":"Se trata de elementos basados en fotointerruptores de ranura como los que vemos en la imagen izquierda siguiente. A partir de estos se fabrican placas preparadas para conectar a Arduino como las que se ven en la imagen de la derecha siguiente. Izquierda: fotointerruptor de ranura - Derecha: sensor FC-03 Los dispositivos basados en optointerruptores son ampliamente utilizados como encoders para detectar la velocidad de giro y la posici\u00f3n del eje de motores. Para realizar esta tarea se emplean discos opacos ranurados que se acoplan al eje del motor, aunque tambi\u00e9n se pueden emplear elementos translucidos sobre los que se dibujan franjas negras. En la imagen siguiente vemos algunos de estos discos. Diferentes tipos de discos para encoder \u00f3ptico Con el sensor FC-03, que incluye comparador LM393 , podemos calcular la velocidad de rotaci\u00f3n de las ruedas de un robot. El funcionamiento b\u00e1sico del sensor es el siguiente; Si hacemos pasar una rueda dentada entre la ranura del sensor, este crea un pulso digital TTL en el pin D0, que podemos leer sin ning\u00fan problema en nuestra placa UNO. En la imagen siguiente vemos detalladas las diferentes partes del encoder. Pinout y partes del sensor FC-03 Los pines de conexi\u00f3n del encoder FC-03 de la imagen anterior los podemos describir de la siguiente forma: Vcc: Tensi\u00f3n de alimentaci\u00f3n del m\u00f3dulo de 3,3V a 12V. Se recomienda 3,3V GND: Masa o referencia 0V D0: Salida de se\u00f1al digital de pulsos TTL A0: Salida de se\u00f1al anal\u00f3gica de los pulsos de salida. Se trata de la se\u00f1al de salida en tiempo real que usualmente no se utiliza Como principales caracter\u00edsticas t\u00e9cnicas definimos las siguientes: Anchura de la ranura: 5mm LED indicador de alimentaci\u00f3n LED indicador de los pulsos de salida del pin D0. Este tipo de encoder suele dar problemas a la hora de leer los pulsos digitales generados por el comparador LM393, y estos consisten en que la placa UNO lee m\u00e1s pulsos de los que se generan realmente, en la pr\u00e1ctica del orden de cuatro veces m\u00e1s. En la imagen siguiente vemos el esquema del circuito que monta este encoder FC-03. Esquema interno del sensor FC-03 Podemos observar en este esquema como el comparador LM393 est\u00e1 configurado como de lazo abierto (no existe realimentaci\u00f3n) lo que hace que el mismo sea extremadamente sensible a los cambios que se producen en la entrada, bien sean provocados por el sensor de ranura (los deseados) o bien por ruidos generados por la propia alimentaci\u00f3n del sensor, los motores u otros elementos (pulsos no deseados) que puedan afectar a la se\u00f1al de salida. Es decir, que la se\u00f1al TTL presentar\u00e1 tanto en los flancos de subida como de bajada una serie de pulsos o rebotes que la placa UNO es capaz de leer e interpretar. La soluci\u00f3n al problema de los pulsos no deseados puede implementarse por hardware o por software. Por hardware: Una primera soluci\u00f3n puede ser alimentar el FC-03 con 3,3V, pero no siempre es sencillo ni darnos una buena se\u00f1al. La otra opci\u00f3n, mucho m\u00e1s eficaz y definitiva, es soldar un condensador de entre 10 y 100 nF entre los pines D0 y GND que filtrar\u00e1 dichos pulsos no deseados. Por software: Lo normal cuando usamos este tipo de sensores es que empleemos las interrupciones de Arduino, de ah\u00ed que los pines reservados para estos sensores sean los digitales 2 y 3, que es donde se implementan las interrupciones en la placa UNO. El punto en contra de esto es que tendremos que implementar un sistema antirrebotes (debounce) para estas dos entradas. En lo que respecta a hacer funcionar al robot no debemos preocuparnos por el tema ya que la librer\u00eda incorpora la implementaci\u00f3n del debounce por software. Si queremos entender algo mejor el tema del debounce podemos recurrir a multitud de tutoriales existente en la red siendo el que recomendamos el que aparece en el blog de Luis Llamas .","title":"Encoder infrarrojos FC-03"},{"location":"conexionado-pruebas/UNO/test/","text":"Pruebas b\u00e1sicas de funcionamiento \u00b6 Una vez analizados y conectados los distintos elementos iremos haciendo peque\u00f1os programas bien mediante la aplicaci\u00f3n Masaylo Blockly basada en Blocklino de Fontaine Jean Philippe , y pensada para programar robots utilizando un entorno gr\u00e1fico o de programaci\u00f3n por bloques, o bien utilizando el IDE de Arduino. En el apartado de software se pueden encontrar los enlaces de descarga y toda la informaci\u00f3n de la aplicaci\u00f3n. Alimentaci\u00f3n \u00b6 Colocamos las pilas AA en su lugar respetando la polaridad de las mismas y accionamos el interruptor. Si todo es correcto en ambas placas se debe encender un diodo LED rojo indicativo de que est\u00e1n alimentadas, tal y como observamos en la imagen siguiente: Primer encendido En este punto vamos a probar tambi\u00e9n que se graba correctamente firmware en la placa UNO a partir de Masaylo Blockly 1.1.1 Beta o posterior . Para ello hemos creado y almacenado el programa blink.bloc que vemos en la imagen siguiente. Programa blink.bloc Si cargamos el programa y dejamos sin accionar el interruptor observaremos como parpadea el LED asociado al pin 13 en la placa UNO pero la placa del driver no est\u00e1 alimentada y por tanto su LED permanece apagado. En la animaci\u00f3n siguiente vemos el parpadeo del LED y el resultado de accionar el interruptor. Animaci\u00f3n que muestra el funcionamiento del programa blink.bloc y del interruptor Este GIF se ha creado a partir de un video en formato mp4 utilizando FFMPEG y GIMP y la informaci\u00f3n obtenida en este enlace . Motores \u00b6 Vamos a realizar una primera prueba del funcionamiento de los motores a partir de los ejemplos suministrados con la librer\u00eda y disponibles en la aplicaci\u00f3n Masaylo Blockly que estamos usando en estas pruebas de funcionamiento. En la imagen siguiente tenemos cargado el ejemplo Aprende a controlar los movimientos b\u00e1sicos del robot Masaylo y hemos destacado el icono desde el que podemos seleccionarlo de la lista que se abre en una ventana emergente y que al hacer clic nos lo carga en el entorno de la aplicaci\u00f3n. Ejemplo Aprende a controlar los movimientos b\u00e1sicos del robot Masaylo cargado Si conectamos la placa al puerto USB del ordenador y cargamos el ejemplo en la placa, cuando accionemos el interruptor (o con este accionado pulsemos el bot\u00f3n de reset) se producir\u00e1 la secuencia de movimiento establecida en el programa que podemos apreciar en la animaci\u00f3n siguiente. Animaci\u00f3n que muestra el funcionamiento del programa motores-ej1.bloc El ejemplo siguiente est\u00e1 basado en Utiliza PWM para controlar la velocidad de movimientos del Masaylo suministrado con la aplicaci\u00f3n pero ligeramente modificado ( motores-ej2.bloc ) para poner todos los valores de PWM al 50% y todos los retardos a 3 segundos. Ejemplo con control PWM de Masaylo El funcionamiento es muy similar al de la animaci\u00f3n anterior pero a la mitad de velocidad. An\u00edmate y prueba el ejemplo y haz cambios para analizar lo que est\u00e1 ocurriendo. Zumbador \u00b6 En esta ocasi\u00f3n vamos a programar el robot desde el IDE de Arduino, en concreto utilizando la versi\u00f3n 1.8.13 o posterior. Para la prueba del zumbador vamos a utilizar la informaci\u00f3n que podemos ver en la web de Input makers con el t\u00edtulo Programar melod\u00eda de Star Wars con Arduino y zumbador . El c\u00f3digo que vamos a grabar en la placa lo vemos a continuaci\u00f3n y basta con utilizar el bot\u00f3n copiar para seleccionarlo y ponerlo en el portapapeles desde el que lo podemos llevar al IDE de Arduino. Este bot\u00f3n se hace mas visible al pasar el cursor por el cuadro del c\u00f3digo en la zona superior derecha del mismo. Tambi\u00e9n puedes descargar el programa comprimido haciendo clic en el enlace buzzer-star-wars que puedes descomprimir y utilizar a conveniencia. int pin = 1; // definimos el pin al que conectaremos el zumbador. /* Definimos cada una de las frecuencias de las notas musicales. * Cuando van acompa\u00f1adas de la letra S significa que esa nota es sostenido. * Cuando van acompa\u00f1adas de la letra H significa que esa nota est\u00e1 en una octava superior (High). */ int c=261; int d=294; int e=329; int f=349; int g=391; int gS=415; int a=440; int aS=455; int b=466; int cH=523; int cSH=554; int dH=587; int dSH=622; int eH=659; int fH=698; int fSH=740; int gH=783; int gSH=830; int aH=880; void setup() { pinMode(pin, OUTPUT); // Hacemos que el pin 1 sea salida. } void loop() { /* Utilizamos la funci\u00f3n tone incluida en el IDE con el formato: tone(N\u00ba-pin, nota, duracion) */ tone(pin, a, 500); delay(550); tone(pin, a, 500); delay(550); tone(pin, a, 500); delay(550); tone(pin, f, 350); delay(350); tone(pin, cH, 150); delay(200); tone(pin, a, 500); delay(550); tone(pin, f, 350); delay(350); tone(pin, cH, 150); delay(200); tone(pin, a, 1000); delay(1050); tone(pin, eH, 500); delay(550); tone(pin, eH, 500); delay(550); tone(pin, eH, 500); delay(550); tone(pin, fH, 350); delay(350); tone(pin, cH, 150); delay(200); tone(pin, gS, 500); delay(550); tone(pin, f, 350); delay(350); tone(pin, cH, 150); delay(200); tone(pin, a, 1000); delay(1050); tone(pin, aH, 500); delay(550); tone(pin, a, 350); delay(350); tone(pin, a, 150); delay(200); tone(pin, aH, 500); delay(550); tone(pin, gSH, 250);delay(250); tone(pin, gH, 250); delay(250); tone(pin, fSH, 125);delay(150); tone(pin, fH, 125); delay(150); tone(pin, fSH, 250);delay(250); delay(250); tone(pin, aS, 250); delay(250); tone(pin, dSH, 500);delay(550); tone(pin, dH, 250); delay(250); tone(pin, cSH, 250);delay(250); tone(pin, cH, 125); delay(150); tone(pin, b, 125); delay(150); tone(pin, cH, 250); delay(250); delay(250); tone(pin, f, 125); delay(150); tone(pin, gS, 500); delay(550); tone(pin, f, 375); delay(375+50); tone(pin, a, 125); delay(150); tone(pin, cH, 500); delay(550); tone(pin, a, 375); delay(400); tone(pin, cH, 125); delay(150); tone(pin, eH, 1000);delay(1050); tone(pin, aH, 500); delay(550); tone(pin, a, 350); delay(350); tone(pin, a, 150); delay(200); tone(pin, aH, 500); delay(550); tone(pin, gSH, 250);delay(250); tone(pin, gH, 250); delay(250); tone(pin, fSH, 125);delay(150); tone(pin, fH, 125); delay(150); tone(pin, fSH, 250);delay(250); delay(250); tone(pin, aS, 250); delay(250); tone(pin, dSH, 500);delay(550); tone(pin, dH, 250); delay(250); tone(pin, cSH, 250);delay(250); tone(pin, cH, 125); delay(150); tone(pin, b, 125); delay(150); tone(pin, cH, 250); delay(250); delay(250); tone(pin, f, 250); delay(250); tone(pin, gS, 500); delay(550); tone(pin, f, 375); delay(400); tone(pin, cH, 125); delay(150); tone(pin, a, 500); delay(550); tone(pin, f, 375); delay(400); tone(pin, c, 125); delay(150); tone(pin, a, 1000); delay(1050); delay(5000); } En el video \"prueba del zumbador en Masaylo-CRG\" que tenemos a continuaci\u00f3n podemos escuchar el resultado de grabar el c\u00f3digo anterior en el robot. Sensores de infrarrojos \u00b6 Para probar y ajustar los sensores de infrarrojos vamos a realizar un sencillo programa en MasayloBlockly como el que vemos en la imagen siguiente. Ejemplo para prueba de los sensores de infrarrojos Si es necesario retocaremos la posici\u00f3n del cursor del potenciometro de ajuste de sensibilidad teniendo en cuenta que es extremadamente sensible y que debemos dejarlo en una posici\u00f3n tal que al situar el sensor sobre una superficie negra el sensor onboard se apague y cuando lo sacamos del negro se encienda. El programa sensores-IR.bloc es muy sencillo y simplemente comprueba si el sensor izquierdo est\u00e1 sobre negro est\u00e1ndo el derecho sobre blanco, si esta condici\u00f3n es cierta el LED onboard del UNO har\u00e1 un parpadeo que repetir\u00e1 dos veces de forma lenta y nos mostrar\u00e1 un mensaje en el monitor serie. Un proceso similar se realiza con el sensor derecho sobre negro siendo esta vez el parpadeo r\u00e1pido y lo har\u00e1 tres veces. Si ninguno de los sensores detecta negro mostrar\u00e1 el correspondiente mensaje permaneciendo el LED apagado. En la imagen siguiente vemos el resultado que muestra el monitor serie al hacer que los sensores lean negro. Resultados obtenidos con el programa de prueba de los sensores de infrarrojos Sensor de distancia HC-SR04 \u00b6 El datasheet del sensor nos indica que debemos generar un pulso de al menos 10us en el pin Trigger o disparador. Si queremos asegurar un trigger bueno podemos poner el pin a nivel bajo durante 4us antes de general el pulso en si. En c\u00f3digo esto es algo como lo siguiente: digitalWrite(Pin_Trigger, LOW); delayMicroseconds(4); digitalWrite(Pin_Trigger, HIGH); delayMicroseconds(10); digitalWrite(Pin_Trigger, LOW); Este c\u00f3digo ya est\u00e1 implementado en la librer\u00eda que se describe en estas notas y, por supuesto lo est\u00e1 en Masaylo Blockly por lo que no debemos preocuparnos por ello. En este caso como ejemplo vamos a utilizar el que viene con la versi\u00f3n 1.1.4 de Masaylo Blockly titulado \"Env\u00eda la distancia al obst\u00e1culo detectado al puerto serie de tu ordenador\" y que podemos ver cargado en la imagen siguiente. Ejemplo \"Env\u00eda la distancia al obst\u00e1culo detectado al puerto serie de tu ordenador\" En la imagen siguiente vemos este mismo ejemplo con la definici\u00f3n de pines que se da en el pinout. Ejemplo \"Env\u00eda la distancia al obst\u00e1culo detectado al puerto serie de tu ordenador\" con A2 y A3 Se puede utilizar una u otra nomenclatura de forma indiferente y en cualquier caso lo que hace el ejemplo es enviarnos al puerto serie la distancia en cent\u00edmetros que est\u00e1 midiendo el sensor una vez por segundo. En la imagen siguiente vemos una ventana con resultados de diferentes distancias medidas por el sensor. Ejemplo \"Env\u00eda la distancia al obst\u00e1culo detectado al puerto serie de tu ordenador\" resultados Servomotores \u00b6 En nuestro caso el robot va dotado de dos servos SG90, uno para accionar el brazo aparta obst\u00e1culos y el otro para accionar la cabeza y que el robot \"mire\" a un lado y otro. Para ambos servos vamos a crear unos programas muy simples que nos sirvan para verificar su funcionamiento. Prueba de funcionamiento del servo de cabeza . Implementamos, o descargamos el programa que vemos en la imagen siguiente: Ejemplo b\u00e1sico de funcionamiento del servo de cabeza En los ejemplos que acompa\u00f1an a la librer\u00eda y que se incluyen en Masaylo Blockly encontramos otras muchas funcionalidades de este servo. En la animaci\u00f3n siguiente vemos el resultado de programar el robot con el ejemplo anterior y como realiza movimientos de izquierda a derecha pasando por la posici\u00f3n central o mirar al frente. Animaci\u00f3n del ejemplo b\u00e1sico de funcionamiento del servo de cabeza Prueba de funcionamiento del servo del brazo . En el caso del brazo hay que tener en cuenta que, si posicionamos la placa UNO como hemos ido viendo en las distintas im\u00e1genes, al grabar este programa (o cualquier otro que trabaje con el servo del brazo) y mientras mantegamos conectado el cable USB, este va a molestar a los movimientos del brazo porque chocar\u00e1 con el mismo. Las opciones que tenemos para evitar que esto ocurra son: girar la placa UNO 180\u00ba sobre la posici\u00f3n indicada hasta ahora retirar el brazo en tanto trabajamos con la conexi\u00f3n USB y colocarlo en el robot para su funcionamiento aut\u00f3nomo colocar el servo junto con el brazo en el otro costado del robot En la imagen siguiente vemos el robot con el servo cambiado de costado. Servo del brazo posicionado a la izquierda Implementamos, o descargamos el programa que vemos en la imagen siguiente: Ejemplo b\u00e1sico de funcionamiento del servo del brazo En los ejemplos que acompa\u00f1an a la librer\u00eda y que se incluyen en Masaylo Blockly encontramos otras muchas funcionalidades de este servo. En la animaci\u00f3n siguiente vemos el resultado de programar el robot con un ejemplo en el que el brazo est\u00e1 colocado en el costado derecho y como realiza movimientos de posicionado del brazo envolviendo al objeto que supuestamente habr\u00eda delante y retracci\u00f3n del brazo a su posici\u00f3n de replegado pasando por la posici\u00f3n central o posici\u00f3n vertical del brazo. Animaci\u00f3n del ejemplo b\u00e1sico de funcionamiento del servo del brazo Encoder infrarrojos FC-03 \u00b6 Para probar el funcionamiento de los encoders vamos a recurrir de nuevo al IDE 1.8.15 de Arduino montando dos ejemplos totalmente similares pero probando cada encoder por separado. Estos ejemplos est\u00e1n inspirados en la implementaci\u00f3n que se hace de los mismos en el robot Andromina OFF ROAD y los detalles analizados en el blog Andromina robot V.2.0 Posteriormente podremos probar distintos ejemplos integrados en la librer\u00eda que l\u00f3gicamente utilizar\u00e1n ambos encoders simult\u00e1neamente. Encoder izquierdo A continuaci\u00f3n vemos el c\u00f3digo comentado de la prueba que vamos a realizar y que puedes descargar o copiar para grabarlo en tu robot y as\u00ed comprobar que el encoder izquierdo funciona correctamente. const int pwm_izdo = 6; //pines y variables motor y encoder izquierdo const int IN1 = 7; const int IN2 = 8; int encoder_izdo = 2; unsigned int rpm_izdo = 0; float vel_izdo = 0; //en Km/h volatile byte pulsos_leidos = 0; // N\u00famero de pulsos leidos en un segundo unsigned long tiempo_anterior = 0; // Tiempo unsigned int muescas = 20; //n\u00famero de muescas del disco del encoder. const int diametro_rueda = 75; //Di\u00e1metro de las ruedas en mm static volatile unsigned long debounce = 0; //Tiempo del rebote. void setup(){ pinMode(pwm_izdo,OUTPUT); pinMode(IN1,OUTPUT); pinMode(IN2,OUTPUT); Serial.begin(9600); pinMode(encoder_izdo, INPUT); attachInterrupt(0, contador, RISING); //Configuraci\u00f3n de la interrupci\u00f3n 0 pulsos_leidos = 0; rpm_izdo = 0; tiempo_anterior = 0; Serial.println(\"MOTOR IZQUIERDO:\"); Serial.print(\"Segundos - \"); Serial.print(\"RPM - \"); Serial.print(\"Pulsos leidos - \"); Serial.println(\"Velocidad (Km/h)\"); Serial.println(\"======== === ============= ================\"); } void loop(){ if (millis() - tiempo_anterior >= 1000){ //Se actualiza cada segundo noInterrupts(); // Desconectamos la interrupci\u00f3n para que no actu\u00e9 en esta parte del programa. digitalWrite(IN1,HIGH); digitalWrite(IN2,LOW); analogWrite(pwm_izdo,255); //a m\u00e1xima velocidad rpm_izdo = (60 * 1000 / muescas )/ (millis() - tiempo_anterior)* pulsos_leidos; //C\u00e1lculo de las revoluciones por minuto vel_izdo = rpm_izdo * 3.1416 * diametro_rueda * 60 / 1000000; //C\u00e1lculo de la vel_izdo en Km/h tiempo_anterior = millis(); //Almacenamos el tiempo actual. Serial.print(\" \"); Serial.print(millis()/1000); Serial.print(\" \"); Serial.print(rpm_izdo,DEC); Serial.print(\" \"); Serial.print(pulsos_leidos,DEC); Serial.print(\" \"); Serial.println(vel_izdo,2); pulsos_leidos = 0; //Inicializamos los pulsos interrupts(); //Reiniciamos la interrupci\u00f3n } } //La funci\u00f3n contador se encarga de contar los pulsos buenos void contador(){ if(digitalRead(encoder_izdo) && (micros()-debounce > 500) && digitalRead (encoder_izdo)){ debounce = micros(); //para comprobar que no contamos rebotes pulsos_leidos++;} //Cuen ta el pulso como bueno } En la imagen siguiente tenemos una captura del terminal serie con los resultados para el encoder izquierdo. Resultados del ejemplo b\u00e1sico para prueba del encoder izquierdo Encoder derecho A continuaci\u00f3n vemos el c\u00f3digo comentado de la prueba que vamos a realizar y que puedes descargar o copiar para grabarlo en tu robot y as\u00ed comprobar que el encoder derecho funciona correctamente. const int pwm_dcho = 11; //pines y variables motor y encoder derecho const int IN3 = 12; const int IN4 = 13; int encoder_dcho = 3; unsigned int rpm_dcho = 0; float vel_dcho = 0; //en Km/h volatile byte pulsos_leidos = 0; // N\u00famero de pulsos leidos en un segundo unsigned long tiempo_anterior = 0; // Tiempo unsigned int muescas = 20; //n\u00famero de muescas del disco del encoder. const int diametro_rueda = 75; //Di\u00e1metro de las ruedas en mm static volatile unsigned long debounce = 0; //Tiempo del rebote. void setup(){ pinMode(pwm_dcho,OUTPUT); pinMode(IN3,OUTPUT); pinMode(IN4,OUTPUT); Serial.begin(9600); pinMode(encoder_dcho, INPUT); attachInterrupt(1, contador, RISING); //Configuraci\u00f3n de la interrupci\u00f3n 1 pulsos_leidos = 0; rpm_dcho = 0; tiempo_anterior = 0; Serial.println(\"MOTOR DERECHO:\"); Serial.print(\"Segundos - \"); Serial.print(\"RPM - \"); Serial.print(\"Pulsos leidos - \"); Serial.println(\"Velocidad (Km/h)\"); Serial.println(\"======== === ============= ================\"); } void loop(){ if (millis() - tiempo_anterior >= 1000){ //Se actualiza cada segundo noInterrupts(); // Desconectamos la interrupci\u00f3n para que no actu\u00e9 en esta parte del programa. digitalWrite(IN3,HIGH); digitalWrite(IN4,LOW); analogWrite(pwm_dcho,255); //a m\u00e1xima velocidad rpm_dcho = (60 * 1000 / muescas )/ (millis() - tiempo_anterior)* pulsos_leidos; //C\u00e1lculo de las revoluciones por minuto vel_dcho = rpm_dcho * 3.1416 * diametro_rueda * 60 / 1000000; //C\u00e1lculo de la vel_dcho en Km/h tiempo_anterior = millis(); //Almacenamos el tiempo actual. Serial.print(\" \"); Serial.print(millis()/1000); Serial.print(\" \"); Serial.print(rpm_dcho,DEC); Serial.print(\" \"); Serial.print(pulsos_leidos,DEC); Serial.print(\" \"); Serial.println(vel_dcho,2); pulsos_leidos = 0; //Inicializamos los pulsos interrupts(); //Reiniciamos la interrupci\u00f3n } } //La funci\u00f3n contador se encarga de contar los pulsos buenos void contador(){ if(digitalRead(encoder_dcho) && (micros()-debounce > 500) && digitalRead (encoder_dcho)){ debounce = micros(); //para comprobar que no contamos rebotes pulsos_leidos++;} //Cuen ta el pulso como bueno } En la imagen siguiente tenemos una captura del terminal serie con los resultados para el encoder derecho. Resultados del ejemplo b\u00e1sico para prueba del encoder derecho","title":"Pruebas b\u00e1sicas de funcionamiento"},{"location":"conexionado-pruebas/UNO/test/#pruebas-basicas-de-funcionamiento","text":"Una vez analizados y conectados los distintos elementos iremos haciendo peque\u00f1os programas bien mediante la aplicaci\u00f3n Masaylo Blockly basada en Blocklino de Fontaine Jean Philippe , y pensada para programar robots utilizando un entorno gr\u00e1fico o de programaci\u00f3n por bloques, o bien utilizando el IDE de Arduino. En el apartado de software se pueden encontrar los enlaces de descarga y toda la informaci\u00f3n de la aplicaci\u00f3n.","title":"Pruebas b\u00e1sicas de funcionamiento"},{"location":"conexionado-pruebas/UNO/test/#alimentacion","text":"Colocamos las pilas AA en su lugar respetando la polaridad de las mismas y accionamos el interruptor. Si todo es correcto en ambas placas se debe encender un diodo LED rojo indicativo de que est\u00e1n alimentadas, tal y como observamos en la imagen siguiente: Primer encendido En este punto vamos a probar tambi\u00e9n que se graba correctamente firmware en la placa UNO a partir de Masaylo Blockly 1.1.1 Beta o posterior . Para ello hemos creado y almacenado el programa blink.bloc que vemos en la imagen siguiente. Programa blink.bloc Si cargamos el programa y dejamos sin accionar el interruptor observaremos como parpadea el LED asociado al pin 13 en la placa UNO pero la placa del driver no est\u00e1 alimentada y por tanto su LED permanece apagado. En la animaci\u00f3n siguiente vemos el parpadeo del LED y el resultado de accionar el interruptor. Animaci\u00f3n que muestra el funcionamiento del programa blink.bloc y del interruptor Este GIF se ha creado a partir de un video en formato mp4 utilizando FFMPEG y GIMP y la informaci\u00f3n obtenida en este enlace .","title":"Alimentaci\u00f3n"},{"location":"conexionado-pruebas/UNO/test/#motores","text":"Vamos a realizar una primera prueba del funcionamiento de los motores a partir de los ejemplos suministrados con la librer\u00eda y disponibles en la aplicaci\u00f3n Masaylo Blockly que estamos usando en estas pruebas de funcionamiento. En la imagen siguiente tenemos cargado el ejemplo Aprende a controlar los movimientos b\u00e1sicos del robot Masaylo y hemos destacado el icono desde el que podemos seleccionarlo de la lista que se abre en una ventana emergente y que al hacer clic nos lo carga en el entorno de la aplicaci\u00f3n. Ejemplo Aprende a controlar los movimientos b\u00e1sicos del robot Masaylo cargado Si conectamos la placa al puerto USB del ordenador y cargamos el ejemplo en la placa, cuando accionemos el interruptor (o con este accionado pulsemos el bot\u00f3n de reset) se producir\u00e1 la secuencia de movimiento establecida en el programa que podemos apreciar en la animaci\u00f3n siguiente. Animaci\u00f3n que muestra el funcionamiento del programa motores-ej1.bloc El ejemplo siguiente est\u00e1 basado en Utiliza PWM para controlar la velocidad de movimientos del Masaylo suministrado con la aplicaci\u00f3n pero ligeramente modificado ( motores-ej2.bloc ) para poner todos los valores de PWM al 50% y todos los retardos a 3 segundos. Ejemplo con control PWM de Masaylo El funcionamiento es muy similar al de la animaci\u00f3n anterior pero a la mitad de velocidad. An\u00edmate y prueba el ejemplo y haz cambios para analizar lo que est\u00e1 ocurriendo.","title":"Motores"},{"location":"conexionado-pruebas/UNO/test/#zumbador","text":"En esta ocasi\u00f3n vamos a programar el robot desde el IDE de Arduino, en concreto utilizando la versi\u00f3n 1.8.13 o posterior. Para la prueba del zumbador vamos a utilizar la informaci\u00f3n que podemos ver en la web de Input makers con el t\u00edtulo Programar melod\u00eda de Star Wars con Arduino y zumbador . El c\u00f3digo que vamos a grabar en la placa lo vemos a continuaci\u00f3n y basta con utilizar el bot\u00f3n copiar para seleccionarlo y ponerlo en el portapapeles desde el que lo podemos llevar al IDE de Arduino. Este bot\u00f3n se hace mas visible al pasar el cursor por el cuadro del c\u00f3digo en la zona superior derecha del mismo. Tambi\u00e9n puedes descargar el programa comprimido haciendo clic en el enlace buzzer-star-wars que puedes descomprimir y utilizar a conveniencia. int pin = 1; // definimos el pin al que conectaremos el zumbador. /* Definimos cada una de las frecuencias de las notas musicales. * Cuando van acompa\u00f1adas de la letra S significa que esa nota es sostenido. * Cuando van acompa\u00f1adas de la letra H significa que esa nota est\u00e1 en una octava superior (High). */ int c=261; int d=294; int e=329; int f=349; int g=391; int gS=415; int a=440; int aS=455; int b=466; int cH=523; int cSH=554; int dH=587; int dSH=622; int eH=659; int fH=698; int fSH=740; int gH=783; int gSH=830; int aH=880; void setup() { pinMode(pin, OUTPUT); // Hacemos que el pin 1 sea salida. } void loop() { /* Utilizamos la funci\u00f3n tone incluida en el IDE con el formato: tone(N\u00ba-pin, nota, duracion) */ tone(pin, a, 500); delay(550); tone(pin, a, 500); delay(550); tone(pin, a, 500); delay(550); tone(pin, f, 350); delay(350); tone(pin, cH, 150); delay(200); tone(pin, a, 500); delay(550); tone(pin, f, 350); delay(350); tone(pin, cH, 150); delay(200); tone(pin, a, 1000); delay(1050); tone(pin, eH, 500); delay(550); tone(pin, eH, 500); delay(550); tone(pin, eH, 500); delay(550); tone(pin, fH, 350); delay(350); tone(pin, cH, 150); delay(200); tone(pin, gS, 500); delay(550); tone(pin, f, 350); delay(350); tone(pin, cH, 150); delay(200); tone(pin, a, 1000); delay(1050); tone(pin, aH, 500); delay(550); tone(pin, a, 350); delay(350); tone(pin, a, 150); delay(200); tone(pin, aH, 500); delay(550); tone(pin, gSH, 250);delay(250); tone(pin, gH, 250); delay(250); tone(pin, fSH, 125);delay(150); tone(pin, fH, 125); delay(150); tone(pin, fSH, 250);delay(250); delay(250); tone(pin, aS, 250); delay(250); tone(pin, dSH, 500);delay(550); tone(pin, dH, 250); delay(250); tone(pin, cSH, 250);delay(250); tone(pin, cH, 125); delay(150); tone(pin, b, 125); delay(150); tone(pin, cH, 250); delay(250); delay(250); tone(pin, f, 125); delay(150); tone(pin, gS, 500); delay(550); tone(pin, f, 375); delay(375+50); tone(pin, a, 125); delay(150); tone(pin, cH, 500); delay(550); tone(pin, a, 375); delay(400); tone(pin, cH, 125); delay(150); tone(pin, eH, 1000);delay(1050); tone(pin, aH, 500); delay(550); tone(pin, a, 350); delay(350); tone(pin, a, 150); delay(200); tone(pin, aH, 500); delay(550); tone(pin, gSH, 250);delay(250); tone(pin, gH, 250); delay(250); tone(pin, fSH, 125);delay(150); tone(pin, fH, 125); delay(150); tone(pin, fSH, 250);delay(250); delay(250); tone(pin, aS, 250); delay(250); tone(pin, dSH, 500);delay(550); tone(pin, dH, 250); delay(250); tone(pin, cSH, 250);delay(250); tone(pin, cH, 125); delay(150); tone(pin, b, 125); delay(150); tone(pin, cH, 250); delay(250); delay(250); tone(pin, f, 250); delay(250); tone(pin, gS, 500); delay(550); tone(pin, f, 375); delay(400); tone(pin, cH, 125); delay(150); tone(pin, a, 500); delay(550); tone(pin, f, 375); delay(400); tone(pin, c, 125); delay(150); tone(pin, a, 1000); delay(1050); delay(5000); } En el video \"prueba del zumbador en Masaylo-CRG\" que tenemos a continuaci\u00f3n podemos escuchar el resultado de grabar el c\u00f3digo anterior en el robot.","title":"Zumbador"},{"location":"conexionado-pruebas/UNO/test/#sensores-de-infrarrojos","text":"Para probar y ajustar los sensores de infrarrojos vamos a realizar un sencillo programa en MasayloBlockly como el que vemos en la imagen siguiente. Ejemplo para prueba de los sensores de infrarrojos Si es necesario retocaremos la posici\u00f3n del cursor del potenciometro de ajuste de sensibilidad teniendo en cuenta que es extremadamente sensible y que debemos dejarlo en una posici\u00f3n tal que al situar el sensor sobre una superficie negra el sensor onboard se apague y cuando lo sacamos del negro se encienda. El programa sensores-IR.bloc es muy sencillo y simplemente comprueba si el sensor izquierdo est\u00e1 sobre negro est\u00e1ndo el derecho sobre blanco, si esta condici\u00f3n es cierta el LED onboard del UNO har\u00e1 un parpadeo que repetir\u00e1 dos veces de forma lenta y nos mostrar\u00e1 un mensaje en el monitor serie. Un proceso similar se realiza con el sensor derecho sobre negro siendo esta vez el parpadeo r\u00e1pido y lo har\u00e1 tres veces. Si ninguno de los sensores detecta negro mostrar\u00e1 el correspondiente mensaje permaneciendo el LED apagado. En la imagen siguiente vemos el resultado que muestra el monitor serie al hacer que los sensores lean negro. Resultados obtenidos con el programa de prueba de los sensores de infrarrojos","title":"Sensores de infrarrojos"},{"location":"conexionado-pruebas/UNO/test/#sensor-de-distancia-hc-sr04","text":"El datasheet del sensor nos indica que debemos generar un pulso de al menos 10us en el pin Trigger o disparador. Si queremos asegurar un trigger bueno podemos poner el pin a nivel bajo durante 4us antes de general el pulso en si. En c\u00f3digo esto es algo como lo siguiente: digitalWrite(Pin_Trigger, LOW); delayMicroseconds(4); digitalWrite(Pin_Trigger, HIGH); delayMicroseconds(10); digitalWrite(Pin_Trigger, LOW); Este c\u00f3digo ya est\u00e1 implementado en la librer\u00eda que se describe en estas notas y, por supuesto lo est\u00e1 en Masaylo Blockly por lo que no debemos preocuparnos por ello. En este caso como ejemplo vamos a utilizar el que viene con la versi\u00f3n 1.1.4 de Masaylo Blockly titulado \"Env\u00eda la distancia al obst\u00e1culo detectado al puerto serie de tu ordenador\" y que podemos ver cargado en la imagen siguiente. Ejemplo \"Env\u00eda la distancia al obst\u00e1culo detectado al puerto serie de tu ordenador\" En la imagen siguiente vemos este mismo ejemplo con la definici\u00f3n de pines que se da en el pinout. Ejemplo \"Env\u00eda la distancia al obst\u00e1culo detectado al puerto serie de tu ordenador\" con A2 y A3 Se puede utilizar una u otra nomenclatura de forma indiferente y en cualquier caso lo que hace el ejemplo es enviarnos al puerto serie la distancia en cent\u00edmetros que est\u00e1 midiendo el sensor una vez por segundo. En la imagen siguiente vemos una ventana con resultados de diferentes distancias medidas por el sensor. Ejemplo \"Env\u00eda la distancia al obst\u00e1culo detectado al puerto serie de tu ordenador\" resultados","title":"Sensor de distancia HC-SR04"},{"location":"conexionado-pruebas/UNO/test/#servomotores","text":"En nuestro caso el robot va dotado de dos servos SG90, uno para accionar el brazo aparta obst\u00e1culos y el otro para accionar la cabeza y que el robot \"mire\" a un lado y otro. Para ambos servos vamos a crear unos programas muy simples que nos sirvan para verificar su funcionamiento. Prueba de funcionamiento del servo de cabeza . Implementamos, o descargamos el programa que vemos en la imagen siguiente: Ejemplo b\u00e1sico de funcionamiento del servo de cabeza En los ejemplos que acompa\u00f1an a la librer\u00eda y que se incluyen en Masaylo Blockly encontramos otras muchas funcionalidades de este servo. En la animaci\u00f3n siguiente vemos el resultado de programar el robot con el ejemplo anterior y como realiza movimientos de izquierda a derecha pasando por la posici\u00f3n central o mirar al frente. Animaci\u00f3n del ejemplo b\u00e1sico de funcionamiento del servo de cabeza Prueba de funcionamiento del servo del brazo . En el caso del brazo hay que tener en cuenta que, si posicionamos la placa UNO como hemos ido viendo en las distintas im\u00e1genes, al grabar este programa (o cualquier otro que trabaje con el servo del brazo) y mientras mantegamos conectado el cable USB, este va a molestar a los movimientos del brazo porque chocar\u00e1 con el mismo. Las opciones que tenemos para evitar que esto ocurra son: girar la placa UNO 180\u00ba sobre la posici\u00f3n indicada hasta ahora retirar el brazo en tanto trabajamos con la conexi\u00f3n USB y colocarlo en el robot para su funcionamiento aut\u00f3nomo colocar el servo junto con el brazo en el otro costado del robot En la imagen siguiente vemos el robot con el servo cambiado de costado. Servo del brazo posicionado a la izquierda Implementamos, o descargamos el programa que vemos en la imagen siguiente: Ejemplo b\u00e1sico de funcionamiento del servo del brazo En los ejemplos que acompa\u00f1an a la librer\u00eda y que se incluyen en Masaylo Blockly encontramos otras muchas funcionalidades de este servo. En la animaci\u00f3n siguiente vemos el resultado de programar el robot con un ejemplo en el que el brazo est\u00e1 colocado en el costado derecho y como realiza movimientos de posicionado del brazo envolviendo al objeto que supuestamente habr\u00eda delante y retracci\u00f3n del brazo a su posici\u00f3n de replegado pasando por la posici\u00f3n central o posici\u00f3n vertical del brazo. Animaci\u00f3n del ejemplo b\u00e1sico de funcionamiento del servo del brazo","title":"Servomotores"},{"location":"conexionado-pruebas/UNO/test/#encoder-infrarrojos-fc-03","text":"Para probar el funcionamiento de los encoders vamos a recurrir de nuevo al IDE 1.8.15 de Arduino montando dos ejemplos totalmente similares pero probando cada encoder por separado. Estos ejemplos est\u00e1n inspirados en la implementaci\u00f3n que se hace de los mismos en el robot Andromina OFF ROAD y los detalles analizados en el blog Andromina robot V.2.0 Posteriormente podremos probar distintos ejemplos integrados en la librer\u00eda que l\u00f3gicamente utilizar\u00e1n ambos encoders simult\u00e1neamente. Encoder izquierdo A continuaci\u00f3n vemos el c\u00f3digo comentado de la prueba que vamos a realizar y que puedes descargar o copiar para grabarlo en tu robot y as\u00ed comprobar que el encoder izquierdo funciona correctamente. const int pwm_izdo = 6; //pines y variables motor y encoder izquierdo const int IN1 = 7; const int IN2 = 8; int encoder_izdo = 2; unsigned int rpm_izdo = 0; float vel_izdo = 0; //en Km/h volatile byte pulsos_leidos = 0; // N\u00famero de pulsos leidos en un segundo unsigned long tiempo_anterior = 0; // Tiempo unsigned int muescas = 20; //n\u00famero de muescas del disco del encoder. const int diametro_rueda = 75; //Di\u00e1metro de las ruedas en mm static volatile unsigned long debounce = 0; //Tiempo del rebote. void setup(){ pinMode(pwm_izdo,OUTPUT); pinMode(IN1,OUTPUT); pinMode(IN2,OUTPUT); Serial.begin(9600); pinMode(encoder_izdo, INPUT); attachInterrupt(0, contador, RISING); //Configuraci\u00f3n de la interrupci\u00f3n 0 pulsos_leidos = 0; rpm_izdo = 0; tiempo_anterior = 0; Serial.println(\"MOTOR IZQUIERDO:\"); Serial.print(\"Segundos - \"); Serial.print(\"RPM - \"); Serial.print(\"Pulsos leidos - \"); Serial.println(\"Velocidad (Km/h)\"); Serial.println(\"======== === ============= ================\"); } void loop(){ if (millis() - tiempo_anterior >= 1000){ //Se actualiza cada segundo noInterrupts(); // Desconectamos la interrupci\u00f3n para que no actu\u00e9 en esta parte del programa. digitalWrite(IN1,HIGH); digitalWrite(IN2,LOW); analogWrite(pwm_izdo,255); //a m\u00e1xima velocidad rpm_izdo = (60 * 1000 / muescas )/ (millis() - tiempo_anterior)* pulsos_leidos; //C\u00e1lculo de las revoluciones por minuto vel_izdo = rpm_izdo * 3.1416 * diametro_rueda * 60 / 1000000; //C\u00e1lculo de la vel_izdo en Km/h tiempo_anterior = millis(); //Almacenamos el tiempo actual. Serial.print(\" \"); Serial.print(millis()/1000); Serial.print(\" \"); Serial.print(rpm_izdo,DEC); Serial.print(\" \"); Serial.print(pulsos_leidos,DEC); Serial.print(\" \"); Serial.println(vel_izdo,2); pulsos_leidos = 0; //Inicializamos los pulsos interrupts(); //Reiniciamos la interrupci\u00f3n } } //La funci\u00f3n contador se encarga de contar los pulsos buenos void contador(){ if(digitalRead(encoder_izdo) && (micros()-debounce > 500) && digitalRead (encoder_izdo)){ debounce = micros(); //para comprobar que no contamos rebotes pulsos_leidos++;} //Cuen ta el pulso como bueno } En la imagen siguiente tenemos una captura del terminal serie con los resultados para el encoder izquierdo. Resultados del ejemplo b\u00e1sico para prueba del encoder izquierdo Encoder derecho A continuaci\u00f3n vemos el c\u00f3digo comentado de la prueba que vamos a realizar y que puedes descargar o copiar para grabarlo en tu robot y as\u00ed comprobar que el encoder derecho funciona correctamente. const int pwm_dcho = 11; //pines y variables motor y encoder derecho const int IN3 = 12; const int IN4 = 13; int encoder_dcho = 3; unsigned int rpm_dcho = 0; float vel_dcho = 0; //en Km/h volatile byte pulsos_leidos = 0; // N\u00famero de pulsos leidos en un segundo unsigned long tiempo_anterior = 0; // Tiempo unsigned int muescas = 20; //n\u00famero de muescas del disco del encoder. const int diametro_rueda = 75; //Di\u00e1metro de las ruedas en mm static volatile unsigned long debounce = 0; //Tiempo del rebote. void setup(){ pinMode(pwm_dcho,OUTPUT); pinMode(IN3,OUTPUT); pinMode(IN4,OUTPUT); Serial.begin(9600); pinMode(encoder_dcho, INPUT); attachInterrupt(1, contador, RISING); //Configuraci\u00f3n de la interrupci\u00f3n 1 pulsos_leidos = 0; rpm_dcho = 0; tiempo_anterior = 0; Serial.println(\"MOTOR DERECHO:\"); Serial.print(\"Segundos - \"); Serial.print(\"RPM - \"); Serial.print(\"Pulsos leidos - \"); Serial.println(\"Velocidad (Km/h)\"); Serial.println(\"======== === ============= ================\"); } void loop(){ if (millis() - tiempo_anterior >= 1000){ //Se actualiza cada segundo noInterrupts(); // Desconectamos la interrupci\u00f3n para que no actu\u00e9 en esta parte del programa. digitalWrite(IN3,HIGH); digitalWrite(IN4,LOW); analogWrite(pwm_dcho,255); //a m\u00e1xima velocidad rpm_dcho = (60 * 1000 / muescas )/ (millis() - tiempo_anterior)* pulsos_leidos; //C\u00e1lculo de las revoluciones por minuto vel_dcho = rpm_dcho * 3.1416 * diametro_rueda * 60 / 1000000; //C\u00e1lculo de la vel_dcho en Km/h tiempo_anterior = millis(); //Almacenamos el tiempo actual. Serial.print(\" \"); Serial.print(millis()/1000); Serial.print(\" \"); Serial.print(rpm_dcho,DEC); Serial.print(\" \"); Serial.print(pulsos_leidos,DEC); Serial.print(\" \"); Serial.println(vel_dcho,2); pulsos_leidos = 0; //Inicializamos los pulsos interrupts(); //Reiniciamos la interrupci\u00f3n } } //La funci\u00f3n contador se encarga de contar los pulsos buenos void contador(){ if(digitalRead(encoder_dcho) && (micros()-debounce > 500) && digitalRead (encoder_dcho)){ debounce = micros(); //para comprobar que no contamos rebotes pulsos_leidos++;} //Cuen ta el pulso como bueno } En la imagen siguiente tenemos una captura del terminal serie con los resultados para el encoder derecho. Resultados del ejemplo b\u00e1sico para prueba del encoder derecho","title":"Encoder infrarrojos FC-03"},{"location":"libreria/ejemplos/","text":"Ejemplos de Masaylo \u00b6 La librer\u00eda de Masaylo incorpora una serie de ejemplos para poder probar el robot de forma directa, para ello vamos al men\u00fa Archivo > Ejemplos > Masaylo, y escogemos el ejemplo que nos interese. Ejemplos de Masaylo","title":"Ejemplos de Masaylo"},{"location":"libreria/ejemplos/#ejemplos-de-masaylo","text":"La librer\u00eda de Masaylo incorpora una serie de ejemplos para poder probar el robot de forma directa, para ello vamos al men\u00fa Archivo > Ejemplos > Masaylo, y escogemos el ejemplo que nos interese. Ejemplos de Masaylo","title":"Ejemplos de Masaylo"},{"location":"libreria/encoders/","text":"Encoders y Masaylo \u00b6 Masaylo puede incorporar dos sensores de infrarrojos tipo encoder, uno en cada una de las ruedas del mismo. Estos dispositivos sirven para poder determinar de forma optica el \u00e1ngulo de giro que se desplaza cada rueda, y por tanto tambi\u00e9n somos capaces de conocer los desplazamientos del robot. Con estos elementos podemos girar un determinado \u00e1ngulo nuestro robot o bien moverlo una cierta distancia. Encoders esquema Encoders foto Las \u00f3rdenes que tenemos para controlar los encoders son las siguientes: objetoMasaylo.encoders (pinIzdoEncoder, pinDchoEncoder, diametro cm) : Configura los pines de los sensores infrarrojos de los encoders y el di\u00e1metro en cm de las ruedas. Si no pasas par\u00e1metros objetoMasaylo.encoders() , pone los valores objetoMasaylo.encoders(2,3,7.8) , por tanto se asigna el pin digital 2 al sensor izquierdo y el 3 al derecho, adem\u00e1s configura un di\u00e1metro de rueda de 7.8 cm. Recordar que esta instrucci\u00f3n al ser de configuraci\u00f3n debe estar en el setup de nuestro programa. En el ejemplo m.encoders (2,3,7.8) . objetoMasaylo.distancia (distancia cm) : Espera hasta que ambas ruedas del robot se han movido la cantidad de cm que le hemos pasado. En el ejemplo m.distancia (20) . objetoMasaylo.angulo (angulo grados) : Espera hasta que ambas ruedas del robot han girado el angulo pasado. En el ejemplo m.angulo (90) . objetoMasaylo.vueltas (n_vueltas) : Espera hasta que ambas ruedas del robot Masaylo han girado el numero de vueltas indicadas. En el ejemplo que presentamos a continuaci\u00f3n (ejemplo 3 de la librer\u00eda), hacemos un bucle for para repetir cuatro veces el desplazamiento del robot 20 cm y el giro hacia derechas de 90\u00ba, por tanto el robot debe realizar un desplazamiento en forma de cuadrado. Uso de encoders","title":"Encoders. Control de distancias y \u00e1ngulos"},{"location":"libreria/encoders/#encoders-y-masaylo","text":"Masaylo puede incorporar dos sensores de infrarrojos tipo encoder, uno en cada una de las ruedas del mismo. Estos dispositivos sirven para poder determinar de forma optica el \u00e1ngulo de giro que se desplaza cada rueda, y por tanto tambi\u00e9n somos capaces de conocer los desplazamientos del robot. Con estos elementos podemos girar un determinado \u00e1ngulo nuestro robot o bien moverlo una cierta distancia. Encoders esquema Encoders foto Las \u00f3rdenes que tenemos para controlar los encoders son las siguientes: objetoMasaylo.encoders (pinIzdoEncoder, pinDchoEncoder, diametro cm) : Configura los pines de los sensores infrarrojos de los encoders y el di\u00e1metro en cm de las ruedas. Si no pasas par\u00e1metros objetoMasaylo.encoders() , pone los valores objetoMasaylo.encoders(2,3,7.8) , por tanto se asigna el pin digital 2 al sensor izquierdo y el 3 al derecho, adem\u00e1s configura un di\u00e1metro de rueda de 7.8 cm. Recordar que esta instrucci\u00f3n al ser de configuraci\u00f3n debe estar en el setup de nuestro programa. En el ejemplo m.encoders (2,3,7.8) . objetoMasaylo.distancia (distancia cm) : Espera hasta que ambas ruedas del robot se han movido la cantidad de cm que le hemos pasado. En el ejemplo m.distancia (20) . objetoMasaylo.angulo (angulo grados) : Espera hasta que ambas ruedas del robot han girado el angulo pasado. En el ejemplo m.angulo (90) . objetoMasaylo.vueltas (n_vueltas) : Espera hasta que ambas ruedas del robot Masaylo han girado el numero de vueltas indicadas. En el ejemplo que presentamos a continuaci\u00f3n (ejemplo 3 de la librer\u00eda), hacemos un bucle for para repetir cuatro veces el desplazamiento del robot 20 cm y el giro hacia derechas de 90\u00ba, por tanto el robot debe realizar un desplazamiento en forma de cuadrado. Uso de encoders","title":"Encoders y Masaylo"},{"location":"libreria/incorporar_libreria/","text":"Incorporar la librer\u00eda en un programa \u00b6 El siguiente paso es que las instrucciones para controlar nuestro robot, que est\u00e1n dentro de la librer\u00eda, est\u00e9n disponibles, por eso debemos incluir la librer\u00eda en nuestro c\u00f3digo, para ello: Men\u00fa Programa > Incluir librer\u00eda > Masaylo Escoger la librer\u00eda una vez instalada En el c\u00f3digo aparecen en las dos primeras l\u00edneas: #include <Encoder.h> #include <Masaylo.h> Estas dos l\u00edneas de c\u00f3digo son las que incorporan la librer\u00eda a nuestro programa para poder controlar el robot. Librer\u00eda incorporada","title":"Incorporaci\u00f3n de la librer\u00eda en un programa"},{"location":"libreria/incorporar_libreria/#incorporar-la-libreria-en-un-programa","text":"El siguiente paso es que las instrucciones para controlar nuestro robot, que est\u00e1n dentro de la librer\u00eda, est\u00e9n disponibles, por eso debemos incluir la librer\u00eda en nuestro c\u00f3digo, para ello: Men\u00fa Programa > Incluir librer\u00eda > Masaylo Escoger la librer\u00eda una vez instalada En el c\u00f3digo aparecen en las dos primeras l\u00edneas: #include <Encoder.h> #include <Masaylo.h> Estas dos l\u00edneas de c\u00f3digo son las que incorporan la librer\u00eda a nuestro programa para poder controlar el robot. Librer\u00eda incorporada","title":"Incorporar la librer\u00eda en un programa"},{"location":"libreria/infrarrojos/","text":"Infrarrojos y Masaylo \u00b6 Masaylo incorpora dos sensores de infrarrojos alojados en sendos portasensores en la parte delantera cercanos al suelo, el objeto de los mismos es detectar reflexi\u00f3n o no de luz infrarroja sobre una superficie, pudiendo distinguir entre superficies que reflejan (blanco) y otras que no lo hacen (negro). Infrarrojos Las \u00f3rdenes que tenemos para controlar los sensores de infrarrojos son las siguientes: objetoMasaylo.infrarrojos (pinIzdoIr,pinDchoIr) : Configura los pines de los sensores infrarrojos de suelo del robot. Si no pasas par\u00e1metros objetoMasaylo.infrarrojos() , pone los valores objetoMasaylo.infrarrojos(14,15) , asociando el sensor izquierdo al pin 14 (A0), y el derecho al pin 15 (A1), esta instrucci\u00f3n debe estar en el setup de nuetro programa. En nuestro caso del ejemplo m.infrarrojos (14,15) . objetoMasaylo.nIzquierda () : Nos devuelve \"true\" si el sensor de infrarrojos izquierdo est\u00e1 a negro y \"false\" si no lo est\u00e1. En nuestro ejemplo m.nIzquierda() . objetoMasaylo.nDerecha () : Nos devuelve \"true\" si el sensor de infrarrojos derecho est\u00e1 a negro y \"false\" si no lo est\u00e1. En nuestro ejemplo m.nDerecha() . objetoMasaylo.bIzquierda () : Nos devuelve \"true\" si el sensor de infrarrojos izquierdo est\u00e1 a blanco y \"false\" si no lo est\u00e1. En nuestro ejemplo m.bIzquierda() . objetoMasaylo.bDerecha () : Nos devuelve \"true\" si el sensor de infrarrojos derecho est\u00e1 a blanco y \"false\" si no lo est\u00e1. En nuestro ejemplo m.bDerecha() . En el ejemplo que presentamos a continuaci\u00f3n (ejemplo 9 de la librer\u00eda), se configura el sensor de infrarrojos, y posteriormente, con varios condicionales, se comprueba todas las combinaciones posibles de estados de blanco y negro de los sensores, para mostrar el estado actual de los mismos en la pantalla del ordenador a trav\u00e9s de comunicaci\u00f3n serie. Uso de infrarrojos","title":"Infrarrojos. Detecci\u00f3n l\u00edneas negras"},{"location":"libreria/infrarrojos/#infrarrojos-y-masaylo","text":"Masaylo incorpora dos sensores de infrarrojos alojados en sendos portasensores en la parte delantera cercanos al suelo, el objeto de los mismos es detectar reflexi\u00f3n o no de luz infrarroja sobre una superficie, pudiendo distinguir entre superficies que reflejan (blanco) y otras que no lo hacen (negro). Infrarrojos Las \u00f3rdenes que tenemos para controlar los sensores de infrarrojos son las siguientes: objetoMasaylo.infrarrojos (pinIzdoIr,pinDchoIr) : Configura los pines de los sensores infrarrojos de suelo del robot. Si no pasas par\u00e1metros objetoMasaylo.infrarrojos() , pone los valores objetoMasaylo.infrarrojos(14,15) , asociando el sensor izquierdo al pin 14 (A0), y el derecho al pin 15 (A1), esta instrucci\u00f3n debe estar en el setup de nuetro programa. En nuestro caso del ejemplo m.infrarrojos (14,15) . objetoMasaylo.nIzquierda () : Nos devuelve \"true\" si el sensor de infrarrojos izquierdo est\u00e1 a negro y \"false\" si no lo est\u00e1. En nuestro ejemplo m.nIzquierda() . objetoMasaylo.nDerecha () : Nos devuelve \"true\" si el sensor de infrarrojos derecho est\u00e1 a negro y \"false\" si no lo est\u00e1. En nuestro ejemplo m.nDerecha() . objetoMasaylo.bIzquierda () : Nos devuelve \"true\" si el sensor de infrarrojos izquierdo est\u00e1 a blanco y \"false\" si no lo est\u00e1. En nuestro ejemplo m.bIzquierda() . objetoMasaylo.bDerecha () : Nos devuelve \"true\" si el sensor de infrarrojos derecho est\u00e1 a blanco y \"false\" si no lo est\u00e1. En nuestro ejemplo m.bDerecha() . En el ejemplo que presentamos a continuaci\u00f3n (ejemplo 9 de la librer\u00eda), se configura el sensor de infrarrojos, y posteriormente, con varios condicionales, se comprueba todas las combinaciones posibles de estados de blanco y negro de los sensores, para mostrar el estado actual de los mismos en la pantalla del ordenador a trav\u00e9s de comunicaci\u00f3n serie. Uso de infrarrojos","title":"Infrarrojos y Masaylo"},{"location":"libreria/instalacion/","text":"Instalaci\u00f3n de la librer\u00eda para Arduino \u00b6 La librer\u00eda se instala como cualquier librer\u00eda de arduino: Descargamos la Librer\u00eda . Abrimos el IDE de Arduino (entorno de desarrollo de Arduino). Para instalarlo si no lo tienes, lo puedes descargar en la direcci\u00f3n: https://www.arduino.cc/en/software Nos dirigimos al Men\u00fa Programa > Incluir librer\u00eda > A\u00f1adir biblioteca .ZIP ... Incluir librer\u00eda a\u00f1adir .zip En la siguiente ventana elegimos la ruta de la biblioteca o librer\u00eda a instalar, que en nuestro caso es Masaylo.zip, habr\u00e1 que recordar d\u00f3nde la descargamos previamente. Incluir librer\u00eda elegir .zip","title":"Instalaci\u00f3n"},{"location":"libreria/instalacion/#instalacion-de-la-libreria-para-arduino","text":"La librer\u00eda se instala como cualquier librer\u00eda de arduino: Descargamos la Librer\u00eda . Abrimos el IDE de Arduino (entorno de desarrollo de Arduino). Para instalarlo si no lo tienes, lo puedes descargar en la direcci\u00f3n: https://www.arduino.cc/en/software Nos dirigimos al Men\u00fa Programa > Incluir librer\u00eda > A\u00f1adir biblioteca .ZIP ... Incluir librer\u00eda a\u00f1adir .zip En la siguiente ventana elegimos la ruta de la biblioteca o librer\u00eda a instalar, que en nuestro caso es Masaylo.zip, habr\u00e1 que recordar d\u00f3nde la descargamos previamente. Incluir librer\u00eda elegir .zip","title":"Instalaci\u00f3n de la librer\u00eda para Arduino"},{"location":"libreria/motores/","text":"Controlar motores de Masaylo \u00b6 Motores Para el control de los dos motores de corriente cont\u00ednua que mueven a Masaylo, lo primero que debemos hacer es crear un objeto tipo robot Masaylo, para ello pondremos la l\u00ednea antes de void setup(), Masaylo objetoMasaylo , en nuestro caso Masaylo m (nuestro robot Masaylo se llama m). Crear objeto Masaylo En la funci\u00f3n setup(), ya sab\u00e9is que se ejecuta una sola vez, vamos a definir los pines de los motores, lo que se puede hacer de dos maneras: Sin pasar par\u00e1metros (sin colocar nada entre los par\u00e9ntesis), objetoMasaylo.init() , en nuestro caso de ejemplo m.init() : con esta orden indicamos que los pines de los motores son los que trae por defecto objetoMasaylo.init(6,7,8,11,12,13) , siendo el orden de los pines definidos de izquierda a derecha, pin de control de velocidad de giro (PWM) del motor izquierdo, pin A del motor izquierdo, pin B del motor izquierdo, pin de control de velocidad de giro (PWM) del motor derecho, pin A del motor derecho, pin B del motor derecho. Pasando par\u00e1metros de pines (coloc\u00e1ndolos entre par\u00e9ntesis), objetoMasaylo.init (pinPWMMotorIzdo,pinAMotorIzdo,pinBMotorIzdo,pinPWMMotorDcho,pinAMotorDcho,pinBMotorDcho) , de esta manera podr\u00edamos conectar nuestros motores a los pines que deseemos, un ejemplo podr\u00eda ser m.init(6,7,8,11,12,13) . Pasamos a explicar las instrucciones para mover el robot: objetoMasaylo.adelante (velocidad) : Mueve el robot Masaylo hacia delante, le podemos pasar el valor de la velocidad a la que lo hace (entre 0 y 255), si no pasamos valor, par\u00e9ntesis sin valor, lo hace a 255. En nuestro caso del ejemplo m.adelante() . objetoMasaylo.atras (velocidad) : Mueve el robot Masaylo hacia atr\u00e1s, le podemos pasar el valor de la velocidad a la que lo hace (entre 0 y 255), si no pasamos valor, par\u00e9ntesis sin valor, lo hace a 255. En nuestro caso del ejemplo m.atras() . objetoMasaylo.izquierda (velocidad) : Gira (pivota) el robot Masaylo hacia la izquierda, le podemos pasar el valor de la velocidad a la que lo hace (entre 0 y 255), si no pasamos valor, par\u00e9ntesis sin valor, lo hace a 255. En nuestro caso del ejemplo m.izquierda() . objetoMasaylo.derecha (velocidad) : Gira (pivota) el robot Masaylo hacia la derecha, le podemos pasar el valor de la velocidad a la que lo hace (entre 0 y 255), si no pasamos valor, par\u00e9ntesis sin valor, lo hace a 255. En nuestro caso del ejemplo m.derecha() . objetoMasaylo.alto () : Para el robot Masaylo. En nuestro caso del ejemplo m.alto() . A continuaci\u00f3n vemos estas \u00f3rdenes reflejadas en el ejemplo 01 de la librer\u00eda: Ejemplo 01 de la librer\u00eda En el ejemplo 02 vemos como se pasan valores de velocidad a los movimientos de nuestro robot: Ejemplo 02 de la librer\u00eda","title":"Control de motores y movimientos"},{"location":"libreria/motores/#controlar-motores-de-masaylo","text":"Motores Para el control de los dos motores de corriente cont\u00ednua que mueven a Masaylo, lo primero que debemos hacer es crear un objeto tipo robot Masaylo, para ello pondremos la l\u00ednea antes de void setup(), Masaylo objetoMasaylo , en nuestro caso Masaylo m (nuestro robot Masaylo se llama m). Crear objeto Masaylo En la funci\u00f3n setup(), ya sab\u00e9is que se ejecuta una sola vez, vamos a definir los pines de los motores, lo que se puede hacer de dos maneras: Sin pasar par\u00e1metros (sin colocar nada entre los par\u00e9ntesis), objetoMasaylo.init() , en nuestro caso de ejemplo m.init() : con esta orden indicamos que los pines de los motores son los que trae por defecto objetoMasaylo.init(6,7,8,11,12,13) , siendo el orden de los pines definidos de izquierda a derecha, pin de control de velocidad de giro (PWM) del motor izquierdo, pin A del motor izquierdo, pin B del motor izquierdo, pin de control de velocidad de giro (PWM) del motor derecho, pin A del motor derecho, pin B del motor derecho. Pasando par\u00e1metros de pines (coloc\u00e1ndolos entre par\u00e9ntesis), objetoMasaylo.init (pinPWMMotorIzdo,pinAMotorIzdo,pinBMotorIzdo,pinPWMMotorDcho,pinAMotorDcho,pinBMotorDcho) , de esta manera podr\u00edamos conectar nuestros motores a los pines que deseemos, un ejemplo podr\u00eda ser m.init(6,7,8,11,12,13) . Pasamos a explicar las instrucciones para mover el robot: objetoMasaylo.adelante (velocidad) : Mueve el robot Masaylo hacia delante, le podemos pasar el valor de la velocidad a la que lo hace (entre 0 y 255), si no pasamos valor, par\u00e9ntesis sin valor, lo hace a 255. En nuestro caso del ejemplo m.adelante() . objetoMasaylo.atras (velocidad) : Mueve el robot Masaylo hacia atr\u00e1s, le podemos pasar el valor de la velocidad a la que lo hace (entre 0 y 255), si no pasamos valor, par\u00e9ntesis sin valor, lo hace a 255. En nuestro caso del ejemplo m.atras() . objetoMasaylo.izquierda (velocidad) : Gira (pivota) el robot Masaylo hacia la izquierda, le podemos pasar el valor de la velocidad a la que lo hace (entre 0 y 255), si no pasamos valor, par\u00e9ntesis sin valor, lo hace a 255. En nuestro caso del ejemplo m.izquierda() . objetoMasaylo.derecha (velocidad) : Gira (pivota) el robot Masaylo hacia la derecha, le podemos pasar el valor de la velocidad a la que lo hace (entre 0 y 255), si no pasamos valor, par\u00e9ntesis sin valor, lo hace a 255. En nuestro caso del ejemplo m.derecha() . objetoMasaylo.alto () : Para el robot Masaylo. En nuestro caso del ejemplo m.alto() . A continuaci\u00f3n vemos estas \u00f3rdenes reflejadas en el ejemplo 01 de la librer\u00eda: Ejemplo 01 de la librer\u00eda En el ejemplo 02 vemos como se pasan valores de velocidad a los movimientos de nuestro robot: Ejemplo 02 de la librer\u00eda","title":"Controlar motores de Masaylo"},{"location":"libreria/por_que/","text":"El por qu\u00e9 de la librer\u00eda \u00b6 Unos de los problemas para controlar robots muchas veces es la ausencia de instrucciones amigables en arduino para controlar sus elementos (motores dc, sensor de ultrasonidos, sensores infrarrojos para seguir l\u00edneas, control de distancias y giros a trav\u00e9s de encoders, servomotores y zumbadores), todo ello pensando en facilitar el uso de dicho robot para estudiantes de secundaria. Por este motivo, a trav\u00e9s de la colaboraci\u00f3n entre el Club de Rob\u00f3tica Granada y Antonio G\u00f3mez , nos planteamos adaptar la librer\u00eda de su robot Masaylo para el control de una revisi\u00f3n de dicho robot.","title":"Por qu\u00e9 de la librer\u00eda"},{"location":"libreria/por_que/#el-por-que-de-la-libreria","text":"Unos de los problemas para controlar robots muchas veces es la ausencia de instrucciones amigables en arduino para controlar sus elementos (motores dc, sensor de ultrasonidos, sensores infrarrojos para seguir l\u00edneas, control de distancias y giros a trav\u00e9s de encoders, servomotores y zumbadores), todo ello pensando en facilitar el uso de dicho robot para estudiantes de secundaria. Por este motivo, a trav\u00e9s de la colaboraci\u00f3n entre el Club de Rob\u00f3tica Granada y Antonio G\u00f3mez , nos planteamos adaptar la librer\u00eda de su robot Masaylo para el control de una revisi\u00f3n de dicho robot.","title":"El por qu\u00e9 de la librer\u00eda"},{"location":"libreria/servos/","text":"Servomotores y Masaylo \u00b6 Masaylo incorpora dos servomotores, uno que nos sirve para girar el sensor de ultrasonidos situado en la zona delantera del robot, y otro para girar el brazo que sirve para capturar objetos. Los servomotores que presenta Masaylo son los microservos SG-90 que permiten un giro entre 0\u00ba y 179\u00ba. Servomotores Las \u00f3rdenes que tenemos para controlar los servomotores son: objetoMasaylo.servos (pin servocabeza, pin servobrazo) : Configura los pines de los servos de la cabeza y del brazo respectivamente. Si no pasas par\u00e1metros objetoMasaylo.servos() , pone los valores objetoMasaylo.servos(5,4) , por tanto el servo de la cabeza (ultrasonidos) es asignado al pin digital 5 y el servo del brazo al pin digital 4, esta instrucci\u00f3n debe estar en el setup de nuestro programa. En el ejemplo m.servos(5,4) . objetoMasaylo.giracabeza (grados) : Gira el servo de la cabeza un \u00e1ngulo dado entre 0\u00ba y 179\u00ba. En el ejemplo m.giracabeza (i) , siendo i una variable en este caso. objetoMasaylo.girabrazo (grados) : Gira el servo del brazo un \u00e1ngulo dado entre 0\u00ba y 179\u00ba. En el ejemplo que presentamos a continuaci\u00f3n (ejemplo 6 de la librer\u00eda) se configura los pines de los servomotores, para posteriormente producir un movimiento giratorio alternativo del sensor de ultrasonidos, movi\u00e9ndolo con un microservo de 10\u00ba a 170\u00ba y de 170\u00ba a 10\u00ba. Control de servomotores","title":"Uso de Servomotores en cabeza y brazo"},{"location":"libreria/servos/#servomotores-y-masaylo","text":"Masaylo incorpora dos servomotores, uno que nos sirve para girar el sensor de ultrasonidos situado en la zona delantera del robot, y otro para girar el brazo que sirve para capturar objetos. Los servomotores que presenta Masaylo son los microservos SG-90 que permiten un giro entre 0\u00ba y 179\u00ba. Servomotores Las \u00f3rdenes que tenemos para controlar los servomotores son: objetoMasaylo.servos (pin servocabeza, pin servobrazo) : Configura los pines de los servos de la cabeza y del brazo respectivamente. Si no pasas par\u00e1metros objetoMasaylo.servos() , pone los valores objetoMasaylo.servos(5,4) , por tanto el servo de la cabeza (ultrasonidos) es asignado al pin digital 5 y el servo del brazo al pin digital 4, esta instrucci\u00f3n debe estar en el setup de nuestro programa. En el ejemplo m.servos(5,4) . objetoMasaylo.giracabeza (grados) : Gira el servo de la cabeza un \u00e1ngulo dado entre 0\u00ba y 179\u00ba. En el ejemplo m.giracabeza (i) , siendo i una variable en este caso. objetoMasaylo.girabrazo (grados) : Gira el servo del brazo un \u00e1ngulo dado entre 0\u00ba y 179\u00ba. En el ejemplo que presentamos a continuaci\u00f3n (ejemplo 6 de la librer\u00eda) se configura los pines de los servomotores, para posteriormente producir un movimiento giratorio alternativo del sensor de ultrasonidos, movi\u00e9ndolo con un microservo de 10\u00ba a 170\u00ba y de 170\u00ba a 10\u00ba. Control de servomotores","title":"Servomotores y Masaylo"},{"location":"libreria/ultrasonidos/","text":"Ultrasonidos y Masaylo \u00b6 Masaylo incorpora un sensor de ultrasonidos en su parte delantera, que nos servir\u00e1 para medir distancias a los objetos que pueda encontrar en su camino. Sensor de Ultrasonidos Las \u00f3rdenes que tenemos para controlar el sensor de ultrasonidos son: objetoMasaylo.ultrasonidos (pinTrigger,pinEcho) : Configura los pines trigger y echo del sensor de ultrasonidos. Si no pasas par\u00e1metros objetoMasaylo.ultrasonidos() , pone los valores objetoMasaylo.ultrasonidos(16,17) , de esta forma el pin del Trigger es el 16 (A2), y el pin del Echo es el 17 (A3), esta instrucci\u00f3n debe estar en el setup de nuestro programa. En nuestro caso del ejemplo m.ultrasonidos (16,17) . objetoMasaylo.distancia () : Nos devuelve la distancia en cm entre el sensor de ultrasonidos y el objeto que tenga enfrentado. En nuestro caso del ejemplo m.distancia() . En el ejemplo que presentamos a continuaci\u00f3n (ejemplo 8 de la librer\u00eda), se configura el sensor de ultrasonidos, para mostrar por el puerto serie la distancia a la que se encuentra un objeto enfrentado al robot masaylo. Uso de ultrasonidos","title":"Ultrasonidos. Detecci\u00f3n de obst\u00e1culos"},{"location":"libreria/ultrasonidos/#ultrasonidos-y-masaylo","text":"Masaylo incorpora un sensor de ultrasonidos en su parte delantera, que nos servir\u00e1 para medir distancias a los objetos que pueda encontrar en su camino. Sensor de Ultrasonidos Las \u00f3rdenes que tenemos para controlar el sensor de ultrasonidos son: objetoMasaylo.ultrasonidos (pinTrigger,pinEcho) : Configura los pines trigger y echo del sensor de ultrasonidos. Si no pasas par\u00e1metros objetoMasaylo.ultrasonidos() , pone los valores objetoMasaylo.ultrasonidos(16,17) , de esta forma el pin del Trigger es el 16 (A2), y el pin del Echo es el 17 (A3), esta instrucci\u00f3n debe estar en el setup de nuestro programa. En nuestro caso del ejemplo m.ultrasonidos (16,17) . objetoMasaylo.distancia () : Nos devuelve la distancia en cm entre el sensor de ultrasonidos y el objeto que tenga enfrentado. En nuestro caso del ejemplo m.distancia() . En el ejemplo que presentamos a continuaci\u00f3n (ejemplo 8 de la librer\u00eda), se configura el sensor de ultrasonidos, para mostrar por el puerto serie la distancia a la que se encuentra un objeto enfrentado al robot masaylo. Uso de ultrasonidos","title":"Ultrasonidos y Masaylo"},{"location":"libreria/zumbador/","text":"Sonidos y Masaylo (Zumbador) \u00b6 Masaylo incorpora un zumbador piezoel\u00e9ctrico en su parte trasera, que nos servir\u00e1 para reproducir sonidos y/o melod\u00edas. Zumbador Las \u00f3rdenes que tenemos para controlar el zumbador son las siguientes: objetoMasaylo.buzzer (pin buzzer) : Configura el pin del buzzer. Si no pasas par\u00e1metros objetoMasaylo.buzzer() , pone los valores objetoMasaylo.buzzer(1) , por tanto habr\u00eda que conectarlo al pin digital 1. Esta orden como es de configuraci\u00f3n debe estar en el setup de nuestro programa. En el ejemplo m.buzzer(1) . objetoMasaylo.tono (frecuencia Hz, duraci\u00f3n ms) : emite un sonido en el zumbador configurado anteriormente, de una cierta frecuencia en Hz y duraci\u00f3n en ms. En el ejemplo hay varias apliacciones como m.tono (re,duracion) , siendo re y duraci\u00f3n constantes con valores enteros. En el siguiente ejemplo (ejemplo 10 de la librer\u00eda), se implementa una escala musical, creando constantes con las frecuencias de las notas de la escala, y constantes con la duraci\u00f3n en ms de la nota y el retardo entre nota y nota. #include <Masaylo.h> Masaylo m; const int do2 = 261; const int re = 293; const int mi = 329; const int fa = 349; const int sol = 392; const int la = 440; const int si = 493; const int duracion = 500; const int retardo = 100; //no hay definiciones void setup() { m.init(); m.buzzer(1); } void loop() { m.tono(do2,duracion); delay(retardo); m.tono(re,duracion); delay(retardo); m.tono(mi,duracion); delay(retardo); m.tono(fa,duracion); delay(retardo); m.tono(sol,duracion); delay(retardo); m.tono(la,duracion); delay(retardo); m.tono(si,duracion); delay(retardo); }","title":"Zumbador. Sonidos"},{"location":"libreria/zumbador/#sonidos-y-masaylo-zumbador","text":"Masaylo incorpora un zumbador piezoel\u00e9ctrico en su parte trasera, que nos servir\u00e1 para reproducir sonidos y/o melod\u00edas. Zumbador Las \u00f3rdenes que tenemos para controlar el zumbador son las siguientes: objetoMasaylo.buzzer (pin buzzer) : Configura el pin del buzzer. Si no pasas par\u00e1metros objetoMasaylo.buzzer() , pone los valores objetoMasaylo.buzzer(1) , por tanto habr\u00eda que conectarlo al pin digital 1. Esta orden como es de configuraci\u00f3n debe estar en el setup de nuestro programa. En el ejemplo m.buzzer(1) . objetoMasaylo.tono (frecuencia Hz, duraci\u00f3n ms) : emite un sonido en el zumbador configurado anteriormente, de una cierta frecuencia en Hz y duraci\u00f3n en ms. En el ejemplo hay varias apliacciones como m.tono (re,duracion) , siendo re y duraci\u00f3n constantes con valores enteros. En el siguiente ejemplo (ejemplo 10 de la librer\u00eda), se implementa una escala musical, creando constantes con las frecuencias de las notas de la escala, y constantes con la duraci\u00f3n en ms de la nota y el retardo entre nota y nota. #include <Masaylo.h> Masaylo m; const int do2 = 261; const int re = 293; const int mi = 329; const int fa = 349; const int sol = 392; const int la = 440; const int si = 493; const int duracion = 500; const int retardo = 100; //no hay definiciones void setup() { m.init(); m.buzzer(1); } void loop() { m.tono(do2,duracion); delay(retardo); m.tono(re,duracion); delay(retardo); m.tono(mi,duracion); delay(retardo); m.tono(fa,duracion); delay(retardo); m.tono(sol,duracion); delay(retardo); m.tono(la,duracion); delay(retardo); m.tono(si,duracion); delay(retardo); }","title":"Sonidos y Masaylo (Zumbador)"},{"location":"masayloBlockly/PWM/","text":"Control de velocidad. Uso de PWM \u00b6 \u00bfEn qu\u00e9 consiste la t\u00e9cnica del PWM? \u00b6 Si bien los microcontroladores en que se basan nuestras Arduino pueden leer entradas anal\u00f3gicas (se\u00f1ales que pueden tomar infinitos valores de modo variable entre un valor m\u00ednimo y uno m\u00e1ximo, normalmente 0 V y 5 V) en algunos de sus pines, no es menos cierto que no pueden escribir de este modo en ninguna salida. Ello dificulta en un principio el control de velocidad de robots como Masaylo, que utiliza motores DC cuya velocidad es proporcional al voltaje que se les aplica. Tal como se explica en el an\u00e1lisis de elementos de la versi\u00f3n UNO , la velocidad de dichos motores puede oscilar entre las 125 rpm y las 230 rpm (sin carga) seg\u00fan la tensi\u00f3n var\u00ede entre 3 y 6 V. Un enfoque del control de movimientos usando salidas digitales s\u00f3lo permitir\u00eda soluciones del tipo todo-nada: Pin de control 1 Pin de control 2 Movimiento del motor 0 0 Paro 0 1 Sentido de las agujas del reloj M\u00c1XIMA VELOCIDAD 1 1 Sentido contrario al de las agujas del reloj M\u00c1XIMA VELOCIDAD 1 1 Paro La t\u00e9cnica PWM (Pulse Width Modulation, modulaci\u00f3n por anchura de pulso) consiste en EMULAR un valor determinado de tensi\u00f3n en un pin alternando los valores m\u00ednimo y m\u00e1ximo (0 V/5 V, normalmente) en el tiempo de modo que el equilibrio entre ambos de como resultado final la tensi\u00f3n buscada. Emulaci\u00f3n de salidas anal\u00f3gicas por PWM. Imagen de Wikimedia Commons, obra de Thewrightstuff Esta t\u00e9cnica se puede utilizar en algunos pines (no en todos) de nuestras tarjetas microcontroladoras, utilizando el comando analogWrite(pin,valor) en el IDE de Arduino en lenguaje C++, siendo pin la patilla conectada a nuestro motor y valor un n\u00famero entre 0 (0 V) y 255 (5 V) Control de velocidad en MasayloBlockly \u00b6 Afortunadamente para el estudiante primerizo, con MasayloBlockly no necesitaremos conocimiento alguno de PWM para modificar la velocidad de los motores de nuestro Masaylo. En el bloque de opciones correspondiente, disponemos de una \u00fanica pieza en la que podemos elegir el movimiento (adelante, atr\u00e1s, izquierda, derecha) y su velocidad en %: Pieza de control de velocidad de movimiento en MasayloBlockly Simplemente haciendo click en la entrada de la pieza referida a la velocidad, podremos modificarla sin problemas a un valor entre 0 % y 100 % Ello hace infinitamente m\u00e1s f\u00e1cil programar la secuencia de movimientos de nuestro robot a velocidad controlada en nuestras primeras aproximaciones a la rob\u00f3tica educativa (si bien, obviamente, recomendamos al estudiante avanzado que se familiarice con el control PWM en el IDE de Arduino a trav\u00e9s de analogWrite() ); Objetivos de la pr\u00e1ctica \u00b6 Imitando al programa anterior, buscamos ahora la siguiente secuencia de movimientos: Adelante a 100 % durante 3 segundos. Giro a izquierda a 60 % durante 0.5 segundos. Adelante de nuevo a 100 % durante 3 segundos. Giro a derecha a 60 % durante 0.5 segundos. Movimiento hacia atr\u00e1s a 100 % durante 3 segundos. Giro a izquierda a 60 % durante 1 segundo. Fin de la secuencia. Programa: movimientos a velocidad variable \u00b6 Procedemos de nuevo a crear un programa que cumpla con los objetivos marcados por la pr\u00e1ctica, utilizando siempre la misma pieza y eligiendo en cada momento el sentido del movimiento y su potencia, tal y como indica la pr\u00f3xima ilustracion. ( Nota: este programa est\u00e1 disponible en el bot\u00f3n de Ejemplos del men\u00fa principal, con el el t\u00edtulo \"Utiliza PWM para controlar la velocidad de movimientos del Masaylo\"). Programa: secuencia de movimientos a velocidad variable","title":"Control de velocidad. Uso de PWM"},{"location":"masayloBlockly/PWM/#control-de-velocidad-uso-de-pwm","text":"","title":"Control de velocidad. Uso de PWM"},{"location":"masayloBlockly/PWM/#en-que-consiste-la-tecnica-del-pwm","text":"Si bien los microcontroladores en que se basan nuestras Arduino pueden leer entradas anal\u00f3gicas (se\u00f1ales que pueden tomar infinitos valores de modo variable entre un valor m\u00ednimo y uno m\u00e1ximo, normalmente 0 V y 5 V) en algunos de sus pines, no es menos cierto que no pueden escribir de este modo en ninguna salida. Ello dificulta en un principio el control de velocidad de robots como Masaylo, que utiliza motores DC cuya velocidad es proporcional al voltaje que se les aplica. Tal como se explica en el an\u00e1lisis de elementos de la versi\u00f3n UNO , la velocidad de dichos motores puede oscilar entre las 125 rpm y las 230 rpm (sin carga) seg\u00fan la tensi\u00f3n var\u00ede entre 3 y 6 V. Un enfoque del control de movimientos usando salidas digitales s\u00f3lo permitir\u00eda soluciones del tipo todo-nada: Pin de control 1 Pin de control 2 Movimiento del motor 0 0 Paro 0 1 Sentido de las agujas del reloj M\u00c1XIMA VELOCIDAD 1 1 Sentido contrario al de las agujas del reloj M\u00c1XIMA VELOCIDAD 1 1 Paro La t\u00e9cnica PWM (Pulse Width Modulation, modulaci\u00f3n por anchura de pulso) consiste en EMULAR un valor determinado de tensi\u00f3n en un pin alternando los valores m\u00ednimo y m\u00e1ximo (0 V/5 V, normalmente) en el tiempo de modo que el equilibrio entre ambos de como resultado final la tensi\u00f3n buscada. Emulaci\u00f3n de salidas anal\u00f3gicas por PWM. Imagen de Wikimedia Commons, obra de Thewrightstuff Esta t\u00e9cnica se puede utilizar en algunos pines (no en todos) de nuestras tarjetas microcontroladoras, utilizando el comando analogWrite(pin,valor) en el IDE de Arduino en lenguaje C++, siendo pin la patilla conectada a nuestro motor y valor un n\u00famero entre 0 (0 V) y 255 (5 V)","title":"\u00bfEn qu\u00e9 consiste la t\u00e9cnica del PWM?"},{"location":"masayloBlockly/PWM/#control-de-velocidad-en-masayloblockly","text":"Afortunadamente para el estudiante primerizo, con MasayloBlockly no necesitaremos conocimiento alguno de PWM para modificar la velocidad de los motores de nuestro Masaylo. En el bloque de opciones correspondiente, disponemos de una \u00fanica pieza en la que podemos elegir el movimiento (adelante, atr\u00e1s, izquierda, derecha) y su velocidad en %: Pieza de control de velocidad de movimiento en MasayloBlockly Simplemente haciendo click en la entrada de la pieza referida a la velocidad, podremos modificarla sin problemas a un valor entre 0 % y 100 % Ello hace infinitamente m\u00e1s f\u00e1cil programar la secuencia de movimientos de nuestro robot a velocidad controlada en nuestras primeras aproximaciones a la rob\u00f3tica educativa (si bien, obviamente, recomendamos al estudiante avanzado que se familiarice con el control PWM en el IDE de Arduino a trav\u00e9s de analogWrite() );","title":"Control de velocidad en MasayloBlockly"},{"location":"masayloBlockly/PWM/#objetivos-de-la-practica","text":"Imitando al programa anterior, buscamos ahora la siguiente secuencia de movimientos: Adelante a 100 % durante 3 segundos. Giro a izquierda a 60 % durante 0.5 segundos. Adelante de nuevo a 100 % durante 3 segundos. Giro a derecha a 60 % durante 0.5 segundos. Movimiento hacia atr\u00e1s a 100 % durante 3 segundos. Giro a izquierda a 60 % durante 1 segundo. Fin de la secuencia.","title":"Objetivos de la pr\u00e1ctica"},{"location":"masayloBlockly/PWM/#programa-movimientos-a-velocidad-variable","text":"Procedemos de nuevo a crear un programa que cumpla con los objetivos marcados por la pr\u00e1ctica, utilizando siempre la misma pieza y eligiendo en cada momento el sentido del movimiento y su potencia, tal y como indica la pr\u00f3xima ilustracion. ( Nota: este programa est\u00e1 disponible en el bot\u00f3n de Ejemplos del men\u00fa principal, con el el t\u00edtulo \"Utiliza PWM para controlar la velocidad de movimientos del Masaylo\"). Programa: secuencia de movimientos a velocidad variable","title":"Programa: movimientos a velocidad variable"},{"location":"masayloBlockly/descarga/","text":"Instalaci\u00f3n de MasayloBlockly \u00b6 A lo largo de las pr\u00f3ximas secciones presentaremos una peque\u00f1a introducci\u00f3n a MasayloBlockly , un software de programaci\u00f3n de sistemas de control basados en Arduino, ESP8266 y ESP32. Si bien no es una herramienta imprescindible para programar el robot Masaylo, s\u00ed que puede suponer una ayuda para el lego que desea introducirse a este mundillo de la Rob\u00f3tica Educativa y que no est\u00e1 familiarizado con el IDE de Arduino que se utiliza normalmente en estos menesteres. A grandes rasgos, la utilidad de MasayloBlockly es ofrecer al usuario un entorno gr\u00e1fico en el que puede arrastrar distintas \"piezas\" de puzzle, cada una de las cuales supone un comando, funci\u00f3n, lectura de par\u00e1metro, etc... en el lenguaje C++ que utiliza el IDE de Arduino para programar sus tarjetas. Esta filosof\u00eda de trabajo permite crear programas sencillos (o complejos) y volcarlos en robots o sistemas de control basados en estos tipos de microcontrolador. Como se ver\u00e1 en los pr\u00f3ximos apartados, se trata de un proceso muy intuitivo y amigable, pero extremadamente potente. Zonas de trabajo de MasayloBlockly Origen de MasayloBlockly \u00b6 MasayloBlockly ha sido dise\u00f1ado por Antonio G\u00f3mez y Mar\u00eda Dolores Nogueras Atance , ambos profesores de Tecnolog\u00eda en Educaci\u00f3n Secundaria, con el objetivo de facilitar al m\u00e1ximo el trabajo con robots educativos como Masaylo, OttoDIY , OttoDIY versi\u00f3n Humanoide y Escornabot , entre otros. Seg\u00fan la experiencia en taller de ambos profesores a lo largo de los a\u00f1os, la programaci\u00f3n directa de este tipo de sistemas (l\u00e9ase lenguaje C++ en el caso del IDE de Arduino), se hace muy dif\u00edcil y confusa para alumnos de cursos inferiores a 4\u00ba de ESO. Esta herramienta pretende posibilitar la programaci\u00f3n directa de sistemas de control que trabajen con sensores y actuadores simples a los alumnos m\u00e1s j\u00f3venes de nuestro sistema educativo, separando este \u00e1mbito de trabajo del aprendizaje directo de lenguajes de programaci\u00f3n complejos como C++, que implica un pensamiento abstracto y una madurez intelectual asociada a niveles superiores. Apilando piezas de puzzle al m\u00e1s puro estilo Scratch, el alumnado (o el simple aficionado) puede construir algoritmos sencillos explicando al ordenador c\u00f3mo pretende que trabaje el sistema de control que est\u00e1 programando (rob\u00f3tico o no) sin un conocimiento directo del lenguaje implicado. Este software es una adaptaci\u00f3n de Blocklino , obra de Jean Philippe Fontaine , que a su vez es una adaptaci\u00f3n/integraci\u00f3n/mejora de trabajos como BlocklyDuino o ArduBlockly . Esta es la magia del software libre. La colaboraci\u00f3n y la libre difusi\u00f3n del conocimiento es lo que est\u00e1 impulsando con tanta intensidad el conocimiento y el enriquecimiento del mundo acad\u00e9mico estos \u00faltimos a\u00f1os. El motor gr\u00e1fico de la aplicaci\u00f3n est\u00e1 basado en la librer\u00eda en JavaScript Google Blockly , que permite insertar un editor visual de c\u00f3digo en webs y apps m\u00f3viles. Descarga e instalaci\u00f3n del software \u00b6 MasayloBlockly, como sus antecesores, es software libre con licencia Creative Commons Zero v1.0 Universal . En su repositorio est\u00e1 disponible por completo el c\u00f3digo fuente que integra este entorno de programaci\u00f3n. En su apartado releases est\u00e1n disponibles para descargar todas las versiones que sus creadores han ido liberando a lo largo del ciclo de vida de este software. Aqu\u00ed est\u00e1n disponibles para descarga las distintas versiones para Windows y Linux de MasayloBlockly \u00b6 Normalmente, cada versi\u00f3n de MasayloBlockly est\u00e1 disponible para Windows 10 (64 bits), Ubuntu (64 bits), as\u00ed como una versi\u00f3n de 32 bits para versiones anteriores de Windows, que trata de dar respuesta a la limitaci\u00f3n de medios inform\u00e1ticos en algunos centros educativos. En cada caso, se ofrece una versi\u00f3n portable (formato appImage en Linux, archivo *.exe en Windows), un instalador para Windows y la carpeta comprimida para Linux. Hay distintas versiones de MasayloBlockly para diversos sistemas operativos En Linux hay que proporcionar permisos de ejecuci\u00f3n al archivo appImage descargado, si optamos por esta posibilidad. Si preferimos descargarnos la carpeta completa, hay que ejecutar el archivo masaylo , preferiblemente por consola: usuario@equipo:~/Descargas/masayloBlockly$/.masaylo Si todo va bien, la aplicaci\u00f3n arrancar\u00e1, mostr\u00e1ndonos una pantalla parecida a \u00e9sta: Apariencia de la aplicaci\u00f3n en el primer arranque Queda a\u00fan pendiente la instalaci\u00f3n de librer\u00edas que MasayloBlockly necesita para poder volcar el c\u00f3digo en C++. No obstante, es aconsejable primero hacer un peque\u00f1o recorrido sobre sus caracter\u00edsticas para que el usuario adquiera cierta seguridad en su utilizaci\u00f3n. Demos, pues, nuestros primeros pasos por este entorno. V\u00eddeo explicativo: descarga e instalaci\u00f3n de MasayloBlockly \u00b6","title":"Descarga e instalaci\u00f3n"},{"location":"masayloBlockly/descarga/#instalacion-de-masayloblockly","text":"A lo largo de las pr\u00f3ximas secciones presentaremos una peque\u00f1a introducci\u00f3n a MasayloBlockly , un software de programaci\u00f3n de sistemas de control basados en Arduino, ESP8266 y ESP32. Si bien no es una herramienta imprescindible para programar el robot Masaylo, s\u00ed que puede suponer una ayuda para el lego que desea introducirse a este mundillo de la Rob\u00f3tica Educativa y que no est\u00e1 familiarizado con el IDE de Arduino que se utiliza normalmente en estos menesteres. A grandes rasgos, la utilidad de MasayloBlockly es ofrecer al usuario un entorno gr\u00e1fico en el que puede arrastrar distintas \"piezas\" de puzzle, cada una de las cuales supone un comando, funci\u00f3n, lectura de par\u00e1metro, etc... en el lenguaje C++ que utiliza el IDE de Arduino para programar sus tarjetas. Esta filosof\u00eda de trabajo permite crear programas sencillos (o complejos) y volcarlos en robots o sistemas de control basados en estos tipos de microcontrolador. Como se ver\u00e1 en los pr\u00f3ximos apartados, se trata de un proceso muy intuitivo y amigable, pero extremadamente potente. Zonas de trabajo de MasayloBlockly","title":"Instalaci\u00f3n de MasayloBlockly"},{"location":"masayloBlockly/descarga/#origen-de-masayloblockly","text":"MasayloBlockly ha sido dise\u00f1ado por Antonio G\u00f3mez y Mar\u00eda Dolores Nogueras Atance , ambos profesores de Tecnolog\u00eda en Educaci\u00f3n Secundaria, con el objetivo de facilitar al m\u00e1ximo el trabajo con robots educativos como Masaylo, OttoDIY , OttoDIY versi\u00f3n Humanoide y Escornabot , entre otros. Seg\u00fan la experiencia en taller de ambos profesores a lo largo de los a\u00f1os, la programaci\u00f3n directa de este tipo de sistemas (l\u00e9ase lenguaje C++ en el caso del IDE de Arduino), se hace muy dif\u00edcil y confusa para alumnos de cursos inferiores a 4\u00ba de ESO. Esta herramienta pretende posibilitar la programaci\u00f3n directa de sistemas de control que trabajen con sensores y actuadores simples a los alumnos m\u00e1s j\u00f3venes de nuestro sistema educativo, separando este \u00e1mbito de trabajo del aprendizaje directo de lenguajes de programaci\u00f3n complejos como C++, que implica un pensamiento abstracto y una madurez intelectual asociada a niveles superiores. Apilando piezas de puzzle al m\u00e1s puro estilo Scratch, el alumnado (o el simple aficionado) puede construir algoritmos sencillos explicando al ordenador c\u00f3mo pretende que trabaje el sistema de control que est\u00e1 programando (rob\u00f3tico o no) sin un conocimiento directo del lenguaje implicado. Este software es una adaptaci\u00f3n de Blocklino , obra de Jean Philippe Fontaine , que a su vez es una adaptaci\u00f3n/integraci\u00f3n/mejora de trabajos como BlocklyDuino o ArduBlockly . Esta es la magia del software libre. La colaboraci\u00f3n y la libre difusi\u00f3n del conocimiento es lo que est\u00e1 impulsando con tanta intensidad el conocimiento y el enriquecimiento del mundo acad\u00e9mico estos \u00faltimos a\u00f1os. El motor gr\u00e1fico de la aplicaci\u00f3n est\u00e1 basado en la librer\u00eda en JavaScript Google Blockly , que permite insertar un editor visual de c\u00f3digo en webs y apps m\u00f3viles.","title":"Origen de MasayloBlockly"},{"location":"masayloBlockly/descarga/#descarga-e-instalacion-del-software","text":"MasayloBlockly, como sus antecesores, es software libre con licencia Creative Commons Zero v1.0 Universal . En su repositorio est\u00e1 disponible por completo el c\u00f3digo fuente que integra este entorno de programaci\u00f3n. En su apartado releases est\u00e1n disponibles para descargar todas las versiones que sus creadores han ido liberando a lo largo del ciclo de vida de este software.","title":"Descarga e instalaci\u00f3n del software"},{"location":"masayloBlockly/descarga/#aqui-estan-disponibles-para-descarga-las-distintas-versiones-para-windows-y-linux-de-masayloblockly","text":"Normalmente, cada versi\u00f3n de MasayloBlockly est\u00e1 disponible para Windows 10 (64 bits), Ubuntu (64 bits), as\u00ed como una versi\u00f3n de 32 bits para versiones anteriores de Windows, que trata de dar respuesta a la limitaci\u00f3n de medios inform\u00e1ticos en algunos centros educativos. En cada caso, se ofrece una versi\u00f3n portable (formato appImage en Linux, archivo *.exe en Windows), un instalador para Windows y la carpeta comprimida para Linux. Hay distintas versiones de MasayloBlockly para diversos sistemas operativos En Linux hay que proporcionar permisos de ejecuci\u00f3n al archivo appImage descargado, si optamos por esta posibilidad. Si preferimos descargarnos la carpeta completa, hay que ejecutar el archivo masaylo , preferiblemente por consola: usuario@equipo:~/Descargas/masayloBlockly$/.masaylo Si todo va bien, la aplicaci\u00f3n arrancar\u00e1, mostr\u00e1ndonos una pantalla parecida a \u00e9sta: Apariencia de la aplicaci\u00f3n en el primer arranque Queda a\u00fan pendiente la instalaci\u00f3n de librer\u00edas que MasayloBlockly necesita para poder volcar el c\u00f3digo en C++. No obstante, es aconsejable primero hacer un peque\u00f1o recorrido sobre sus caracter\u00edsticas para que el usuario adquiera cierta seguridad en su utilizaci\u00f3n. Demos, pues, nuestros primeros pasos por este entorno.","title":"Aqu\u00ed est\u00e1n disponibles para descarga las distintas versiones para Windows y Linux de MasayloBlockly"},{"location":"masayloBlockly/descarga/#video-explicativo-descarga-e-instalacion-de-masayloblockly","text":"","title":"V\u00eddeo explicativo: descarga e instalaci\u00f3n de MasayloBlockly"},{"location":"masayloBlockly/distanciaPuertoSerie/","text":"Detecci\u00f3n de obst\u00e1culos. Uso del puerto serie \u00b6 En esta pr\u00e1ctica aprenderemos a inicializar el sensor de ultrasonidos HC-SR04 del robot Masaylo y utilizarlo para detectar obst\u00e1culos, calcular la distancia a la que se encuentran y enviar dicho dato a nuestro ordenador para que podamos leerlo de manera directa a trav\u00e9s del monitor del puerto serie \u00bfQu\u00e9 es el monitor del puerto serie? \u00b6 El puerto serie es el canal de comunicaci\u00f3n que utiliza Arduino para comunicarse con nuestro ordenador a trav\u00e9s de nuestro cable USB, para cargar los programas compilados a trav\u00e9s del IDE o enviar y recibir informaci\u00f3n. Los pines digitales 0 (Rx) y 1 (Tx) del microcontrolador son los encargados de realizar dicha comunicaci\u00f3n, raz\u00f3n por la que se aconseja dejar ambas patillas sin conectar en nuestro sistema de control si vamos a necesitar comunicaci\u00f3n o en el momento de cargar un nuevo programa. El IDE de Arduino nos facilita dicha comunicaci\u00f3n utilizando los comandos Serial.begin(velocidad) (la velocidad est\u00e1ndar suele ser de 9600 baudios), y los comandos Serial.print(texto) para escribir, Serial.println(texto) para escribir con retorno de carro, o Serial.read(dato) para recibir informaci\u00f3n. Para abrir este canal de comunicaci\u00f3n, dicha IDE nos ofrece un icono muy caracter\u00edstico. Icono de apertura del puerto serie en el IDE de Arduino Al hacer click en dicho icono, se abre una nueva ventana en la que Arduino imprimir\u00e1 la correspondiente informaci\u00f3n a medida que transcurra el programa. Ventana del puerto serie en el IDE Como siempre, MasayloBlockly nos facilitar\u00e1 esta tarea. Dentro del conjunto de bloques de programaci\u00f3n asignados a \"modo experto\" (alcanzable, como el lector recordar\u00e1, a trav\u00e9s del icono de preferencias ),podemos incluir en la zona de opciones el grupo \"Puerto Serie\", del que utilizaremos, en esta actividad de iniciaci\u00f3n, las siguientes piezas: Icono Funci\u00f3n Inicializar el puerto serie a la velocidad en baudios indicada (9600 por defecto, configurable) Arduino escribir\u00e1 en el puerto serie el texto o dato que le indiquemos (incluye un texto editable por defecto, pero lo sustituiremos por la lectura del sensor) NOTA: LA PIEZA DE INICIALIZACI\u00d3N DEL PUERTO SERIE NO EST\u00c1 PREPARADA PARA ENCAJAR CON LAS OTRAS, PUESTO QUE HACE REFERENCIA A UNA TAREA DE CONFIGURACI\u00d3N PREVIA AL HILO GENERAL QUE DESARROLLAR\u00c1 EL PROGRAMA. NO HAY PROBLEMA EN DEJARLA EN EL ESPACIO DE TRABAJO DE MODO INDEPENDIENTE DE LAS DEM\u00c1S OTRA NOTA: POR MOTIVOS DE CONFIGURACI\u00d3N, EL MONITOR DEL PUERTO SERIE DE MASAYLOBLOCKLY S\u00d3LO DEVUELVE LECTURAS DESPU\u00c9S DE LEER UN RETORNO DE CARRO. ESO SIGNIFICA QUE SI UTILIZAMOS LA PIEZA ENVIAR A PUERTO SERIE SIN COMPLETAR CON ESCRIBIR L\u00cdNEA , NO APARECER\u00c1 INFORMACI\u00d3N ALGUNA EN LA VENTANA DE DICHO MONITOR Como actividad de ampliaci\u00f3n, sugerimos al lector que utilice el bloque de opciones \"Textos\" disponible en el men\u00fa de preferencias para combinar textos con el resultado medido, tal y como podr\u00e1 ver en la soluci\u00f3n final que ofrecemos. Uso del sensor de ultrasonidos como detector de obst\u00e1culos \u00b6 En la secci\u00f3n de an\u00e1lisis de elementos de la versi\u00f3n UNO se explica sobradamente las caracter\u00edsticas y el conexionado del sensor de ultrasonidos. En MasayloBlockly es muy f\u00e1cil inicializar el sensor de ultrasonidos indicando los pines a que hemos conectado ECHO y TRIGGER , y obtener lecturas peri\u00f3dicas de la distancia a cualquier obst\u00e1culo que se pueda encontrar en el rango de alcance de dicho sensor. El sensor de ultrasonidos puede detectar obst\u00e1culos y medir su distancia Las piezas que utilizaremos para tal fin ser\u00e1n: Icono Funci\u00f3n Inicializar el sensor de ultrasonidos indicando los pines TRIGGER y ECHO (por defecto, A2 y A3, pero la pieza es editable) Esta pieza devuelve la lectura en cm indicada por el sensor en su \u00faltima lectura Objetivos de la pr\u00e1ctica \u00b6 Como ya hemos explicado, queremos mostrar el uso del puerto serie al usuario no avezado de un modo sencillo, utiliz\u00e1ndolo como canal de comunicaci\u00f3n para obtener las distancias obtenidas por el sensor de distancia en lecturas peri\u00f3dicas. Podemos, pues, establecer los siguientes objetivos: Inicializar el puerto serie del robot Masaylo estableciendo una velocidad est\u00e1ndar (9600 baudios). Inicializar el robot Masaylo indicando, en su caso, los pines de control de motores. Inicializar el sensor de ultrasonidos indicando los pines de conexi\u00f3n a TRIGGER y ECHO , en caso de ser distintos a los establecidos por defecto. Realizar una lectura de distancia y pasarla al puerto serie para su lectura por parte del usuario. Esperar un segundo. Repetir el bucle. Pr\u00e1ctica: lectura de distancias a trav\u00e9s del puerto serie Programa: lectura de distancias medidas por el sensor US a trav\u00e9s del puerto serie \u00b6 La siguiente imagen desarrolla el programa utilizado ( Nota: este programa est\u00e1 disponible en el bot\u00f3n de Ejemplos del men\u00fa principal, con el t\u00edtulo \"Env\u00eda la distancia al obst\u00e1culo detectado al puerto serie de tu ordenador\"). Programa: env\u00edo de los datos de distancia al puerto serie Resultado: lectura de distancias a trav\u00e9s del puerto serie \u00b6 Para abrir el monitor del puerto serie, s\u00f3lo hay que hacer doble click en el icono para abrir la ventana del monitor y hacer click en el bot\u00f3n ***Arrancar** (debe asegurarse de que la velocidad estipulada es 9600) para iniciar la comunicaci\u00f3n con el sistema de control del Masaylo: Lectura de los datos de distancia usando el monitor de MasayloBlockly Ejercicio de ampliaci\u00f3n: programar un sistema de desplazamiento que evite obst\u00e1culos \u00b6 Con lo mostrado hasta aqu\u00ed, el lector deber\u00eda ya estar suficientemente capacitado para programar a Masaylo de modo que \u00e9ste se mueva de forma aut\u00f3noma evitando los obst\u00e1culos que se presenten. En el bot\u00f3n de Ejemplos del men\u00fa principal hay precisamente un algoritmo que cumple este objetivo, llamado \"Aprende a detectar obst\u00e1culos con el sensor US y a esquivarlos mediante movimientos aleatorios\". Ejercicio de ampliaci\u00f3n: movimiento aut\u00f3nomo con detecci\u00f3n y evasi\u00f3n de obst\u00e1culos V\u00eddeo explicativo: uso del puerto serie para leer distancias a obst\u00e1culos detectados \u00b6","title":"Detecci\u00f3n de obst\u00e1culos. Uso del puerto serie"},{"location":"masayloBlockly/distanciaPuertoSerie/#deteccion-de-obstaculos-uso-del-puerto-serie","text":"En esta pr\u00e1ctica aprenderemos a inicializar el sensor de ultrasonidos HC-SR04 del robot Masaylo y utilizarlo para detectar obst\u00e1culos, calcular la distancia a la que se encuentran y enviar dicho dato a nuestro ordenador para que podamos leerlo de manera directa a trav\u00e9s del monitor del puerto serie","title":"Detecci\u00f3n de obst\u00e1culos. Uso del puerto serie"},{"location":"masayloBlockly/distanciaPuertoSerie/#que-es-el-monitor-del-puerto-serie","text":"El puerto serie es el canal de comunicaci\u00f3n que utiliza Arduino para comunicarse con nuestro ordenador a trav\u00e9s de nuestro cable USB, para cargar los programas compilados a trav\u00e9s del IDE o enviar y recibir informaci\u00f3n. Los pines digitales 0 (Rx) y 1 (Tx) del microcontrolador son los encargados de realizar dicha comunicaci\u00f3n, raz\u00f3n por la que se aconseja dejar ambas patillas sin conectar en nuestro sistema de control si vamos a necesitar comunicaci\u00f3n o en el momento de cargar un nuevo programa. El IDE de Arduino nos facilita dicha comunicaci\u00f3n utilizando los comandos Serial.begin(velocidad) (la velocidad est\u00e1ndar suele ser de 9600 baudios), y los comandos Serial.print(texto) para escribir, Serial.println(texto) para escribir con retorno de carro, o Serial.read(dato) para recibir informaci\u00f3n. Para abrir este canal de comunicaci\u00f3n, dicha IDE nos ofrece un icono muy caracter\u00edstico. Icono de apertura del puerto serie en el IDE de Arduino Al hacer click en dicho icono, se abre una nueva ventana en la que Arduino imprimir\u00e1 la correspondiente informaci\u00f3n a medida que transcurra el programa. Ventana del puerto serie en el IDE Como siempre, MasayloBlockly nos facilitar\u00e1 esta tarea. Dentro del conjunto de bloques de programaci\u00f3n asignados a \"modo experto\" (alcanzable, como el lector recordar\u00e1, a trav\u00e9s del icono de preferencias ),podemos incluir en la zona de opciones el grupo \"Puerto Serie\", del que utilizaremos, en esta actividad de iniciaci\u00f3n, las siguientes piezas: Icono Funci\u00f3n Inicializar el puerto serie a la velocidad en baudios indicada (9600 por defecto, configurable) Arduino escribir\u00e1 en el puerto serie el texto o dato que le indiquemos (incluye un texto editable por defecto, pero lo sustituiremos por la lectura del sensor) NOTA: LA PIEZA DE INICIALIZACI\u00d3N DEL PUERTO SERIE NO EST\u00c1 PREPARADA PARA ENCAJAR CON LAS OTRAS, PUESTO QUE HACE REFERENCIA A UNA TAREA DE CONFIGURACI\u00d3N PREVIA AL HILO GENERAL QUE DESARROLLAR\u00c1 EL PROGRAMA. NO HAY PROBLEMA EN DEJARLA EN EL ESPACIO DE TRABAJO DE MODO INDEPENDIENTE DE LAS DEM\u00c1S OTRA NOTA: POR MOTIVOS DE CONFIGURACI\u00d3N, EL MONITOR DEL PUERTO SERIE DE MASAYLOBLOCKLY S\u00d3LO DEVUELVE LECTURAS DESPU\u00c9S DE LEER UN RETORNO DE CARRO. ESO SIGNIFICA QUE SI UTILIZAMOS LA PIEZA ENVIAR A PUERTO SERIE SIN COMPLETAR CON ESCRIBIR L\u00cdNEA , NO APARECER\u00c1 INFORMACI\u00d3N ALGUNA EN LA VENTANA DE DICHO MONITOR Como actividad de ampliaci\u00f3n, sugerimos al lector que utilice el bloque de opciones \"Textos\" disponible en el men\u00fa de preferencias para combinar textos con el resultado medido, tal y como podr\u00e1 ver en la soluci\u00f3n final que ofrecemos.","title":"\u00bfQu\u00e9 es el monitor del puerto serie?"},{"location":"masayloBlockly/distanciaPuertoSerie/#uso-del-sensor-de-ultrasonidos-como-detector-de-obstaculos","text":"En la secci\u00f3n de an\u00e1lisis de elementos de la versi\u00f3n UNO se explica sobradamente las caracter\u00edsticas y el conexionado del sensor de ultrasonidos. En MasayloBlockly es muy f\u00e1cil inicializar el sensor de ultrasonidos indicando los pines a que hemos conectado ECHO y TRIGGER , y obtener lecturas peri\u00f3dicas de la distancia a cualquier obst\u00e1culo que se pueda encontrar en el rango de alcance de dicho sensor. El sensor de ultrasonidos puede detectar obst\u00e1culos y medir su distancia Las piezas que utilizaremos para tal fin ser\u00e1n: Icono Funci\u00f3n Inicializar el sensor de ultrasonidos indicando los pines TRIGGER y ECHO (por defecto, A2 y A3, pero la pieza es editable) Esta pieza devuelve la lectura en cm indicada por el sensor en su \u00faltima lectura","title":"Uso del sensor de ultrasonidos como detector de obst\u00e1culos"},{"location":"masayloBlockly/distanciaPuertoSerie/#objetivos-de-la-practica","text":"Como ya hemos explicado, queremos mostrar el uso del puerto serie al usuario no avezado de un modo sencillo, utiliz\u00e1ndolo como canal de comunicaci\u00f3n para obtener las distancias obtenidas por el sensor de distancia en lecturas peri\u00f3dicas. Podemos, pues, establecer los siguientes objetivos: Inicializar el puerto serie del robot Masaylo estableciendo una velocidad est\u00e1ndar (9600 baudios). Inicializar el robot Masaylo indicando, en su caso, los pines de control de motores. Inicializar el sensor de ultrasonidos indicando los pines de conexi\u00f3n a TRIGGER y ECHO , en caso de ser distintos a los establecidos por defecto. Realizar una lectura de distancia y pasarla al puerto serie para su lectura por parte del usuario. Esperar un segundo. Repetir el bucle. Pr\u00e1ctica: lectura de distancias a trav\u00e9s del puerto serie","title":"Objetivos de la pr\u00e1ctica"},{"location":"masayloBlockly/distanciaPuertoSerie/#programa-lectura-de-distancias-medidas-por-el-sensor-us-a-traves-del-puerto-serie","text":"La siguiente imagen desarrolla el programa utilizado ( Nota: este programa est\u00e1 disponible en el bot\u00f3n de Ejemplos del men\u00fa principal, con el t\u00edtulo \"Env\u00eda la distancia al obst\u00e1culo detectado al puerto serie de tu ordenador\"). Programa: env\u00edo de los datos de distancia al puerto serie","title":"Programa: lectura de distancias medidas por el sensor US a trav\u00e9s del puerto serie"},{"location":"masayloBlockly/distanciaPuertoSerie/#resultado-lectura-de-distancias-a-traves-del-puerto-serie","text":"Para abrir el monitor del puerto serie, s\u00f3lo hay que hacer doble click en el icono para abrir la ventana del monitor y hacer click en el bot\u00f3n ***Arrancar** (debe asegurarse de que la velocidad estipulada es 9600) para iniciar la comunicaci\u00f3n con el sistema de control del Masaylo: Lectura de los datos de distancia usando el monitor de MasayloBlockly","title":"Resultado: lectura de distancias a trav\u00e9s del puerto serie"},{"location":"masayloBlockly/distanciaPuertoSerie/#ejercicio-de-ampliacion-programar-un-sistema-de-desplazamiento-que-evite-obstaculos","text":"Con lo mostrado hasta aqu\u00ed, el lector deber\u00eda ya estar suficientemente capacitado para programar a Masaylo de modo que \u00e9ste se mueva de forma aut\u00f3noma evitando los obst\u00e1culos que se presenten. En el bot\u00f3n de Ejemplos del men\u00fa principal hay precisamente un algoritmo que cumple este objetivo, llamado \"Aprende a detectar obst\u00e1culos con el sensor US y a esquivarlos mediante movimientos aleatorios\". Ejercicio de ampliaci\u00f3n: movimiento aut\u00f3nomo con detecci\u00f3n y evasi\u00f3n de obst\u00e1culos","title":"Ejercicio de ampliaci\u00f3n: programar un sistema de desplazamiento que evite obst\u00e1culos"},{"location":"masayloBlockly/distanciaPuertoSerie/#video-explicativo-uso-del-puerto-serie-para-leer-distancias-a-obstaculos-detectados","text":"","title":"V\u00eddeo explicativo: uso del puerto serie para leer distancias a obst\u00e1culos detectados"},{"location":"masayloBlockly/encoder/","text":"Trabajo con encoder. Control b\u00e1sico de distancias y \u00e1ngulos \u00b6 Masaylo nos ofrece tambi\u00e9n la posibilidad de instalar dos encoder modelo FC-03 , que permiten un cierto control sobre el \u00e1ngulo de giro de los motores DC de desplazamiento. Estos sensores, de por s\u00ed, son de dif\u00edcil manejo para los aficionados maker con una cierta experiencia en la implementaci\u00f3n de sistemas con Arduino. Adem\u00e1s, precisan del manejo de interrupciones por parte del microprocesador, concepto \u00e9ste reservado para estudiantes m\u00e1s avanzados. No obstante, la librer\u00eda de Masaylo resuelve con cierta elegancia todos estos inconvenientes, permitiendo un control, si no perfecto, s\u00ed bastante adecuado de distancias recorridas y \u00e1ngulos de desplazamiento. Nota: al contrario que en el resto de sensores, los pines de conexi\u00f3n de los encoder no son opcionales. Deben ser forzosamente 2 y 3, aunque puedan intercambiarse entre s\u00ed. Esto se debe a que la librer\u00eda gestiona el funcionamiento de estos sensores bas\u00e1ndose en el uso de interrupciones, que en las tarjetas Arduino UNO y NANO deben ser forzosamente estas patillas Repetimos que el uso de estos encoder en Arduino es bastante complicado, por lo que el lector no deber\u00eda esperar resultados perfectos. Si sujetamos a Masaylo en el aire, es decir, probamos los programas en vac\u00edo, obtendremos el funcionamiento m\u00e1s aproximado. Una vez en el suelo, dependiendo del estado de las pilas, podemos encontrar errores m\u00e1s o menos aproximados. Control de distancias y \u00e1ngulos en MasayloBlockly \u00b6 MasayloBlockly aprovecha al m\u00e1ximo las caracter\u00edsticas de la librer\u00eda de Masaylo para ofrecernos el siguiente despliegue de opciones: Icono Funci\u00f3n Inicializar los encoder indicando sus pines a izquierda y derecha. El di\u00e1metro hace referencia al de las ruedas de Masaylo. Si el usuario modificara dicho tama\u00f1o, debe especificarlo para el correcto c\u00e1lculo de distancias recorridas. Cuando Masaylo est\u00e1 en marcha hacia adelante, espera a que sus ruedas hayan dado el n\u00famero de vueltas especificado antes de pasar a la siguiente orden Cuando Masaylo est\u00e1 en marcha hacia adelante, espera a haber avanzado la distancia indicada antes de pasar a la siguiente orden Cuando Masaylo est\u00e1 girando, espera a haber avanzado el \u00e1ngulo marcado por el usuario antes de pasar a la siguiente orden Objetivos de la pr\u00e1ctica \u00b6 En esta ocasi\u00f3n, nos proponemos utilizar los encoder para hacer que Masaylo haga un recorrido que dibuje un cuadrado de 20 cm. Nuestro programa deber\u00e1 cumplir los siguientes objetivos: Inicializar el robot Masaylo indicando, en su caso, los pines de control de motores. Inicializar los encoder, indicando la patilla a que est\u00e1n conectados (forzosamente deben ser los pines digitales 2 y 3). Repetir en bucle cuatro veces el siguiente conjunto de \u00f3rdenes: Ir hacia adelante Esperar 20 cm Parar durante 1 segundo Girar a la derecha Esperar a haber completado los 90 \u00ba Parar durante 1 segundo Fin del programa. Interrumpir ciclo de trabajo. Nuevo bloque de control de flujo: uso de bucles \u00b6 Aprovechando que hay que repetir conjuntos de \u00f3rdenes, presentaremos otra de las piezas importantes dentro de la opci\u00f3n L\u00f3gica de MasayloBlockly: el comando Repetir x veces Comando de control de flujo: repetir x veces Programa: recorrer un cuadrado perfecto \u00b6 La imagen siguiente presenta la soluci\u00f3n a la pr\u00e1ctica propuesta( Nota: este programa est\u00e1 disponible en el bot\u00f3n de Ejemplos del men\u00fa principal, con el t\u00edtulo \"Aprende a usar los encoder de ranura para recorrer un cuadrado perfecto\"). Pr\u00e1ctica: recorrer un cuadrado perfecto","title":"Trabajo con encoder. Control b\u00e1sico de distancias y \u00e1ngulos"},{"location":"masayloBlockly/encoder/#trabajo-con-encoder-control-basico-de-distancias-y-angulos","text":"Masaylo nos ofrece tambi\u00e9n la posibilidad de instalar dos encoder modelo FC-03 , que permiten un cierto control sobre el \u00e1ngulo de giro de los motores DC de desplazamiento. Estos sensores, de por s\u00ed, son de dif\u00edcil manejo para los aficionados maker con una cierta experiencia en la implementaci\u00f3n de sistemas con Arduino. Adem\u00e1s, precisan del manejo de interrupciones por parte del microprocesador, concepto \u00e9ste reservado para estudiantes m\u00e1s avanzados. No obstante, la librer\u00eda de Masaylo resuelve con cierta elegancia todos estos inconvenientes, permitiendo un control, si no perfecto, s\u00ed bastante adecuado de distancias recorridas y \u00e1ngulos de desplazamiento. Nota: al contrario que en el resto de sensores, los pines de conexi\u00f3n de los encoder no son opcionales. Deben ser forzosamente 2 y 3, aunque puedan intercambiarse entre s\u00ed. Esto se debe a que la librer\u00eda gestiona el funcionamiento de estos sensores bas\u00e1ndose en el uso de interrupciones, que en las tarjetas Arduino UNO y NANO deben ser forzosamente estas patillas Repetimos que el uso de estos encoder en Arduino es bastante complicado, por lo que el lector no deber\u00eda esperar resultados perfectos. Si sujetamos a Masaylo en el aire, es decir, probamos los programas en vac\u00edo, obtendremos el funcionamiento m\u00e1s aproximado. Una vez en el suelo, dependiendo del estado de las pilas, podemos encontrar errores m\u00e1s o menos aproximados.","title":"Trabajo con encoder. Control b\u00e1sico de distancias y \u00e1ngulos"},{"location":"masayloBlockly/encoder/#control-de-distancias-y-angulos-en-masayloblockly","text":"MasayloBlockly aprovecha al m\u00e1ximo las caracter\u00edsticas de la librer\u00eda de Masaylo para ofrecernos el siguiente despliegue de opciones: Icono Funci\u00f3n Inicializar los encoder indicando sus pines a izquierda y derecha. El di\u00e1metro hace referencia al de las ruedas de Masaylo. Si el usuario modificara dicho tama\u00f1o, debe especificarlo para el correcto c\u00e1lculo de distancias recorridas. Cuando Masaylo est\u00e1 en marcha hacia adelante, espera a que sus ruedas hayan dado el n\u00famero de vueltas especificado antes de pasar a la siguiente orden Cuando Masaylo est\u00e1 en marcha hacia adelante, espera a haber avanzado la distancia indicada antes de pasar a la siguiente orden Cuando Masaylo est\u00e1 girando, espera a haber avanzado el \u00e1ngulo marcado por el usuario antes de pasar a la siguiente orden","title":"Control de distancias y \u00e1ngulos en MasayloBlockly"},{"location":"masayloBlockly/encoder/#objetivos-de-la-practica","text":"En esta ocasi\u00f3n, nos proponemos utilizar los encoder para hacer que Masaylo haga un recorrido que dibuje un cuadrado de 20 cm. Nuestro programa deber\u00e1 cumplir los siguientes objetivos: Inicializar el robot Masaylo indicando, en su caso, los pines de control de motores. Inicializar los encoder, indicando la patilla a que est\u00e1n conectados (forzosamente deben ser los pines digitales 2 y 3). Repetir en bucle cuatro veces el siguiente conjunto de \u00f3rdenes: Ir hacia adelante Esperar 20 cm Parar durante 1 segundo Girar a la derecha Esperar a haber completado los 90 \u00ba Parar durante 1 segundo Fin del programa. Interrumpir ciclo de trabajo.","title":"Objetivos de la pr\u00e1ctica"},{"location":"masayloBlockly/encoder/#nuevo-bloque-de-control-de-flujo-uso-de-bucles","text":"Aprovechando que hay que repetir conjuntos de \u00f3rdenes, presentaremos otra de las piezas importantes dentro de la opci\u00f3n L\u00f3gica de MasayloBlockly: el comando Repetir x veces Comando de control de flujo: repetir x veces","title":"Nuevo bloque de control de flujo: uso de bucles"},{"location":"masayloBlockly/encoder/#programa-recorrer-un-cuadrado-perfecto","text":"La imagen siguiente presenta la soluci\u00f3n a la pr\u00e1ctica propuesta( Nota: este programa est\u00e1 disponible en el bot\u00f3n de Ejemplos del men\u00fa principal, con el t\u00edtulo \"Aprende a usar los encoder de ranura para recorrer un cuadrado perfecto\"). Pr\u00e1ctica: recorrer un cuadrado perfecto","title":"Programa: recorrer un cuadrado perfecto"},{"location":"masayloBlockly/instalacion/","text":"Mi primer programa. Instalaci\u00f3n de librer\u00edas \u00b6 Para compilar y cargar los binarios en Arduino, MasayloBlockly utiliza la herramienta arduino-cli , una soluci\u00f3n integral que gestiona la instalaci\u00f3n de librer\u00edas y tarjetas (Arduino o ESP), la compilaci\u00f3n y el volcado del c\u00f3digo. Si bien es una herramienta completamente portable y aut\u00f3noma, MasayloBlockly crear\u00e1 una carpeta en nuestro disco duro (incluso en sus versiones portables) que utilizar\u00e1 para trabajar con archivos temporales. Adem\u00e1s, arduino-cli necesita un archivo de configuraci\u00f3n e instalar el n\u00facleo de compatibilidad (core) con las tarjetas Arduino y, opcionalmente, tarjetas ESP, as\u00ed como las librer\u00edas que usa MasayloBlockly con estos sistemas de control. Pasos de instalaci\u00f3n detallados \u00b6 La primera vez que intentamos compilar/cargar un programa con una nueva versi\u00f3n de MasayloBlockly, el software lo detectar\u00e1 y enviar\u00e1 un mensaje en una ventana emergente indicando que necesita instalar algunas librer\u00edas. El proceso que sigue a continuaci\u00f3n va informando al usuario de manera ordenada en sucesivas ventanas emergentes de los pasos que se van dando. Como el proceso es muy parecido en los sistemas operativos Windows y Linux, procedemos a documentarlo en Linux. Tras cerrar el primer popup, se abre otro indicando al usuario que espere un mensaje de confirmaci\u00f3n. El siguiente paso es crear una carpeta llamada masaylo en la carpeta /home/usuario/.masaylo Una vez creada dicha carpeta, un nuevo mensaje avisa de que se va a proceder a copiar las librer\u00edas necesarias en la carpeta /home/usuario/Arduino/libraries Si nunca se hab\u00eda trabajado con Arduino antes, dicha carpeta se crear\u00e1. Si, por el contrario, el usuario ya hab\u00eda experimentado con el IDE de Arduino, dicha carpeta ya existir\u00e1, y simplemente se a\u00f1adir\u00e1n las carpetas necesarias. Creaci\u00f3n de la carpeta .masaylo Como puede verse en la anterior figura, el proceso es lo bastante r\u00e1pido como para que se solapen algunos pasos. Esto no perjudica en absoluto el resultado final, m\u00e1s bien al contrario. Una vez copiadas las librer\u00edas, se procede a instalar la compatibilidad con las tarjetas Arduino de microcontrolador AVR con las que trabaja MasayloBlockly AVISO: ES NECESARIA UNA CONEXI\u00d3N A INTERNET Dependiendo de la potencia de nuestro ordenador, este proceso puede alargarse un poco. No obstante, en poco tiempo surgir\u00e1 un nuevo popup de confirmaci\u00f3n: S\u00f3lo nos queda instalar la compatibilidad con ESP8266 (como la NodeMCU) y ESP32. Como es opcional, la nueva ventana abierta nos permite elegir si queremos hacer esta instalaci\u00f3n. DISCLAIMER: Arduino-cli necesita descargar los archivos necesarios para trabajar con estas carpetas de un servidor de Espresiff. Hemos podido comprobar que, en ocasiones, este servidor no responde correctamente y nos podemos encontrar con un mensaje de error. Ello \u00fanicamente supone que MasayloBlockly a\u00fan no puede trabajar con dichas tarjetas, pero el resto de la instalaci\u00f3n se ha llevado a cabo con \u00e9xito. En otro apartado hemos dejado un link a un script que nos permitir\u00e1 volver a intentarlo si nos encontramos con este problema. Si elegimos instalar los core de ESP (muy recomendable), se nos avisar\u00e1 de que este proceso puede ser algo m\u00e1s largo que los anteriores. Si todo va bien, un \u00faltimo mensaje nos confirmar\u00e1 que ya estamos preparados para empezar a trabajar. V\u00eddeo explicativo: instalaci\u00f3n de librer\u00edas y archivos de caracter\u00edsticas \u00b6 \u00bfQu\u00e9 hacer si falla la instalaci\u00f3n de ESP8266 y ESP32? \u00b6 Si falla la instalaci\u00f3n de tarjetas ESP, no estaremos preparados para usar MasayloBlockly para programar sistemas IoT (Internet of Things, Internet de las cosas), de modo que tenemos dos posibilidades: Desinstalar Masaylo y repetir el proceso (en Linux, bastar\u00eda con borrar la carpeta ./masaylo de nuestra home) Instalar manualmente estas tarjetas con un script (un programa de consola). LINK A SCRIPT DE INSTALACI\u00d3N DE TARJETAS ESP \u00b6 V\u00eddeo explicativo: uso de script de instalaci\u00f3n de tarjetas ESP8266 y ESP32 \u00b6","title":"Instalaci\u00f3n de librer\u00edas"},{"location":"masayloBlockly/instalacion/#mi-primer-programa-instalacion-de-librerias","text":"Para compilar y cargar los binarios en Arduino, MasayloBlockly utiliza la herramienta arduino-cli , una soluci\u00f3n integral que gestiona la instalaci\u00f3n de librer\u00edas y tarjetas (Arduino o ESP), la compilaci\u00f3n y el volcado del c\u00f3digo. Si bien es una herramienta completamente portable y aut\u00f3noma, MasayloBlockly crear\u00e1 una carpeta en nuestro disco duro (incluso en sus versiones portables) que utilizar\u00e1 para trabajar con archivos temporales. Adem\u00e1s, arduino-cli necesita un archivo de configuraci\u00f3n e instalar el n\u00facleo de compatibilidad (core) con las tarjetas Arduino y, opcionalmente, tarjetas ESP, as\u00ed como las librer\u00edas que usa MasayloBlockly con estos sistemas de control.","title":"Mi primer programa. Instalaci\u00f3n de librer\u00edas"},{"location":"masayloBlockly/instalacion/#pasos-de-instalacion-detallados","text":"La primera vez que intentamos compilar/cargar un programa con una nueva versi\u00f3n de MasayloBlockly, el software lo detectar\u00e1 y enviar\u00e1 un mensaje en una ventana emergente indicando que necesita instalar algunas librer\u00edas. El proceso que sigue a continuaci\u00f3n va informando al usuario de manera ordenada en sucesivas ventanas emergentes de los pasos que se van dando. Como el proceso es muy parecido en los sistemas operativos Windows y Linux, procedemos a documentarlo en Linux. Tras cerrar el primer popup, se abre otro indicando al usuario que espere un mensaje de confirmaci\u00f3n. El siguiente paso es crear una carpeta llamada masaylo en la carpeta /home/usuario/.masaylo Una vez creada dicha carpeta, un nuevo mensaje avisa de que se va a proceder a copiar las librer\u00edas necesarias en la carpeta /home/usuario/Arduino/libraries Si nunca se hab\u00eda trabajado con Arduino antes, dicha carpeta se crear\u00e1. Si, por el contrario, el usuario ya hab\u00eda experimentado con el IDE de Arduino, dicha carpeta ya existir\u00e1, y simplemente se a\u00f1adir\u00e1n las carpetas necesarias. Creaci\u00f3n de la carpeta .masaylo Como puede verse en la anterior figura, el proceso es lo bastante r\u00e1pido como para que se solapen algunos pasos. Esto no perjudica en absoluto el resultado final, m\u00e1s bien al contrario. Una vez copiadas las librer\u00edas, se procede a instalar la compatibilidad con las tarjetas Arduino de microcontrolador AVR con las que trabaja MasayloBlockly AVISO: ES NECESARIA UNA CONEXI\u00d3N A INTERNET Dependiendo de la potencia de nuestro ordenador, este proceso puede alargarse un poco. No obstante, en poco tiempo surgir\u00e1 un nuevo popup de confirmaci\u00f3n: S\u00f3lo nos queda instalar la compatibilidad con ESP8266 (como la NodeMCU) y ESP32. Como es opcional, la nueva ventana abierta nos permite elegir si queremos hacer esta instalaci\u00f3n. DISCLAIMER: Arduino-cli necesita descargar los archivos necesarios para trabajar con estas carpetas de un servidor de Espresiff. Hemos podido comprobar que, en ocasiones, este servidor no responde correctamente y nos podemos encontrar con un mensaje de error. Ello \u00fanicamente supone que MasayloBlockly a\u00fan no puede trabajar con dichas tarjetas, pero el resto de la instalaci\u00f3n se ha llevado a cabo con \u00e9xito. En otro apartado hemos dejado un link a un script que nos permitir\u00e1 volver a intentarlo si nos encontramos con este problema. Si elegimos instalar los core de ESP (muy recomendable), se nos avisar\u00e1 de que este proceso puede ser algo m\u00e1s largo que los anteriores. Si todo va bien, un \u00faltimo mensaje nos confirmar\u00e1 que ya estamos preparados para empezar a trabajar.","title":"Pasos de instalaci\u00f3n detallados"},{"location":"masayloBlockly/instalacion/#video-explicativo-instalacion-de-librerias-y-archivos-de-caracteristicas","text":"","title":"V\u00eddeo explicativo: instalaci\u00f3n de librer\u00edas y archivos de caracter\u00edsticas"},{"location":"masayloBlockly/instalacion/#que-hacer-si-falla-la-instalacion-de-esp8266-y-esp32","text":"Si falla la instalaci\u00f3n de tarjetas ESP, no estaremos preparados para usar MasayloBlockly para programar sistemas IoT (Internet of Things, Internet de las cosas), de modo que tenemos dos posibilidades: Desinstalar Masaylo y repetir el proceso (en Linux, bastar\u00eda con borrar la carpeta ./masaylo de nuestra home) Instalar manualmente estas tarjetas con un script (un programa de consola).","title":"\u00bfQu\u00e9 hacer si falla la instalaci\u00f3n de ESP8266 y ESP32?"},{"location":"masayloBlockly/instalacion/#link-a-script-de-instalacion-de-tarjetas-esp","text":"","title":"LINK A SCRIPT DE INSTALACI\u00d3N DE TARJETAS ESP"},{"location":"masayloBlockly/instalacion/#video-explicativo-uso-de-script-de-instalacion-de-tarjetas-esp8266-y-esp32","text":"","title":"V\u00eddeo explicativo: uso de script de instalaci\u00f3n de tarjetas ESP8266 y ESP32"},{"location":"masayloBlockly/primerPrograma/","text":"Mi primer programa: movimientos b\u00e1sicos de Masaylo \u00b6 Objetivos de la pr\u00e1ctica \u00b6 Muy bien. Ya hemos instalado nuestra aplicaci\u00f3n, hemos instalado nuestras librer\u00edas y archivos de caracter\u00edsticas de microcontroladores y estamos preparados para realizar nuestra primera prueba pr\u00e1ctica. Para ello, vamos a programar a nuestro Masaylo para que haga una \u00fanica vez (ya explicamos en la secci\u00f3n Primeros pasos c\u00f3mo introducir un punto de interrupci\u00f3n de programa con la tecla \"Fin\") la siguiente secuencia de movimientos: Moverse hacia adelante durante 3 segundos. Girar hacia la izquierda 0.5 segundos. Mover hacia adelante otros 3 segundos. Girar hacia la derecha durante 0.5 segundos. Ir hacia atr\u00e1s 3 segundos. Girar hacia la izquierda durante 1 segundo. Paro. Fin del programa. Creaci\u00f3n del programa en MasayloBlockly \u00b6 Todas las piezas que vamos a utilizar las obtendremos de los siguientes bloques de opciones: para todos los comandos de movimiento del robot (como es obvio) para los comandos de espera (en modo primerizo si utilizamos el icono de preferencias del men\u00fa principal) para insertar la pieza \"Fin\" que introducir\u00e1 el punto de interrupci\u00f3n del programa. Inicializaci\u00f3n de un robot en Arduino \u00b6 Por norma, todos los programas referidos a robots en Arduino y derivados implican el uso de librer\u00edas especializadas inspiradas en la filosof\u00eda de la programaci\u00f3n orientada a objetos (POO) que exigen, al principio del programa, que se declare e inicialize un objeto de la clase que integra las caracter\u00edsticas del robot referido. En todos los casos, la pieza referida a la inicializaci\u00f3n del robot estar\u00e1 siempre al principio del desplegable de cada bloque de opciones: Icono Funci\u00f3n Inicializar un Escornabot Inicializar un OttoDIY Inicializar un Otto Humanoide Inicializar un robot Masaylo est\u00e1ndar Inicializar un Masaylo que no lleva las conexiones por defecto que se aconsejan en la documentaci\u00f3n (esto es, est\u00e1 personalizado) Programa: movimientos b\u00e1sicos \u00b6 Procedemos, pues, a crear nuestro programa con el objetivo de lograr los objetivos estipulados. Por esta vez, no nos pararemos a matizar la velocidad a la que queremos hacer cada movimiento (para lo que, obviamente, tambi\u00e9n disponemos del correspondiente comando en formato gr\u00e1fico) y nos limitaremos a crear el siguiente programa ( Nota: este programa est\u00e1 disponible en el bot\u00f3n de Ejemplos del men\u00fa principal, con el el t\u00edtulo \"Aprende a controlar los movimientos b\u00e1sicos del robot Masaylo\"). Mi primer programa: movimientos b\u00e1sicos V\u00eddeo explicativo: mi primer programa: secuencia de movimientos simples \u00b6","title":"Mi primer programa. Movimientos b\u00e1sicos"},{"location":"masayloBlockly/primerPrograma/#mi-primer-programa-movimientos-basicos-de-masaylo","text":"","title":"Mi primer programa: movimientos b\u00e1sicos de Masaylo"},{"location":"masayloBlockly/primerPrograma/#objetivos-de-la-practica","text":"Muy bien. Ya hemos instalado nuestra aplicaci\u00f3n, hemos instalado nuestras librer\u00edas y archivos de caracter\u00edsticas de microcontroladores y estamos preparados para realizar nuestra primera prueba pr\u00e1ctica. Para ello, vamos a programar a nuestro Masaylo para que haga una \u00fanica vez (ya explicamos en la secci\u00f3n Primeros pasos c\u00f3mo introducir un punto de interrupci\u00f3n de programa con la tecla \"Fin\") la siguiente secuencia de movimientos: Moverse hacia adelante durante 3 segundos. Girar hacia la izquierda 0.5 segundos. Mover hacia adelante otros 3 segundos. Girar hacia la derecha durante 0.5 segundos. Ir hacia atr\u00e1s 3 segundos. Girar hacia la izquierda durante 1 segundo. Paro. Fin del programa.","title":"Objetivos de la pr\u00e1ctica"},{"location":"masayloBlockly/primerPrograma/#creacion-del-programa-en-masayloblockly","text":"Todas las piezas que vamos a utilizar las obtendremos de los siguientes bloques de opciones: para todos los comandos de movimiento del robot (como es obvio) para los comandos de espera (en modo primerizo si utilizamos el icono de preferencias del men\u00fa principal) para insertar la pieza \"Fin\" que introducir\u00e1 el punto de interrupci\u00f3n del programa.","title":"Creaci\u00f3n del programa en MasayloBlockly"},{"location":"masayloBlockly/primerPrograma/#inicializacion-de-un-robot-en-arduino","text":"Por norma, todos los programas referidos a robots en Arduino y derivados implican el uso de librer\u00edas especializadas inspiradas en la filosof\u00eda de la programaci\u00f3n orientada a objetos (POO) que exigen, al principio del programa, que se declare e inicialize un objeto de la clase que integra las caracter\u00edsticas del robot referido. En todos los casos, la pieza referida a la inicializaci\u00f3n del robot estar\u00e1 siempre al principio del desplegable de cada bloque de opciones: Icono Funci\u00f3n Inicializar un Escornabot Inicializar un OttoDIY Inicializar un Otto Humanoide Inicializar un robot Masaylo est\u00e1ndar Inicializar un Masaylo que no lleva las conexiones por defecto que se aconsejan en la documentaci\u00f3n (esto es, est\u00e1 personalizado)","title":"Inicializaci\u00f3n de un robot en Arduino"},{"location":"masayloBlockly/primerPrograma/#programa-movimientos-basicos","text":"Procedemos, pues, a crear nuestro programa con el objetivo de lograr los objetivos estipulados. Por esta vez, no nos pararemos a matizar la velocidad a la que queremos hacer cada movimiento (para lo que, obviamente, tambi\u00e9n disponemos del correspondiente comando en formato gr\u00e1fico) y nos limitaremos a crear el siguiente programa ( Nota: este programa est\u00e1 disponible en el bot\u00f3n de Ejemplos del men\u00fa principal, con el el t\u00edtulo \"Aprende a controlar los movimientos b\u00e1sicos del robot Masaylo\"). Mi primer programa: movimientos b\u00e1sicos","title":"Programa: movimientos b\u00e1sicos"},{"location":"masayloBlockly/primerPrograma/#video-explicativo-mi-primer-programa-secuencia-de-movimientos-simples","text":"","title":"V\u00eddeo explicativo: mi primer programa: secuencia de movimientos simples"},{"location":"masayloBlockly/primerospasos/","text":"Primeros pasos. Vista general de MasayloBlockly \u00b6 Organizaci\u00f3n general del escritorio \u00b6 El entorno de programaci\u00f3n nos ofrece un escritorio dividido en cuatro grandes zonas: Men\u00fa principal Men\u00fa de opciones de programaci\u00f3n (desplegar\u00e1 un submen\u00fa con distintos comandos seg\u00fan la opci\u00f3n elegida) Zona principal de trabajo Zona de traducci\u00f3n simult\u00e1nea a C++ (desplegable o no a elecci\u00f3n del usuario) Organizaci\u00f3n general del entorno de trabajo Men\u00fa principal \u00b6 El men\u00fa principal ofrece las siguientes opciones, simbolizadas por iconos: Modo gr\u00e1fico/modo texto Hacer click en este icono conmutar\u00e1 la barra de la zona de opciones de programaci\u00f3n por el c\u00f3digo en modo texto del algoritmo en el que estamos trabajando, a semejanza de lo que ocurre en la zona de traducci\u00f3n a C++, pero con la opci\u00f3n a\u00f1adida de poder editar el c\u00f3digo generado (no es recomendable para usuarios inexpertos), de modo que podamos introducir peque\u00f1as variaciones a nuestro gusto. Nuevo abre un nuevo programa en blanco, reiniciando el flujo de trabajo (obviamente) Ejemplos ofrece una selecci\u00f3n de programas precargados, principalmente (en el momento de escribir estas l\u00edneas) para Escornabot y Masaylo Cargar programa abre un programa guardado previamente. Los programas se guardan en formato XML con extensi\u00f3n .block Guardar programa guarda nuestro trabajo en el directorio que indiquemos. Preferencias abre una subventana que nos permite, entre otras cosas, elegir los bloques de comandos de que queremos disponer y el idioma en que queremos trabajar (ingl\u00e9s, franc\u00e9s y espa\u00f1ol, aunque de momento s\u00f3lo est\u00e1 garantizado el funcionamiento en espa\u00f1ol). Monitor puerto serie abre una subventana con acceso al monitor del puerto serie. Tarjetas disponibles despliega una selecci\u00f3n con las tarjetas que MasayloBlockly puede programar. Importante: debe elegirse ANTES de empezar a programar, o grabar nuestro programa antes de cambiar de tarjeta, pues cualquier cambio provocar\u00e1 un borrado de la zona de trabajo Elecci\u00f3n de puerto USB en este desplegable aparecer\u00e1n los puertos USB disponibles. El usuario deber\u00e1 indicar el puerto (normalmente, s\u00f3lo habr\u00e1 uno disponible) en que ha conectado la tarjeta Arduino. Compilar Este bot\u00f3n dar\u00e1 la orden de iniciar el proceso de compilaci\u00f3n del programa. Si todo es correcto, un mensaje de confirmaci\u00f3n lo indicar\u00e1. De lo contrario, se indicar\u00e1 qu\u00e9 fallo se ha cometido en un mensaje de pop-up. Este proceso no es obligatorio (basta con pinchar directamente en la opci\u00f3n de volcado), pero es un h\u00e1bito aconsejable . Cargar Una vez compilado (aunque, repetimos, no es un paso obligatorio), el siguiente paso es cargar el programa en el sistema de control (rob\u00f3tico o no) que hayamos conectado, previa selecci\u00f3n del puerto USB. Al cabo de unos segundos, si se ha elegido correctamente el tipo de tarjeta utilizada y el puerto conectado, un mensaje de confirmaci\u00f3n nos indicar\u00e1 que todo el proceso se ha realizado correctamente. Acabamos de volcar nuestro programa en la tarjeta Arduino. Exportar Despu\u00e9s de la compilaci\u00f3n, se nos ofrece la oportunidad de guardar el programa compilado en binario en nuestro disco duro, con fines educativos o acad\u00e9micos. Cargar Una vez compilado (aunque, repetimos, no es un paso obligatorio), el siguiente paso es cargar el programa en el sistema de control (rob\u00f3tico o no) que hayamos conectado, previa selecci\u00f3n del puerto USB. Al cabo de unos segundos, si se ha elegido correctamente el tipo de tarjeta utilizada y el puerto conectado, un mensaje de confirmaci\u00f3n nos indicar\u00e1 que todo el proceso se ha realizado correctamente. Acabamos de volcar nuestro programa en la tarjeta Arduino. Deshacer Deshace el \u00faltimo paso. Rehacer Rehace el \u00faltimo paso. Tomar instant\u00e1nea Graba el programa en su versi\u00f3n gr\u00e1fica en formato *.png en la carpeta que indique el usuario. Desplegar la zona de c\u00f3digo Abre o cierra la zona de traducci\u00f3n simult\u00e1nea a C++ del programa que el usuario est\u00e1 generando. Men\u00fa de opciones de programaci\u00f3n \u00b6 De manera muy intuitiva, las distintas agrupaciones de comandos utilizables se ofrecen de manera ordenada en la zona izquierda de la pantalla. Dichos comandos pueden combinarse entre s\u00ed (es decir, si por ejemplo empezamos a trabajar con el bloque Masaylo , ello no quiere decir que no podamos utilizar piezas de la agrupaci\u00f3n Tiempo o Estructura ). Hay dos modos de trabajo, elegibles desde el icono de Preferencias , perfectamente configurables: \"Primerizo\" o \"Experto\" . Cada uno de ellos nos permite elegir qu\u00e9 agrupaciones de piezas deseamos que aparezca en este men\u00fa. Podemos elegir todas las disponibles, o por el contrario podemos especificar s\u00f3lo las que vamos a necesitar, al objeto de no enfrentarnos a un conjunto excesivo de opciones que pueda hacer el trabajo con este entorno demasiado confuso. | Apariencia de la subventana de configuraci\u00f3n | |:-:| | | Obs\u00e9rvese la presencia del bot\u00f3n \"Vaciar memoria cach\u00e9\" . Si en alg\u00fan momento la aplicaci\u00f3n ofrece alg\u00fan comportamiento extra\u00f1o, o el usuario detecta corrupci\u00f3n o mal funcionamiento en la plantilla que organiza la apariencia de la aplicaci\u00f3n, esta opci\u00f3n resetear\u00e1 al programa a sus opciones de inicio. Zona principal de trabajo y espacio de traducci\u00f3n simult\u00e1nea \u00b6 En esta zona, inicialmente en blanco, iremos \"encajando\" las distintas piezas que representen las \u00f3rdenes que queremos incluir en nuestro programa. A medida que vamos especificando las \u00f3rdenes que queremos a\u00f1adir al programa, y si hemos activado la zona de traducci\u00f3n simult\u00e1nea con el icono , podremos acceder a la redacci\u00f3n del programa equivalente en lenguaje C++ que causar\u00eda el mismo efecto en el sistema de control si utilizaramos el IDE de Arduino. Espacio de traducci\u00f3n Simult\u00e1nea a C++ La zona de traducci\u00f3n simult\u00e1nea no es editable y por lo tanto no se puede modificar. . Si queremos editar el c\u00f3digo necesitaremos utilizar la herramienta Conmutaci\u00f3n a modo texto El espacio de traducci\u00f3n simult\u00e1nea incorpora, a su vez, dos herramientas \u00fatiles, representadas por sus respectivos iconos: Guardar sketch Permite guardar el sketch con extensi\u00f3n *.ino (la extensi\u00f3n est\u00e1ndar para el IDE de Arduino) en la carpeta se\u00f1alada por el usuario con el nombre que desee. Copiar sketch Guarda el texto del sketch en memoria para utilizarlo en funciones de copia y pega en otros programas. Conmutaci\u00f3n a modo texto \u00b6 Como se ha explicado al principio de esta secci\u00f3n, el icono tiene la funci\u00f3n de desactivar el modo gr\u00e1fico en el que trabaja, haciendo desaparecer el editor visual de c\u00f3digo, torn\u00e1ndolo por el texto en lenguaje C++, al estilo de lo que se ve en la zona de traducci\u00f3n simult\u00e1nea , pero con la caracter\u00edstica particular de que el usuario puede editar y modificar el c\u00f3digo (asumiendo el riesgo correspondiente). La conmutaci\u00f3n a modo texto nos permite editar el c\u00f3digo Nota interesante: estructura de un programa en Arduino \u00b6 Si bien la meta de MasayloBlockly es permitir a sus usuarios programar sus propios robots/sistemas de control sin tener conocimiento de C++, esta informaci\u00f3n sobre los c\u00f3digos *.ino s\u00ed que puede resultarle \u00fatil. Por definici\u00f3n, cualquier c\u00f3digo en Arduino tiene, COMO M\u00cdNIMO (obviando la inclusi\u00f3n de librer\u00edas y la declaraci\u00f3n de variables globales), dos funciones generales en las que se introducen las \u00f3rdenes correspondientes a cada \"pieza\" de nuestra zona de trabajo: Funci\u00f3n de configuraci\u00f3n (setup) . En esta funci\u00f3n introducimos todos los comandos referentes a la configuraci\u00f3n (entradas, salidas, uso digital/anal\u00f3gico...) del sistema. ESTA FUNCI\u00d3N SE EJECUTA AL ARRANCAR EL PROGRAMA, UNA \u00daNICA VEZ. AL LLEGAR A LA \u00daLTIMA ORDEN, DA PASO A loop() Para repetir esta funci\u00f3n, habr\u00eda que reiniciar la tarjeta o apagar y volver a encender el sistema. Funci\u00f3n principal (loop) . Empieza despu\u00e9s de ejecutarse la funci\u00f3n setup() . Esta funci\u00f3n contiene los comandos generales que regir\u00e1n el comportamiento de nuestro robot o sistema de control, gobernados por nuestra tarjeta controladora, sea \u00e9sta Arduino, ESP8266 o ESP32. ESTA FUNCI\u00d3N SE REPITE INVARIABLEMENTE. CADA VEZ QUE LLEGA A LA \u00daLTIMA ORDEN QUE CONTIENE Y LA EJECUTA, VOLVER\u00c1 DE NUEVO AL COMIENZO. ES LO QUE SE CONOCE COMO UN BUCLE . Dependiendo del programa, el conjunto de comandos que contiene esta funci\u00f3n puede llegar a ejecutarse varias veces por segundo . \u00bfQu\u00e9 implica esta filosof\u00eda de programaci\u00f3n?. Que el usuario novel puede cometer un fallo como el del siguiente ejemplo: supongamos que queremos programar a un robot Masaylo para que al arrancar, vaya hacia adelante durante un segundo, y luego se pare. Eso supone dar tres \u00f3rdenes (nos pararemos con m\u00e1s detalle sobre las caracter\u00edsticas de este programa en pr\u00f3ximas secciones). El problema es que dichas \u00f3rdenes se estipulan (como puede verse en la ilustraci\u00f3n) dentro de la funci\u00f3n loop() . Seg\u00fan lo que acabamos de explicar, ello supone que al llegar a la \u00faltima orden (ALTO) , el bucle se reiniciar\u00e1, ejecutando inmediatamente de nuevo la orden ADELANTE , que obviamente anula el paro de los motores. El resultado pr\u00e1ctico es que nuestro Masaylo empezar\u00e1 un movimiento hacia adelante continuo, sin que podamos percibir que el robot se detenga nunca. Ejemplo de programa con resultado inesperado debido a la repetici\u00f3n en bucle de las \u00f3rdenes \u00bfSignifica ello que no podemos crear programas que se ejecuten una \u00fanica vez?. No, por supuesto. Para ello podemos utilizar una pieza especial denominada FIN , disponible en el bloque Arduino en el modo Primerizo, y en el bloque Estructura en el modo Experto, que all\u00e1 donde la pongamos (nota para usuarios m\u00e1s expertos) insertar\u00e1 un bucle eterno de tipo while(true); , paralizando a partir de ah\u00ed la ejecuci\u00f3n del resto del c\u00f3digo. Ejecuci\u00f3n de un programa una \u00fanica vez con la pieza Fin Prepar\u00e1ndonos para crear nuestro primer programa \u00b6 Esta introducci\u00f3n, aunque m\u00ednima, deber\u00eda ser suficiente para que el usuario se mueva con cierta soltura por todas las caracter\u00edsticas que ofrece este entorno gr\u00e1fico de programaci\u00f3n. Como hemos comentado ya a\u00fan tenemos pendiente un \u00faltimo paso, que es el de la instalaci\u00f3n de librer\u00edas , y que se llevar\u00e1 a cabo una vez creemos nuestro primer programa y tratemos de compilarlo o volcarlo directamente en el micro de nuestro robot. V\u00eddeo explicativo: caracter\u00edsticas generales de MasayloBlockly \u00b6","title":"Primeros pasos"},{"location":"masayloBlockly/primerospasos/#primeros-pasos-vista-general-de-masayloblockly","text":"","title":"Primeros pasos. Vista general de MasayloBlockly"},{"location":"masayloBlockly/primerospasos/#organizacion-general-del-escritorio","text":"El entorno de programaci\u00f3n nos ofrece un escritorio dividido en cuatro grandes zonas: Men\u00fa principal Men\u00fa de opciones de programaci\u00f3n (desplegar\u00e1 un submen\u00fa con distintos comandos seg\u00fan la opci\u00f3n elegida) Zona principal de trabajo Zona de traducci\u00f3n simult\u00e1nea a C++ (desplegable o no a elecci\u00f3n del usuario) Organizaci\u00f3n general del entorno de trabajo","title":"Organizaci\u00f3n general del escritorio"},{"location":"masayloBlockly/primerospasos/#menu-principal","text":"El men\u00fa principal ofrece las siguientes opciones, simbolizadas por iconos: Modo gr\u00e1fico/modo texto Hacer click en este icono conmutar\u00e1 la barra de la zona de opciones de programaci\u00f3n por el c\u00f3digo en modo texto del algoritmo en el que estamos trabajando, a semejanza de lo que ocurre en la zona de traducci\u00f3n a C++, pero con la opci\u00f3n a\u00f1adida de poder editar el c\u00f3digo generado (no es recomendable para usuarios inexpertos), de modo que podamos introducir peque\u00f1as variaciones a nuestro gusto. Nuevo abre un nuevo programa en blanco, reiniciando el flujo de trabajo (obviamente) Ejemplos ofrece una selecci\u00f3n de programas precargados, principalmente (en el momento de escribir estas l\u00edneas) para Escornabot y Masaylo Cargar programa abre un programa guardado previamente. Los programas se guardan en formato XML con extensi\u00f3n .block Guardar programa guarda nuestro trabajo en el directorio que indiquemos. Preferencias abre una subventana que nos permite, entre otras cosas, elegir los bloques de comandos de que queremos disponer y el idioma en que queremos trabajar (ingl\u00e9s, franc\u00e9s y espa\u00f1ol, aunque de momento s\u00f3lo est\u00e1 garantizado el funcionamiento en espa\u00f1ol). Monitor puerto serie abre una subventana con acceso al monitor del puerto serie. Tarjetas disponibles despliega una selecci\u00f3n con las tarjetas que MasayloBlockly puede programar. Importante: debe elegirse ANTES de empezar a programar, o grabar nuestro programa antes de cambiar de tarjeta, pues cualquier cambio provocar\u00e1 un borrado de la zona de trabajo Elecci\u00f3n de puerto USB en este desplegable aparecer\u00e1n los puertos USB disponibles. El usuario deber\u00e1 indicar el puerto (normalmente, s\u00f3lo habr\u00e1 uno disponible) en que ha conectado la tarjeta Arduino. Compilar Este bot\u00f3n dar\u00e1 la orden de iniciar el proceso de compilaci\u00f3n del programa. Si todo es correcto, un mensaje de confirmaci\u00f3n lo indicar\u00e1. De lo contrario, se indicar\u00e1 qu\u00e9 fallo se ha cometido en un mensaje de pop-up. Este proceso no es obligatorio (basta con pinchar directamente en la opci\u00f3n de volcado), pero es un h\u00e1bito aconsejable . Cargar Una vez compilado (aunque, repetimos, no es un paso obligatorio), el siguiente paso es cargar el programa en el sistema de control (rob\u00f3tico o no) que hayamos conectado, previa selecci\u00f3n del puerto USB. Al cabo de unos segundos, si se ha elegido correctamente el tipo de tarjeta utilizada y el puerto conectado, un mensaje de confirmaci\u00f3n nos indicar\u00e1 que todo el proceso se ha realizado correctamente. Acabamos de volcar nuestro programa en la tarjeta Arduino. Exportar Despu\u00e9s de la compilaci\u00f3n, se nos ofrece la oportunidad de guardar el programa compilado en binario en nuestro disco duro, con fines educativos o acad\u00e9micos. Cargar Una vez compilado (aunque, repetimos, no es un paso obligatorio), el siguiente paso es cargar el programa en el sistema de control (rob\u00f3tico o no) que hayamos conectado, previa selecci\u00f3n del puerto USB. Al cabo de unos segundos, si se ha elegido correctamente el tipo de tarjeta utilizada y el puerto conectado, un mensaje de confirmaci\u00f3n nos indicar\u00e1 que todo el proceso se ha realizado correctamente. Acabamos de volcar nuestro programa en la tarjeta Arduino. Deshacer Deshace el \u00faltimo paso. Rehacer Rehace el \u00faltimo paso. Tomar instant\u00e1nea Graba el programa en su versi\u00f3n gr\u00e1fica en formato *.png en la carpeta que indique el usuario. Desplegar la zona de c\u00f3digo Abre o cierra la zona de traducci\u00f3n simult\u00e1nea a C++ del programa que el usuario est\u00e1 generando.","title":"Men\u00fa principal"},{"location":"masayloBlockly/primerospasos/#menu-de-opciones-de-programacion","text":"De manera muy intuitiva, las distintas agrupaciones de comandos utilizables se ofrecen de manera ordenada en la zona izquierda de la pantalla. Dichos comandos pueden combinarse entre s\u00ed (es decir, si por ejemplo empezamos a trabajar con el bloque Masaylo , ello no quiere decir que no podamos utilizar piezas de la agrupaci\u00f3n Tiempo o Estructura ). Hay dos modos de trabajo, elegibles desde el icono de Preferencias , perfectamente configurables: \"Primerizo\" o \"Experto\" . Cada uno de ellos nos permite elegir qu\u00e9 agrupaciones de piezas deseamos que aparezca en este men\u00fa. Podemos elegir todas las disponibles, o por el contrario podemos especificar s\u00f3lo las que vamos a necesitar, al objeto de no enfrentarnos a un conjunto excesivo de opciones que pueda hacer el trabajo con este entorno demasiado confuso. | Apariencia de la subventana de configuraci\u00f3n | |:-:| | | Obs\u00e9rvese la presencia del bot\u00f3n \"Vaciar memoria cach\u00e9\" . Si en alg\u00fan momento la aplicaci\u00f3n ofrece alg\u00fan comportamiento extra\u00f1o, o el usuario detecta corrupci\u00f3n o mal funcionamiento en la plantilla que organiza la apariencia de la aplicaci\u00f3n, esta opci\u00f3n resetear\u00e1 al programa a sus opciones de inicio.","title":"Men\u00fa de opciones de programaci\u00f3n"},{"location":"masayloBlockly/primerospasos/#zona-principal-de-trabajo-y-espacio-de-traduccion-simultanea","text":"En esta zona, inicialmente en blanco, iremos \"encajando\" las distintas piezas que representen las \u00f3rdenes que queremos incluir en nuestro programa. A medida que vamos especificando las \u00f3rdenes que queremos a\u00f1adir al programa, y si hemos activado la zona de traducci\u00f3n simult\u00e1nea con el icono , podremos acceder a la redacci\u00f3n del programa equivalente en lenguaje C++ que causar\u00eda el mismo efecto en el sistema de control si utilizaramos el IDE de Arduino. Espacio de traducci\u00f3n Simult\u00e1nea a C++ La zona de traducci\u00f3n simult\u00e1nea no es editable y por lo tanto no se puede modificar. . Si queremos editar el c\u00f3digo necesitaremos utilizar la herramienta Conmutaci\u00f3n a modo texto El espacio de traducci\u00f3n simult\u00e1nea incorpora, a su vez, dos herramientas \u00fatiles, representadas por sus respectivos iconos: Guardar sketch Permite guardar el sketch con extensi\u00f3n *.ino (la extensi\u00f3n est\u00e1ndar para el IDE de Arduino) en la carpeta se\u00f1alada por el usuario con el nombre que desee. Copiar sketch Guarda el texto del sketch en memoria para utilizarlo en funciones de copia y pega en otros programas.","title":"Zona principal de trabajo y espacio de traducci\u00f3n simult\u00e1nea"},{"location":"masayloBlockly/primerospasos/#conmutacion-a-modo-texto","text":"Como se ha explicado al principio de esta secci\u00f3n, el icono tiene la funci\u00f3n de desactivar el modo gr\u00e1fico en el que trabaja, haciendo desaparecer el editor visual de c\u00f3digo, torn\u00e1ndolo por el texto en lenguaje C++, al estilo de lo que se ve en la zona de traducci\u00f3n simult\u00e1nea , pero con la caracter\u00edstica particular de que el usuario puede editar y modificar el c\u00f3digo (asumiendo el riesgo correspondiente). La conmutaci\u00f3n a modo texto nos permite editar el c\u00f3digo","title":"Conmutaci\u00f3n a modo texto"},{"location":"masayloBlockly/primerospasos/#nota-interesante-estructura-de-un-programa-en-arduino","text":"Si bien la meta de MasayloBlockly es permitir a sus usuarios programar sus propios robots/sistemas de control sin tener conocimiento de C++, esta informaci\u00f3n sobre los c\u00f3digos *.ino s\u00ed que puede resultarle \u00fatil. Por definici\u00f3n, cualquier c\u00f3digo en Arduino tiene, COMO M\u00cdNIMO (obviando la inclusi\u00f3n de librer\u00edas y la declaraci\u00f3n de variables globales), dos funciones generales en las que se introducen las \u00f3rdenes correspondientes a cada \"pieza\" de nuestra zona de trabajo: Funci\u00f3n de configuraci\u00f3n (setup) . En esta funci\u00f3n introducimos todos los comandos referentes a la configuraci\u00f3n (entradas, salidas, uso digital/anal\u00f3gico...) del sistema. ESTA FUNCI\u00d3N SE EJECUTA AL ARRANCAR EL PROGRAMA, UNA \u00daNICA VEZ. AL LLEGAR A LA \u00daLTIMA ORDEN, DA PASO A loop() Para repetir esta funci\u00f3n, habr\u00eda que reiniciar la tarjeta o apagar y volver a encender el sistema. Funci\u00f3n principal (loop) . Empieza despu\u00e9s de ejecutarse la funci\u00f3n setup() . Esta funci\u00f3n contiene los comandos generales que regir\u00e1n el comportamiento de nuestro robot o sistema de control, gobernados por nuestra tarjeta controladora, sea \u00e9sta Arduino, ESP8266 o ESP32. ESTA FUNCI\u00d3N SE REPITE INVARIABLEMENTE. CADA VEZ QUE LLEGA A LA \u00daLTIMA ORDEN QUE CONTIENE Y LA EJECUTA, VOLVER\u00c1 DE NUEVO AL COMIENZO. ES LO QUE SE CONOCE COMO UN BUCLE . Dependiendo del programa, el conjunto de comandos que contiene esta funci\u00f3n puede llegar a ejecutarse varias veces por segundo . \u00bfQu\u00e9 implica esta filosof\u00eda de programaci\u00f3n?. Que el usuario novel puede cometer un fallo como el del siguiente ejemplo: supongamos que queremos programar a un robot Masaylo para que al arrancar, vaya hacia adelante durante un segundo, y luego se pare. Eso supone dar tres \u00f3rdenes (nos pararemos con m\u00e1s detalle sobre las caracter\u00edsticas de este programa en pr\u00f3ximas secciones). El problema es que dichas \u00f3rdenes se estipulan (como puede verse en la ilustraci\u00f3n) dentro de la funci\u00f3n loop() . Seg\u00fan lo que acabamos de explicar, ello supone que al llegar a la \u00faltima orden (ALTO) , el bucle se reiniciar\u00e1, ejecutando inmediatamente de nuevo la orden ADELANTE , que obviamente anula el paro de los motores. El resultado pr\u00e1ctico es que nuestro Masaylo empezar\u00e1 un movimiento hacia adelante continuo, sin que podamos percibir que el robot se detenga nunca. Ejemplo de programa con resultado inesperado debido a la repetici\u00f3n en bucle de las \u00f3rdenes \u00bfSignifica ello que no podemos crear programas que se ejecuten una \u00fanica vez?. No, por supuesto. Para ello podemos utilizar una pieza especial denominada FIN , disponible en el bloque Arduino en el modo Primerizo, y en el bloque Estructura en el modo Experto, que all\u00e1 donde la pongamos (nota para usuarios m\u00e1s expertos) insertar\u00e1 un bucle eterno de tipo while(true); , paralizando a partir de ah\u00ed la ejecuci\u00f3n del resto del c\u00f3digo. Ejecuci\u00f3n de un programa una \u00fanica vez con la pieza Fin","title":"Nota interesante: estructura de un programa en Arduino"},{"location":"masayloBlockly/primerospasos/#preparandonos-para-crear-nuestro-primer-programa","text":"Esta introducci\u00f3n, aunque m\u00ednima, deber\u00eda ser suficiente para que el usuario se mueva con cierta soltura por todas las caracter\u00edsticas que ofrece este entorno gr\u00e1fico de programaci\u00f3n. Como hemos comentado ya a\u00fan tenemos pendiente un \u00faltimo paso, que es el de la instalaci\u00f3n de librer\u00edas , y que se llevar\u00e1 a cabo una vez creemos nuestro primer programa y tratemos de compilarlo o volcarlo directamente en el micro de nuestro robot.","title":"Prepar\u00e1ndonos para crear nuestro primer programa"},{"location":"masayloBlockly/primerospasos/#video-explicativo-caracteristicas-generales-de-masayloblockly","text":"","title":"V\u00eddeo explicativo: caracter\u00edsticas generales de MasayloBlockly"},{"location":"masayloBlockly/sensoresIR/","text":"Introducci\u00f3n a los bloques l\u00f3gicos. Uso de sensores de infrarrojos \u00b6 Pasamos a continuaci\u00f3n a familiarizarnos con el uso de los sensores de infrarrojos FC-51 , que pueden funcionar como sensores de obst\u00e1culos a peque\u00f1as distancias o, como es el caso de Masaylo, para discriminar el color negro del blanco, lo que permite la creaci\u00f3n de robots siguel\u00edneas. En esta pr\u00e1ctica aprenderemos a inicializar los sensores de infrarrojos, tambi\u00e9n llamados IR, de Masaylo y utilizarlos para indicar si el robot detecta blanco o negro tanto a su derecha como a su izquierda a medida que \u00e9ste avanza. Esta informaci\u00f3n se procesar\u00e1 y se ofrecer\u00e1 al usuario a trav\u00e9s del monitor del puerto serie, al estilo de la pr\u00e1ctica anterior con el sensor de ultrasonidos. Pr\u00e1ctica: lectura de sensores de infrarrojos a trav\u00e9s del puerto serie Presentaci\u00f3n de nuevos bloques. Uso de la l\u00f3gica en programaci\u00f3n. Bloques si/si no \u00b6 Para utilizar los sensores de infrarrojos en MasayloBlockly, seguimos la misma filosof\u00eda de trabajo que con el sensor de ultrasonidos: inicializar ambos sensores y recoger su lectura, aunque en este caso el abanico de piezas es algo m\u00e1s amplio: Icono Funci\u00f3n Inicializar los sensores IR indicando sus pines a izquierda y derecha Devuelve verdadero si pisa negro por la izquierda, y falso si pisa blanco Devuelve verdadero si pisa negro por la derecha, y falso si pisa blanco Devuelve verdadero si pisa blanco por la izquierda, y falso si pisa negro Devuelve verdadero si pisa blanco por la derecha, y falso si pisa negro Pero lo realmente importante en esta secci\u00f3n, es que por primera vez vamos a presentar de modo espec\u00edfico el trabajo con bloques l\u00f3gicos, que si bien han aparecido ya en alg\u00fan ejemplo de ampliaci\u00f3n, no han sido a\u00fan tratados con cierta rigurosidad. Dichos bloques est\u00e1n agrupados en la opci\u00f3n **L\u00f3gica ** de la zona de bloques de opciones. Como creemos sinceramente en el concepto del aprendizaje significativo, en esta ocasi\u00f3n s\u00f3lo vamos a trabajar con dos de los bloques de esta agrupaci\u00f3n, que permitir\u00e1n al lector comprender su papel en programaci\u00f3n a trav\u00e9s de su uso en esta pr\u00e1ctica: Icono Funci\u00f3n Bloque de control de flujo SI (si se cumple la condici\u00f3n, se ejecutar\u00e1 el bloque de comandos que se introduzca dentro de este bloque) Compara dos elementos y devuelve verdadero si la condici\u00f3n de comparaci\u00f3n se cumple (A y B, A o B, etc...) El bloque SI, como algunas otras piezas disponibles en MasayloBlockly, incluye un peque\u00f1o icono azul de un engranaje en su parte superior izquierda que permite personalizarlo y a\u00f1adirle funcionalidades (en el caso de la imagen, podemos crear bloques SI/SI NO, SI/DE LO CONTRARIO SI, etc...). Algunos bloques incluyen un peque\u00f1o icono de personalizaci\u00f3n para complementar su significado Objetivos de la pr\u00e1ctica \u00b6 Nuestro programa deber\u00e1 cumplir los siguientes objetivos: Inicializar el puerto serie del robot Masaylo estableciendo una velocidad est\u00e1ndar (9600 baudios). Inicializar el robot Masaylo indicando, en su caso, los pines de control de motores. Inicializar los sensores de infrarrojos, indicando la patilla a que est\u00e1n conectados (por defecto, los pines anal\u00f3gicos A0 y A1). Realizar la lectura de ambos sensores. Pasar el estado de ambos sensores por el puerto serie. Si ambos est\u00e1n en negro, lanzaremos el mensaje \"Lado oscuro de la fuerza\". Si ambos est\u00e1n en blanco, el mensaje ser\u00e1 \"La fuerza est\u00e1 en t\u00ed\" (un gui\u00f1o del programador a los lectores boomer). Esperar un segundo y repetir el bucle. Como el usuario pronto comprobar\u00e1, la personalizaci\u00f3n del bloque l\u00f3gico SI nos facilitar\u00e1 mucho el trabajo. Pr\u00e1ctica: lectura de distancias a trav\u00e9s del puerto serie Programa: comprobaci\u00f3n de sensores IR a trav\u00e9s del puerto serie \u00b6 Presentamos a continuaci\u00f3n la soluci\u00f3n a la pr\u00e1ctica propuesta( Nota: este programa est\u00e1 disponible en el bot\u00f3n de Ejemplos del men\u00fa principal, con el t\u00edtulo \"Env\u00eda al puerto serie de tu ordenador la medici\u00f3n (blanco/negro) de tus sensores IR\"). Programa: env\u00edo de la informaci\u00f3n de los sensores IR al puerto serie Ejercicio de ampliaci\u00f3n: programar un robot siguel\u00edneas \u00b6 La programaci\u00f3n de siguel\u00edneas (normalmente, una l\u00ednea negra sobre un fondo blanco) es un cl\u00e1sico en la pedagog\u00eda de la Rob\u00f3tica Educativa. El uso de motores DC como los de Masaylo, baratos y accesibles de muy dif\u00edcil control, complica bastante esta tarea. No obstante, presentamos a continuaci\u00f3n una propuesta que puede suponer un buen punto de partida. Dependiendo de las distintas condiciones del circuito y del propio robot, ser\u00e1 seguramente necesario adaptarla a dichas circunstancias, moderando las velocidades propuestas. Ejercicio de ampliaci\u00f3n: Masaylo siguel\u00edneas V\u00eddeo explicativo: uso del puerto serie para leer sensores de infrarrojos \u00b6","title":"Introducci\u00f3n a los bloques l\u00f3gicos. Uso de sensores de infrarrojos."},{"location":"masayloBlockly/sensoresIR/#introduccion-a-los-bloques-logicos-uso-de-sensores-de-infrarrojos","text":"Pasamos a continuaci\u00f3n a familiarizarnos con el uso de los sensores de infrarrojos FC-51 , que pueden funcionar como sensores de obst\u00e1culos a peque\u00f1as distancias o, como es el caso de Masaylo, para discriminar el color negro del blanco, lo que permite la creaci\u00f3n de robots siguel\u00edneas. En esta pr\u00e1ctica aprenderemos a inicializar los sensores de infrarrojos, tambi\u00e9n llamados IR, de Masaylo y utilizarlos para indicar si el robot detecta blanco o negro tanto a su derecha como a su izquierda a medida que \u00e9ste avanza. Esta informaci\u00f3n se procesar\u00e1 y se ofrecer\u00e1 al usuario a trav\u00e9s del monitor del puerto serie, al estilo de la pr\u00e1ctica anterior con el sensor de ultrasonidos. Pr\u00e1ctica: lectura de sensores de infrarrojos a trav\u00e9s del puerto serie","title":"Introducci\u00f3n a los bloques l\u00f3gicos. Uso de sensores de infrarrojos"},{"location":"masayloBlockly/sensoresIR/#presentacion-de-nuevos-bloques-uso-de-la-logica-en-programacion-bloques-sisi-no","text":"Para utilizar los sensores de infrarrojos en MasayloBlockly, seguimos la misma filosof\u00eda de trabajo que con el sensor de ultrasonidos: inicializar ambos sensores y recoger su lectura, aunque en este caso el abanico de piezas es algo m\u00e1s amplio: Icono Funci\u00f3n Inicializar los sensores IR indicando sus pines a izquierda y derecha Devuelve verdadero si pisa negro por la izquierda, y falso si pisa blanco Devuelve verdadero si pisa negro por la derecha, y falso si pisa blanco Devuelve verdadero si pisa blanco por la izquierda, y falso si pisa negro Devuelve verdadero si pisa blanco por la derecha, y falso si pisa negro Pero lo realmente importante en esta secci\u00f3n, es que por primera vez vamos a presentar de modo espec\u00edfico el trabajo con bloques l\u00f3gicos, que si bien han aparecido ya en alg\u00fan ejemplo de ampliaci\u00f3n, no han sido a\u00fan tratados con cierta rigurosidad. Dichos bloques est\u00e1n agrupados en la opci\u00f3n **L\u00f3gica ** de la zona de bloques de opciones. Como creemos sinceramente en el concepto del aprendizaje significativo, en esta ocasi\u00f3n s\u00f3lo vamos a trabajar con dos de los bloques de esta agrupaci\u00f3n, que permitir\u00e1n al lector comprender su papel en programaci\u00f3n a trav\u00e9s de su uso en esta pr\u00e1ctica: Icono Funci\u00f3n Bloque de control de flujo SI (si se cumple la condici\u00f3n, se ejecutar\u00e1 el bloque de comandos que se introduzca dentro de este bloque) Compara dos elementos y devuelve verdadero si la condici\u00f3n de comparaci\u00f3n se cumple (A y B, A o B, etc...) El bloque SI, como algunas otras piezas disponibles en MasayloBlockly, incluye un peque\u00f1o icono azul de un engranaje en su parte superior izquierda que permite personalizarlo y a\u00f1adirle funcionalidades (en el caso de la imagen, podemos crear bloques SI/SI NO, SI/DE LO CONTRARIO SI, etc...). Algunos bloques incluyen un peque\u00f1o icono de personalizaci\u00f3n para complementar su significado","title":"Presentaci\u00f3n de nuevos bloques. Uso de la l\u00f3gica en programaci\u00f3n. Bloques si/si no"},{"location":"masayloBlockly/sensoresIR/#objetivos-de-la-practica","text":"Nuestro programa deber\u00e1 cumplir los siguientes objetivos: Inicializar el puerto serie del robot Masaylo estableciendo una velocidad est\u00e1ndar (9600 baudios). Inicializar el robot Masaylo indicando, en su caso, los pines de control de motores. Inicializar los sensores de infrarrojos, indicando la patilla a que est\u00e1n conectados (por defecto, los pines anal\u00f3gicos A0 y A1). Realizar la lectura de ambos sensores. Pasar el estado de ambos sensores por el puerto serie. Si ambos est\u00e1n en negro, lanzaremos el mensaje \"Lado oscuro de la fuerza\". Si ambos est\u00e1n en blanco, el mensaje ser\u00e1 \"La fuerza est\u00e1 en t\u00ed\" (un gui\u00f1o del programador a los lectores boomer). Esperar un segundo y repetir el bucle. Como el usuario pronto comprobar\u00e1, la personalizaci\u00f3n del bloque l\u00f3gico SI nos facilitar\u00e1 mucho el trabajo. Pr\u00e1ctica: lectura de distancias a trav\u00e9s del puerto serie","title":"Objetivos de la pr\u00e1ctica"},{"location":"masayloBlockly/sensoresIR/#programa-comprobacion-de-sensores-ir-a-traves-del-puerto-serie","text":"Presentamos a continuaci\u00f3n la soluci\u00f3n a la pr\u00e1ctica propuesta( Nota: este programa est\u00e1 disponible en el bot\u00f3n de Ejemplos del men\u00fa principal, con el t\u00edtulo \"Env\u00eda al puerto serie de tu ordenador la medici\u00f3n (blanco/negro) de tus sensores IR\"). Programa: env\u00edo de la informaci\u00f3n de los sensores IR al puerto serie","title":"Programa: comprobaci\u00f3n de sensores IR a trav\u00e9s del puerto serie"},{"location":"masayloBlockly/sensoresIR/#ejercicio-de-ampliacion-programar-un-robot-siguelineas","text":"La programaci\u00f3n de siguel\u00edneas (normalmente, una l\u00ednea negra sobre un fondo blanco) es un cl\u00e1sico en la pedagog\u00eda de la Rob\u00f3tica Educativa. El uso de motores DC como los de Masaylo, baratos y accesibles de muy dif\u00edcil control, complica bastante esta tarea. No obstante, presentamos a continuaci\u00f3n una propuesta que puede suponer un buen punto de partida. Dependiendo de las distintas condiciones del circuito y del propio robot, ser\u00e1 seguramente necesario adaptarla a dichas circunstancias, moderando las velocidades propuestas. Ejercicio de ampliaci\u00f3n: Masaylo siguel\u00edneas","title":"Ejercicio de ampliaci\u00f3n: programar un robot siguel\u00edneas"},{"location":"masayloBlockly/sensoresIR/#video-explicativo-uso-del-puerto-serie-para-leer-sensores-de-infrarrojos","text":"","title":"V\u00eddeo explicativo: uso del puerto serie para leer sensores de infrarrojos"},{"location":"masayloBlockly/servos/","text":"Uso de servomotores en brazo y cabeza \u00b6 Como se suele decir en ingl\u00e9s, \"last but no least\", por \u00faltimo, pero no por ello menos importante, Masaylo nos ofrece tambi\u00e9n la opci\u00f3n de utilizar servomotores de posici\u00f3n de modelo SG-90 o similar que permiten el movimiento angular, si as\u00ed lo deseamos, del sensor de ultrasonidos (aunque tambi\u00e9n se nos ofrece la opci\u00f3n de dejarlo fijo) y de un brazo auxiliar que posibilitar\u00eda la captura y/o desplazamiento de peque\u00f1os obst\u00e1culos. Masaylo puede incorporar dos servomotores que agreguen movilidad a algunas partes Inicializaci\u00f3n y uso de los servomotores \u00b6 En MasayloBlockly podemos encontrar las siguientes piezas de programaci\u00f3n para controlar estos servomotores: Icono Funci\u00f3n Inicializar los servomotores indicando sus pines para cabeza (sensor de US) y brazo. Si no se va a respetar el conexionado por defecto, es aconsejable utilizar patillas con PWM Indicar el \u00e1ngulo al que queremos girar el sensor de ultrasonidos. 90 \u00ba constituye la posici\u00f3n central Cuando Masaylo est\u00e1 en marcha hacia adelante, espera a haber avanzado la distancia indicada antes de pasar a la siguiente orden Indicar el \u00e1ngulo al que queremos girar el brazo auxiliar. 90 \u00ba constituye la posici\u00f3n central Objetivos de la pr\u00e1ctica \u00b6 Limit\u00e9monos en esta ocasi\u00f3n a probar el servomotor del cabezal del sensor de ultrasonidos (el brazo auxiliar obedecer\u00eda exactamente del mismo modo) de acuerdo a la siguiente pauta: Inicializar el robot Masaylo. Inicializar ambos servos, especificando el pin al que va conectado cada uno. Partiendo de 10 \u00ba, realizar el giro hasta una posici\u00f3n de 170 \u00ba, con variaciones de 10 \u00ba a cada cambio Invertir el proceso y girar progresivamente de 170 \u00ba a 10 \u00ba Repetici\u00f3n del bucle M\u00e1s bloques l\u00f3gicos: repetir hasta que y repetir por intervalos . Trabajo con variables \u00b6 Seguimos aprovechando para enriquecer nuestro acervo de comandos l\u00f3gicos, tan necesarios en programaci\u00f3n. En esta ocasi\u00f3n, utilizaremos dos nuevas piezas que permiten la repetici\u00f3n en bucle de conjuntos de \u00f3rdenes conforme al cumplimiento de determinadas condiciones. Adem\u00e1s, aunque no es necesario para este programa, utilizaremos variables por primera vez: Icono Funci\u00f3n Esta pieza nos permite insertar en su seno un conjunto de \u00f3rdenes que se repetir\u00e1n MIENTRAS SE EST\u00c9 CUMPLIENDO LA CONDICI\u00d3N QUE ESTIPULEMOS De comprensi\u00f3n algo m\u00e1s compleja, pero de suma utilidad para el programador, esta pieza cuenta con una variable a la que dar un valor inicial , un valor final y un valor de variaci\u00f3n . Los comandos que albergue en su interior se ir\u00e1n repitiendo en bucle mientras dicha variable se encuentre entre su valor inicial y su final, a\u00f1adi\u00e9ndole el valor de variaci\u00f3n a cada finalizaci\u00f3n del bucle. Permite crear algoritmos que repiten ciertas secuencias que se repiten progresivamente con ligeros cambios asociados a dicha variable Aunque no es el objetivo de estas l\u00edneas hacer un estudio exhaustivo de todas las caracter\u00edsticas de cualquier lenguaje de programaci\u00f3n, no est\u00e1 de m\u00e1s saber que es com\u00fan trabajar con variables. A este respecto, MasayloBlockly tambi\u00e9n presenta su correspondiente bloque de opciones que empieza con el bot\u00f3n Crear variable (indicar su nombre en la ventana emergente que aparecer\u00e1) para a continuaci\u00f3n ampliar el abanico a las siguientes posibilidades: Men\u00fa de trabajo con variables en MasayloBlockly Programa: giro progresivo a izquierda y derecha \u00b6 La imagen siguiente presenta la soluci\u00f3n a la pr\u00e1ctica propuesta( Nota: este programa est\u00e1 disponible en el bot\u00f3n de Ejemplos del men\u00fa principal, con el t\u00edtulo \"Gira el cabezal del sensor de ultrasonidos\"). Conviene aclarar dos cosas: En condiciones normales, en los bucles que ata\u00f1en a los movimientos de servomotores, se debe establecer un intervalo m\u00ednimo de pausa para no da\u00f1ar el motor. La librer\u00eda de Masaylo los incluye ya de serie, por lo que no es necesario, pero en otros robots esto debe ser tenido en cuenta. No es necesario el uso de variables en la segunda parte del programa (habr\u00eda bastado volver a utilizar una pieza Repetir por intervalos ) Pr\u00e1ctica: giro del cabezal del sensor de US V\u00eddeo explicativo: control de los servomotores de Masaylo \u00b6","title":"Uso de servomotores en brazo y cabeza"},{"location":"masayloBlockly/servos/#uso-de-servomotores-en-brazo-y-cabeza","text":"Como se suele decir en ingl\u00e9s, \"last but no least\", por \u00faltimo, pero no por ello menos importante, Masaylo nos ofrece tambi\u00e9n la opci\u00f3n de utilizar servomotores de posici\u00f3n de modelo SG-90 o similar que permiten el movimiento angular, si as\u00ed lo deseamos, del sensor de ultrasonidos (aunque tambi\u00e9n se nos ofrece la opci\u00f3n de dejarlo fijo) y de un brazo auxiliar que posibilitar\u00eda la captura y/o desplazamiento de peque\u00f1os obst\u00e1culos. Masaylo puede incorporar dos servomotores que agreguen movilidad a algunas partes","title":"Uso de servomotores en brazo y cabeza"},{"location":"masayloBlockly/servos/#inicializacion-y-uso-de-los-servomotores","text":"En MasayloBlockly podemos encontrar las siguientes piezas de programaci\u00f3n para controlar estos servomotores: Icono Funci\u00f3n Inicializar los servomotores indicando sus pines para cabeza (sensor de US) y brazo. Si no se va a respetar el conexionado por defecto, es aconsejable utilizar patillas con PWM Indicar el \u00e1ngulo al que queremos girar el sensor de ultrasonidos. 90 \u00ba constituye la posici\u00f3n central Cuando Masaylo est\u00e1 en marcha hacia adelante, espera a haber avanzado la distancia indicada antes de pasar a la siguiente orden Indicar el \u00e1ngulo al que queremos girar el brazo auxiliar. 90 \u00ba constituye la posici\u00f3n central","title":"Inicializaci\u00f3n y uso de los servomotores"},{"location":"masayloBlockly/servos/#objetivos-de-la-practica","text":"Limit\u00e9monos en esta ocasi\u00f3n a probar el servomotor del cabezal del sensor de ultrasonidos (el brazo auxiliar obedecer\u00eda exactamente del mismo modo) de acuerdo a la siguiente pauta: Inicializar el robot Masaylo. Inicializar ambos servos, especificando el pin al que va conectado cada uno. Partiendo de 10 \u00ba, realizar el giro hasta una posici\u00f3n de 170 \u00ba, con variaciones de 10 \u00ba a cada cambio Invertir el proceso y girar progresivamente de 170 \u00ba a 10 \u00ba Repetici\u00f3n del bucle","title":"Objetivos de la pr\u00e1ctica"},{"location":"masayloBlockly/servos/#mas-bloques-logicos-repetir-hasta-que-y-repetir-por-intervalos-trabajo-con-variables","text":"Seguimos aprovechando para enriquecer nuestro acervo de comandos l\u00f3gicos, tan necesarios en programaci\u00f3n. En esta ocasi\u00f3n, utilizaremos dos nuevas piezas que permiten la repetici\u00f3n en bucle de conjuntos de \u00f3rdenes conforme al cumplimiento de determinadas condiciones. Adem\u00e1s, aunque no es necesario para este programa, utilizaremos variables por primera vez: Icono Funci\u00f3n Esta pieza nos permite insertar en su seno un conjunto de \u00f3rdenes que se repetir\u00e1n MIENTRAS SE EST\u00c9 CUMPLIENDO LA CONDICI\u00d3N QUE ESTIPULEMOS De comprensi\u00f3n algo m\u00e1s compleja, pero de suma utilidad para el programador, esta pieza cuenta con una variable a la que dar un valor inicial , un valor final y un valor de variaci\u00f3n . Los comandos que albergue en su interior se ir\u00e1n repitiendo en bucle mientras dicha variable se encuentre entre su valor inicial y su final, a\u00f1adi\u00e9ndole el valor de variaci\u00f3n a cada finalizaci\u00f3n del bucle. Permite crear algoritmos que repiten ciertas secuencias que se repiten progresivamente con ligeros cambios asociados a dicha variable Aunque no es el objetivo de estas l\u00edneas hacer un estudio exhaustivo de todas las caracter\u00edsticas de cualquier lenguaje de programaci\u00f3n, no est\u00e1 de m\u00e1s saber que es com\u00fan trabajar con variables. A este respecto, MasayloBlockly tambi\u00e9n presenta su correspondiente bloque de opciones que empieza con el bot\u00f3n Crear variable (indicar su nombre en la ventana emergente que aparecer\u00e1) para a continuaci\u00f3n ampliar el abanico a las siguientes posibilidades: Men\u00fa de trabajo con variables en MasayloBlockly","title":"M\u00e1s bloques l\u00f3gicos: repetir hasta que y repetir por intervalos . Trabajo con variables"},{"location":"masayloBlockly/servos/#programa-giro-progresivo-a-izquierda-y-derecha","text":"La imagen siguiente presenta la soluci\u00f3n a la pr\u00e1ctica propuesta( Nota: este programa est\u00e1 disponible en el bot\u00f3n de Ejemplos del men\u00fa principal, con el t\u00edtulo \"Gira el cabezal del sensor de ultrasonidos\"). Conviene aclarar dos cosas: En condiciones normales, en los bucles que ata\u00f1en a los movimientos de servomotores, se debe establecer un intervalo m\u00ednimo de pausa para no da\u00f1ar el motor. La librer\u00eda de Masaylo los incluye ya de serie, por lo que no es necesario, pero en otros robots esto debe ser tenido en cuenta. No es necesario el uso de variables en la segunda parte del programa (habr\u00eda bastado volver a utilizar una pieza Repetir por intervalos ) Pr\u00e1ctica: giro del cabezal del sensor de US","title":" Programa: giro progresivo a izquierda y derecha "},{"location":"masayloBlockly/servos/#video-explicativo-control-de-los-servomotores-de-masaylo","text":"","title":"V\u00eddeo explicativo: control de los servomotores de Masaylo"},{"location":"presentaciones/medios/","text":"Apariciones en medios de comunicaci\u00f3n \u00b6 Entrevista realizada por Onda Cero a Antonio: Elemento de audio no soportado por tu navegador. Publicado art\u00edculo en la revista digital EducarCLM: Enlace al art\u00edculo","title":"Apariciones en medios de comunicaci\u00f3n"},{"location":"presentaciones/medios/#apariciones-en-medios-de-comunicacion","text":"Entrevista realizada por Onda Cero a Antonio: Elemento de audio no soportado por tu navegador. Publicado art\u00edculo en la revista digital EducarCLM: Enlace al art\u00edculo","title":"Apariciones en medios de comunicaci\u00f3n"},{"location":"presentaciones/presentacion1/","text":"Primera presentaci\u00f3n de MASAYLO-CRG en sociedad \u00b6 Masaylo, el robot educativo Open Source nacido en Ciudad Real La tarde del pr\u00f3ximo viernes 26 de noviembre de 2021 el IES Maestro Juan de \u00c1vila de Ciudad Real albergar\u00e1 la presentaci\u00f3n oficial a la comunidad educativa del robot Masaylo a cargo de D. Federico Coca y D. Manuel Hidalgo, colaboradores del Parque de las Ciencias de Granada, invitados por el profesor Antonio G\u00f3mez. \u00bfQu\u00e9 es Masaylo? \u00b6 Masaylo es un robot impreso en 3D de car\u00e1cter Open Source basado en el uso de la tarjeta microcontroladora Arduino, pieza central de las actividades de programaci\u00f3n en la materia de Tecnolog\u00eda Rob\u00f3tica que se imparte en 4\u00ba de ESO en los centros p\u00fablicos castellano-manchegos. Dicho robot fue dise\u00f1ado originalmente por los profesores del IES Maestro Juan de \u00c1vila de Ciudad Real Antonio G\u00f3mez y M.\u00aa Dolores Nogueras, aunque ahora es el centro de un proyecto en el que colaboran profesores y expertos de la comunidad maker de varias ciudades de Castilla la Mancha y Andaluc\u00eda. Masaylo es un robot de car\u00e1cter modular concebido para su uso en varias materias de Educaci\u00f3n Secundaria, pero tambi\u00e9n de Educaci\u00f3n Primaria. El profesor puede construir varias modalidades de este sistema, dependiendo de su experiencia previa y la complejidad de las actividades que desee desarrollar en el aula. Su dise\u00f1o se centr\u00f3 desde el principio en ofrecer un montaje sencillo para el profesor o el alumno inexperto, as\u00ed como escasas exigencias econ\u00f3micas, al ser montable en su mayor parte con materiales ya existentes normalmente en cualquier Aula-Taller de Tecnolog\u00eda. \u00bfQu\u00e9 significa Open Source? \u00b6 El t\u00e9rmino Open Source (\u201cFuente abierta\u201d, en castellano), es una filosof\u00eda basada en compartir dise\u00f1os, programas y montajes mediante una colaboraci\u00f3n abierta. El movimiento Open Source sostiene que todo el mundo deber\u00eda tener libre acceso al conocimiento, que al compartirse se extiende y enriquece m\u00e1s f\u00e1cilmente. Dentro de su concepci\u00f3n Open Source, todo lo que tiene que ver con Masaylo (dise\u00f1o, fuentes para imprimir en 3D, instrucciones de montaje, programas\u2026) se pone a disposici\u00f3n de profesores, alumnos y cualquier aficionado interesado en la Rob\u00f3tica para que puedan, no s\u00f3lo aprender, sino modificar, compartir y distribuir todo lo relacionado con la Rob\u00f3tica a nivel de Educaci\u00f3n Secundaria. El grupo de expertos maker que est\u00e1 detr\u00e1s de este simp\u00e1tico robot mantiene de forma totalmente altruista toda una plataforma que incluye, por un lado, los ficheros que permiten construir todas las piezas utilizando una impresora 3D, como sus fuentes (los archivos de dise\u00f1o originales que permiten realizar modificaciones a cada pieza), las bibliotecas de programaci\u00f3n e incluso un entorno de desarrollo basado en el juego con piezas de tipo<FONT COLOencia de Ciudad Real. Este tipo de actividades implican la colaboraci\u00f3n de alumnos de 4\u00ba de ESO con experiencia previa en programaci\u00f3n, que act\u00faan como monitores de los ni\u00f1os m\u00e1s peque\u00f1os que acuden a estas actividades, ense\u00f1\u00e1ndoles a programar y experimentar con distintas magnitudes f\u00edsicas utilizando robots como Masaylo. Esta concepci\u00f3n asegura un aprendizaje significativo tanto en los j\u00f3venes como en los ni\u00f1os, al basarse en el descubrimiento y la experimentaci\u00f3n, adem\u00e1s del alto grado de motivaci\u00f3n que presenta. Masaylo ha participado tambi\u00e9n ya un par de veces en algunos talleres coordinados por el IES Maestro Juan de \u00c1vila que se celebran en el Aula Hospitalaria del HGUCR, actividades \u00e9stas que permiten a los ni\u00f1os y ni\u00f1as ingresados disfrutar por una tarde de actividades de formaci\u00f3n y aprendizaje utilizando, de nuevo, el juego y el descubrimiento como herramientas. En la actualidad se est\u00e1n dise\u00f1ando tambi\u00e9n propuestas de formaci\u00f3n para profesores de Educaci\u00f3n Primaria interesados en proyectos STEAM que les permitiera crear sus propias actividades para sus respectivos grupos clase con autonom\u00eda y seguridad. Club Rob\u00f3tica Granada: papel del Parque de las Ciencias en el proyecto \u00b6 Si bien Masaylo es de factura original ciudadrreale\u00f1a, varios integrantes del Club Rob\u00f3tica Granada, entidad fuertemente vinculada al Parque de las Ciencias de esta misma ciudad llevan m\u00e1s de un a\u00f1o participando muy activamente en el continuo redise\u00f1o y mejora de este robot desde el punto de vista de la comunidad educativa. Papel particularmente activo e importante en las actuales expectativas del proyecto tienen los dos ponentes de la presentaci\u00f3n, D. Federico Coca y D. Manuel Hidalgo, viejos conocidos del mundillo maker y referencias de la rob\u00f3tica educativa a nivel nacional, as\u00ed como otros profesores igualmente respetados en el \u00e1mbito de la educaci\u00f3n y la impresi\u00f3n 3D, como D. Pedro Ruiz o D. Prudencio Luna. El Club Rob\u00f3tica Granada no s\u00f3lo est\u00e1 teniendo un importante papel en el dise\u00f1o y desarrollo de este robot, sino que tambi\u00e9n impulsa de forma muy activa el reconocimiento del proyecto en el \u00e1mbito educativo andaluz. Masaylo se ha presentado como alternativa introductoria a la programaci\u00f3n en la Escuela T\u00e9cnica Superior de Ingenier\u00edas Inform\u00e1tica y de Telecomunicaci\u00f3n de la Universidad de Granada (ETSIIT) y en un futuro pr\u00f3ximo se realizar\u00e1 una presentaci\u00f3n oficial previa en Granada a la comunidad maker andaluza. Ceremonia de presentaci\u00f3n \u00b6 La ceremonia de presentaci\u00f3n se realizar\u00e1 el pr\u00f3ximo viernes 26 de abril, a las 17\u201930 h en el Sal\u00f3n de Actos del IES Maestro Juan de \u00c1vila de Ciudad Real y con la colaboraci\u00f3n de la Casa de la Ciencia de Ciudad Real.Actuar\u00e1n como ponentes los desarrolladores de Masaylo D. Antonio G\u00f3mez, D. Federico Coca y D. Manuel Hidalgo. Al final de la ceremonia, la Casa de la Ciencia donar\u00e1 un robot Masaylo al Aula Hospitalaria del Hospital General Universitario de Ciudad Real. Video de presentaci\u00f3n \u00b6 A continuaci\u00f3n puedes el video de presentaci\u00f3n realizado por Antonio:","title":"Primera presentaci\u00f3n"},{"location":"presentaciones/presentacion1/#primera-presentacion-de-masaylo-crg-en-sociedad","text":"Masaylo, el robot educativo Open Source nacido en Ciudad Real La tarde del pr\u00f3ximo viernes 26 de noviembre de 2021 el IES Maestro Juan de \u00c1vila de Ciudad Real albergar\u00e1 la presentaci\u00f3n oficial a la comunidad educativa del robot Masaylo a cargo de D. Federico Coca y D. Manuel Hidalgo, colaboradores del Parque de las Ciencias de Granada, invitados por el profesor Antonio G\u00f3mez.","title":"Primera presentaci\u00f3n de MASAYLO-CRG en sociedad"},{"location":"presentaciones/presentacion1/#que-es-masaylo","text":"Masaylo es un robot impreso en 3D de car\u00e1cter Open Source basado en el uso de la tarjeta microcontroladora Arduino, pieza central de las actividades de programaci\u00f3n en la materia de Tecnolog\u00eda Rob\u00f3tica que se imparte en 4\u00ba de ESO en los centros p\u00fablicos castellano-manchegos. Dicho robot fue dise\u00f1ado originalmente por los profesores del IES Maestro Juan de \u00c1vila de Ciudad Real Antonio G\u00f3mez y M.\u00aa Dolores Nogueras, aunque ahora es el centro de un proyecto en el que colaboran profesores y expertos de la comunidad maker de varias ciudades de Castilla la Mancha y Andaluc\u00eda. Masaylo es un robot de car\u00e1cter modular concebido para su uso en varias materias de Educaci\u00f3n Secundaria, pero tambi\u00e9n de Educaci\u00f3n Primaria. El profesor puede construir varias modalidades de este sistema, dependiendo de su experiencia previa y la complejidad de las actividades que desee desarrollar en el aula. Su dise\u00f1o se centr\u00f3 desde el principio en ofrecer un montaje sencillo para el profesor o el alumno inexperto, as\u00ed como escasas exigencias econ\u00f3micas, al ser montable en su mayor parte con materiales ya existentes normalmente en cualquier Aula-Taller de Tecnolog\u00eda.","title":"\u00bfQu\u00e9 es Masaylo?"},{"location":"presentaciones/presentacion1/#que-significa-open-source","text":"El t\u00e9rmino Open Source (\u201cFuente abierta\u201d, en castellano), es una filosof\u00eda basada en compartir dise\u00f1os, programas y montajes mediante una colaboraci\u00f3n abierta. El movimiento Open Source sostiene que todo el mundo deber\u00eda tener libre acceso al conocimiento, que al compartirse se extiende y enriquece m\u00e1s f\u00e1cilmente. Dentro de su concepci\u00f3n Open Source, todo lo que tiene que ver con Masaylo (dise\u00f1o, fuentes para imprimir en 3D, instrucciones de montaje, programas\u2026) se pone a disposici\u00f3n de profesores, alumnos y cualquier aficionado interesado en la Rob\u00f3tica para que puedan, no s\u00f3lo aprender, sino modificar, compartir y distribuir todo lo relacionado con la Rob\u00f3tica a nivel de Educaci\u00f3n Secundaria. El grupo de expertos maker que est\u00e1 detr\u00e1s de este simp\u00e1tico robot mantiene de forma totalmente altruista toda una plataforma que incluye, por un lado, los ficheros que permiten construir todas las piezas utilizando una impresora 3D, como sus fuentes (los archivos de dise\u00f1o originales que permiten realizar modificaciones a cada pieza), las bibliotecas de programaci\u00f3n e incluso un entorno de desarrollo basado en el juego con piezas de tipo<FONT COLOencia de Ciudad Real. Este tipo de actividades implican la colaboraci\u00f3n de alumnos de 4\u00ba de ESO con experiencia previa en programaci\u00f3n, que act\u00faan como monitores de los ni\u00f1os m\u00e1s peque\u00f1os que acuden a estas actividades, ense\u00f1\u00e1ndoles a programar y experimentar con distintas magnitudes f\u00edsicas utilizando robots como Masaylo. Esta concepci\u00f3n asegura un aprendizaje significativo tanto en los j\u00f3venes como en los ni\u00f1os, al basarse en el descubrimiento y la experimentaci\u00f3n, adem\u00e1s del alto grado de motivaci\u00f3n que presenta. Masaylo ha participado tambi\u00e9n ya un par de veces en algunos talleres coordinados por el IES Maestro Juan de \u00c1vila que se celebran en el Aula Hospitalaria del HGUCR, actividades \u00e9stas que permiten a los ni\u00f1os y ni\u00f1as ingresados disfrutar por una tarde de actividades de formaci\u00f3n y aprendizaje utilizando, de nuevo, el juego y el descubrimiento como herramientas. En la actualidad se est\u00e1n dise\u00f1ando tambi\u00e9n propuestas de formaci\u00f3n para profesores de Educaci\u00f3n Primaria interesados en proyectos STEAM que les permitiera crear sus propias actividades para sus respectivos grupos clase con autonom\u00eda y seguridad.","title":"\u00bfQu\u00e9 significa Open Source?"},{"location":"presentaciones/presentacion1/#club-robotica-granada-papel-del-parque-de-las-ciencias-en-el-proyecto","text":"Si bien Masaylo es de factura original ciudadrreale\u00f1a, varios integrantes del Club Rob\u00f3tica Granada, entidad fuertemente vinculada al Parque de las Ciencias de esta misma ciudad llevan m\u00e1s de un a\u00f1o participando muy activamente en el continuo redise\u00f1o y mejora de este robot desde el punto de vista de la comunidad educativa. Papel particularmente activo e importante en las actuales expectativas del proyecto tienen los dos ponentes de la presentaci\u00f3n, D. Federico Coca y D. Manuel Hidalgo, viejos conocidos del mundillo maker y referencias de la rob\u00f3tica educativa a nivel nacional, as\u00ed como otros profesores igualmente respetados en el \u00e1mbito de la educaci\u00f3n y la impresi\u00f3n 3D, como D. Pedro Ruiz o D. Prudencio Luna. El Club Rob\u00f3tica Granada no s\u00f3lo est\u00e1 teniendo un importante papel en el dise\u00f1o y desarrollo de este robot, sino que tambi\u00e9n impulsa de forma muy activa el reconocimiento del proyecto en el \u00e1mbito educativo andaluz. Masaylo se ha presentado como alternativa introductoria a la programaci\u00f3n en la Escuela T\u00e9cnica Superior de Ingenier\u00edas Inform\u00e1tica y de Telecomunicaci\u00f3n de la Universidad de Granada (ETSIIT) y en un futuro pr\u00f3ximo se realizar\u00e1 una presentaci\u00f3n oficial previa en Granada a la comunidad maker andaluza.","title":"Club Rob\u00f3tica Granada: papel del Parque de las Ciencias en el proyecto"},{"location":"presentaciones/presentacion1/#ceremonia-de-presentacion","text":"La ceremonia de presentaci\u00f3n se realizar\u00e1 el pr\u00f3ximo viernes 26 de abril, a las 17\u201930 h en el Sal\u00f3n de Actos del IES Maestro Juan de \u00c1vila de Ciudad Real y con la colaboraci\u00f3n de la Casa de la Ciencia de Ciudad Real.Actuar\u00e1n como ponentes los desarrolladores de Masaylo D. Antonio G\u00f3mez, D. Federico Coca y D. Manuel Hidalgo. Al final de la ceremonia, la Casa de la Ciencia donar\u00e1 un robot Masaylo al Aula Hospitalaria del Hospital General Universitario de Ciudad Real.","title":"Ceremonia de presentaci\u00f3n"},{"location":"presentaciones/presentacion1/#video-de-presentacion","text":"A continuaci\u00f3n puedes el video de presentaci\u00f3n realizado por Antonio:","title":"Video de presentaci\u00f3n"}]}
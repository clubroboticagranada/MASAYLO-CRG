{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"MASAYLO - CRG \u00b6 MASAYLO-CRG es un robot creado a partir de la idea de Antonio G\u00f3mez ( https://github.com/agomezgar/masaylo ) del que se van a desarrollar las tres versiones que se exponen a continuaci\u00f3n MASAYLO-CRG-UNO \u00b6 Esta versi\u00f3n, basada en la placa Keyestudio UNO est\u00e1 pensada para que el alumnado de los \u00faltimos cursos de primaria y los del primer ciclo de ESO trabajen los temas STEAM. En la imagen siguiente vemos el aspecto que presenta el robot MASAYLO-CRG-UNO en fase de dise\u00f1o. La programaci\u00f3n de este modelo la podemos realizar a partir del IDE de Arduino (instalando la librer\u00eda correspondiente) o a partir del entorno gr\u00e1fico MASAYLOBLOCKLY. Aspecto general de MASAYLO-CRG-UNO MASAYLO-CRG-NANO \u00b6 Se trata de un modelo totalmente similar al anterior pero que en esta ocasi\u00f3n va a utilizar una placa tipo Arduino Nano con una shield que permite tambi\u00e9n disponer de pines de conexionado r\u00e1pido. En la imagen de la izquierda vemos la placa y en la de la derecha la shield. El aspecto del robot una vez montado es totalmente similar al de la imagen anterior con la salvedad del cambio de placa. Aspecto placa Nano Aspecto de la shield para placa Nano MASAYLO-CRG-IoT \u00b6 En este caso el modelo se implementa a partir de una placa Node MCU ESP32 con shield que incluye los drivers para motores. Este modelo se dirige a los \u00faltimos cursos de ESO, bachillerato y Ciclos Formativos y su principal objetivo, sin dejar atr\u00e1s la sencillez del robot, es trabajar, adem\u00e1s de los temas STEAM, el Internet Of Thing (IoT) o internet de las cosas. B\u00e1sicamente el robot va dotado de conexi\u00f3n WiFi con todo lo que ello conlleva. La idea principal es poder programarlo a partir de un entorno de programaci\u00f3n por bloques, poder desarrollar APPs para m\u00f3viles o tablets para su control a partir de un entorno gr\u00e1fico como Blocky, montando nuestro propio servidor para tal fin. Otro objetivo de este robot es poder realizar colaboraciones a distancia consistentes en, por ejemplo, ejercer el control de un robot situado en cualquier parte del mundo desde el lugar en el que el alumnado est\u00e1 trabajando con la APP. En la imagen siguiente a la izquierda vemos el aspecto de la placa ESP32 y a la derecha el de la shield. El aspecto del robot una vez montado es totalmente similar al montado para la versi\u00f3n UNO con la salvedad del cambio de placa y que el driver de motores est\u00e1 integrado en la shield. Aspecto placa Node MCU ESP32 de 30 pines Aspecto de la shield para placa ESP32 El prop\u00f3sito principal es que sea un robot sencillo de imprimir y de construir y que pueda servir para iniciar en el tema STEAM al alumnado desde los \u00faltimos cursos de educaci\u00f3n primaria hasta bachillerato y ciclos formativos pasando por las distintas etapas de la ESO. Se ha pretendido que los dise\u00f1os 3D sean f\u00e1cilmente imprimibles, sin necesidad de soportes y aconsejamos una altura de capa de 0.2mm. Se ha procurado que los tiempos de impresi\u00f3n sean lo m\u00e1s cortos posible pero al mismo tiempo vers\u00e1tiles para las posibles diferencias entre las distintas placas a utilizar. En el apartado de descripci\u00f3n del hardware se pondr\u00e1n algunos enlaces recomendados para adquisici\u00f3n del material aunque, como no pod\u00eda ser de otra manera, cada quien lo puede adquirir donde mejor le parezca. Cualquiera de los modelos puede ser utilizado para otra etapa formativa u objetivo y lo podremos adaptar a nuestras necesidades, siendo esto posible porque se suministran los archivos fuente de dise\u00f1o y programaci\u00f3n y para ello solamente tenemos que cumplir con los requisitos establecidos en las licencias .","title":"Introducci\u00f3n"},{"location":"#masaylo-crg","text":"MASAYLO-CRG es un robot creado a partir de la idea de Antonio G\u00f3mez ( https://github.com/agomezgar/masaylo ) del que se van a desarrollar las tres versiones que se exponen a continuaci\u00f3n","title":"MASAYLO - CRG"},{"location":"#masaylo-crg-uno","text":"Esta versi\u00f3n, basada en la placa Keyestudio UNO est\u00e1 pensada para que el alumnado de los \u00faltimos cursos de primaria y los del primer ciclo de ESO trabajen los temas STEAM. En la imagen siguiente vemos el aspecto que presenta el robot MASAYLO-CRG-UNO en fase de dise\u00f1o. La programaci\u00f3n de este modelo la podemos realizar a partir del IDE de Arduino (instalando la librer\u00eda correspondiente) o a partir del entorno gr\u00e1fico MASAYLOBLOCKLY. Aspecto general de MASAYLO-CRG-UNO","title":"MASAYLO-CRG-UNO"},{"location":"#masaylo-crg-nano","text":"Se trata de un modelo totalmente similar al anterior pero que en esta ocasi\u00f3n va a utilizar una placa tipo Arduino Nano con una shield que permite tambi\u00e9n disponer de pines de conexionado r\u00e1pido. En la imagen de la izquierda vemos la placa y en la de la derecha la shield. El aspecto del robot una vez montado es totalmente similar al de la imagen anterior con la salvedad del cambio de placa. Aspecto placa Nano Aspecto de la shield para placa Nano","title":"MASAYLO-CRG-NANO"},{"location":"#masaylo-crg-iot","text":"En este caso el modelo se implementa a partir de una placa Node MCU ESP32 con shield que incluye los drivers para motores. Este modelo se dirige a los \u00faltimos cursos de ESO, bachillerato y Ciclos Formativos y su principal objetivo, sin dejar atr\u00e1s la sencillez del robot, es trabajar, adem\u00e1s de los temas STEAM, el Internet Of Thing (IoT) o internet de las cosas. B\u00e1sicamente el robot va dotado de conexi\u00f3n WiFi con todo lo que ello conlleva. La idea principal es poder programarlo a partir de un entorno de programaci\u00f3n por bloques, poder desarrollar APPs para m\u00f3viles o tablets para su control a partir de un entorno gr\u00e1fico como Blocky, montando nuestro propio servidor para tal fin. Otro objetivo de este robot es poder realizar colaboraciones a distancia consistentes en, por ejemplo, ejercer el control de un robot situado en cualquier parte del mundo desde el lugar en el que el alumnado est\u00e1 trabajando con la APP. En la imagen siguiente a la izquierda vemos el aspecto de la placa ESP32 y a la derecha el de la shield. El aspecto del robot una vez montado es totalmente similar al montado para la versi\u00f3n UNO con la salvedad del cambio de placa y que el driver de motores est\u00e1 integrado en la shield. Aspecto placa Node MCU ESP32 de 30 pines Aspecto de la shield para placa ESP32 El prop\u00f3sito principal es que sea un robot sencillo de imprimir y de construir y que pueda servir para iniciar en el tema STEAM al alumnado desde los \u00faltimos cursos de educaci\u00f3n primaria hasta bachillerato y ciclos formativos pasando por las distintas etapas de la ESO. Se ha pretendido que los dise\u00f1os 3D sean f\u00e1cilmente imprimibles, sin necesidad de soportes y aconsejamos una altura de capa de 0.2mm. Se ha procurado que los tiempos de impresi\u00f3n sean lo m\u00e1s cortos posible pero al mismo tiempo vers\u00e1tiles para las posibles diferencias entre las distintas placas a utilizar. En el apartado de descripci\u00f3n del hardware se pondr\u00e1n algunos enlaces recomendados para adquisici\u00f3n del material aunque, como no pod\u00eda ser de otra manera, cada quien lo puede adquirir donde mejor le parezca. Cualquiera de los modelos puede ser utilizado para otra etapa formativa u objetivo y lo podremos adaptar a nuestras necesidades, siendo esto posible porque se suministran los archivos fuente de dise\u00f1o y programaci\u00f3n y para ello solamente tenemos que cumplir con los requisitos establecidos en las licencias .","title":"MASAYLO-CRG-IoT"},{"location":"ensamble-s/","text":"Materiales necesarios y ensamblado plataforma superior \u00b6 Plataforma superior \u00b6 En esta pieza es donde vamos a colocar el servo para el brazo aparta objetos y los elementos de electr\u00f3nica correspondientes a cada versi\u00f3n. El brazo lo podemos color tanto a la derecha como a la izquierda y recordemos que de forma opcional podemos poner tambi\u00e9n el soporte del zumbador o un sensor fijo de ultrasonidos. El aspecto de la pieza denominada plataforma superior lo vemos en la imagen siguiente. Plataforma superior en fase de dise\u00f1o Plataforma superior Brazo aparta objetos \u00b6 Se trata de una especie de gancho accionado por un servo SG-90 que nos va a servir para apartar objetos detectado por el sensor HC-SR04 de nuestro camino. La idea es que el brazo estar\u00e1 normalmente replegado hacia las ruedas y que, cuando vamos siguiendo una l\u00ednea o resolviendo un laberinto o simplemente desplaz\u00e1ndonos con el robot y detectamos enfrente un objeto del tama\u00f1o de una lata de refresco, se accione el brazo para envolverlo, el robot realice un giro arrastrando el objeto fuera de su trayectoria, posteriormente deshaga el giro, retraiga el brazo y continue su camino. El aspecto del brazo en fase de dise\u00f1o e impreso lo vemos en la imagen siguiente. Brazo en fase de dise\u00f1o Brazo impreso P7. Brazo aparta objetos Im\u00e1genes Necesitamos: - 1 brazo impreso - 1 soporte para servo impreso - 1 pala de un brazo para el servo - 1 tornillo de rosca chapa de los que vienen con el servo - 1 servo SG-90 - 2 tornillos M2x10mm - 2 tuercas M2 - 2 tornillos M3x10mm - 2 tuercas M3 Montamos el servo en su soporte y lo sujetamos con los tornillos M2x10. Colocamos la pala en el alojamiento del brazo y atornillamos este conjunto al servo con el tornillo de rosca chapa. El conjunto anterior lo montamos sobre la plataforma superior en el lugar escogido para ello que deber\u00e1 estar lo mas cercano posible a la parte delantera del robot si imprimimos el brazo a su tama\u00f1o original. En las im\u00e1genes vemos el aspecto de las piezas tanto en fase de dise\u00f1o como impresas \u2192 Es conveniente realizar el posicionamiento del engranaje del servo de forma adecuada antes de continuar. Teniendo en cuenta que el servo puede girar 180\u00ba colocamos el engranaje con la mano o con ayuda de una de las palas del servo en tal posici\u00f3n que permita el movimiento correcto del brazo o del sensor de ultrasonidos. En las imagenes siguientes vemos la plataforma superior con el brazo colocado. Plataforma superior con brazo en fase de dise\u00f1o Plataforma superior con brazo Interruptor, Placa UNO y driver motores \u00b6 Introducimos el interruptor en el orificio rectangular de la plataforma superior destinado para ello y ejerciendo un poco de presi\u00f3n lo encajamos en su lugar. P8. Placa UNO y driver motores Im\u00e1genes Necesitamos: - 7 separadores M3x5mm impresos - 7 tornillos M3x12mm - 7 tuercas M3 - 1 placa UNO con pines extendidos - 1 placa driver de motores L298 Utilizando separadores M3x5mm impresos y tornillos M3x12mm con sus tuercas, colocamos tanto la placa UNO como la placa de drivers en su lugar, que con el interruptor ya colocado nos deja la plataforma superior acabada. En la im\u00e1gen vemos el aspecto del separador en fase de dise\u00f1o \u2192 En la imagen siguiente vemos la plataforma superior en el estado actual. Plataforma superior finalizada en fase de dise\u00f1o Ensamble de las dos plataformas \u00b6 P9. Ensamble de las dos plataformas Im\u00e1genes Necesitamos: - 4 separadores M3x28mm impresos - 4 tornillos M3x40mm - 4 tuercas M3 Utilizando los separadores M3x28mm impresos y tornillos M3x40mm con sus tuercas, sujetamos la plataforma superior a la inferior. En la im\u00e1gen vemos el aspecto del separador en fase de dise\u00f1o \u2192 En la imagen siguiente vemos las dos plataformas montadas. Plataformas superior e inferior montadas en fase de dise\u00f1o Plataformas superior e inferior montadas Sensores de ranura \u00b6 El \u00faltimo paso a realizar es colocar los sensores de ranura sujetos a la plataforma superior y alineados con los discos ranurados de forma que estos giren libremente. P10. Sensores de ranura Necesitamos: - 2 sensores de ranura - 2 tornillos M3x10mm - 2 tuercas M3 - 2 arandelas M3 Sujetamos ambos sensores en su lugar. En las imagenes siguientes vemos mas en detalle el aspecto de estos sensores montados en su lugar. Sensores de ranura en fase de dise\u00f1o Sensores de ranura montados Aspecto final del robot \u00b6 Una vez finalizado el montaje de todos los elementos el robot presenta, en fase de dise\u00f1o, el aspecto que vemos en las im\u00e1genes siguientes. Robot ensamblado en fase de dise\u00f1o Robot ensamblado en fase de dise\u00f1o sobre el soporte de pruebas En las im\u00e1genes siguientes vemos el robot con el ensamblado finalizado. Robot ensamblado Robot ensamblado En la imagen siguiente vemos el robot ensamblado colocado sobre el soporte de pruebas listo para comenzar el conexionado y pruebas del montaje. Robot ensamblado sobre su soporte","title":"Materiales necesarios y ensamblado plataforma superior"},{"location":"ensamble-s/#materiales-necesarios-y-ensamblado-plataforma-superior","text":"","title":"Materiales necesarios y ensamblado plataforma superior"},{"location":"ensamble-s/#plataforma-superior","text":"En esta pieza es donde vamos a colocar el servo para el brazo aparta objetos y los elementos de electr\u00f3nica correspondientes a cada versi\u00f3n. El brazo lo podemos color tanto a la derecha como a la izquierda y recordemos que de forma opcional podemos poner tambi\u00e9n el soporte del zumbador o un sensor fijo de ultrasonidos. El aspecto de la pieza denominada plataforma superior lo vemos en la imagen siguiente. Plataforma superior en fase de dise\u00f1o Plataforma superior","title":"Plataforma superior"},{"location":"ensamble-s/#brazo-aparta-objetos","text":"Se trata de una especie de gancho accionado por un servo SG-90 que nos va a servir para apartar objetos detectado por el sensor HC-SR04 de nuestro camino. La idea es que el brazo estar\u00e1 normalmente replegado hacia las ruedas y que, cuando vamos siguiendo una l\u00ednea o resolviendo un laberinto o simplemente desplaz\u00e1ndonos con el robot y detectamos enfrente un objeto del tama\u00f1o de una lata de refresco, se accione el brazo para envolverlo, el robot realice un giro arrastrando el objeto fuera de su trayectoria, posteriormente deshaga el giro, retraiga el brazo y continue su camino. El aspecto del brazo en fase de dise\u00f1o e impreso lo vemos en la imagen siguiente. Brazo en fase de dise\u00f1o Brazo impreso P7. Brazo aparta objetos Im\u00e1genes Necesitamos: - 1 brazo impreso - 1 soporte para servo impreso - 1 pala de un brazo para el servo - 1 tornillo de rosca chapa de los que vienen con el servo - 1 servo SG-90 - 2 tornillos M2x10mm - 2 tuercas M2 - 2 tornillos M3x10mm - 2 tuercas M3 Montamos el servo en su soporte y lo sujetamos con los tornillos M2x10. Colocamos la pala en el alojamiento del brazo y atornillamos este conjunto al servo con el tornillo de rosca chapa. El conjunto anterior lo montamos sobre la plataforma superior en el lugar escogido para ello que deber\u00e1 estar lo mas cercano posible a la parte delantera del robot si imprimimos el brazo a su tama\u00f1o original. En las im\u00e1genes vemos el aspecto de las piezas tanto en fase de dise\u00f1o como impresas \u2192 Es conveniente realizar el posicionamiento del engranaje del servo de forma adecuada antes de continuar. Teniendo en cuenta que el servo puede girar 180\u00ba colocamos el engranaje con la mano o con ayuda de una de las palas del servo en tal posici\u00f3n que permita el movimiento correcto del brazo o del sensor de ultrasonidos. En las imagenes siguientes vemos la plataforma superior con el brazo colocado. Plataforma superior con brazo en fase de dise\u00f1o Plataforma superior con brazo","title":"Brazo aparta objetos"},{"location":"ensamble-s/#interruptor-placa-uno-y-driver-motores","text":"Introducimos el interruptor en el orificio rectangular de la plataforma superior destinado para ello y ejerciendo un poco de presi\u00f3n lo encajamos en su lugar. P8. Placa UNO y driver motores Im\u00e1genes Necesitamos: - 7 separadores M3x5mm impresos - 7 tornillos M3x12mm - 7 tuercas M3 - 1 placa UNO con pines extendidos - 1 placa driver de motores L298 Utilizando separadores M3x5mm impresos y tornillos M3x12mm con sus tuercas, colocamos tanto la placa UNO como la placa de drivers en su lugar, que con el interruptor ya colocado nos deja la plataforma superior acabada. En la im\u00e1gen vemos el aspecto del separador en fase de dise\u00f1o \u2192 En la imagen siguiente vemos la plataforma superior en el estado actual. Plataforma superior finalizada en fase de dise\u00f1o","title":"Interruptor, Placa UNO y driver motores"},{"location":"ensamble-s/#ensamble-de-las-dos-plataformas","text":"P9. Ensamble de las dos plataformas Im\u00e1genes Necesitamos: - 4 separadores M3x28mm impresos - 4 tornillos M3x40mm - 4 tuercas M3 Utilizando los separadores M3x28mm impresos y tornillos M3x40mm con sus tuercas, sujetamos la plataforma superior a la inferior. En la im\u00e1gen vemos el aspecto del separador en fase de dise\u00f1o \u2192 En la imagen siguiente vemos las dos plataformas montadas. Plataformas superior e inferior montadas en fase de dise\u00f1o Plataformas superior e inferior montadas","title":"Ensamble de las dos plataformas"},{"location":"ensamble-s/#sensores-de-ranura","text":"El \u00faltimo paso a realizar es colocar los sensores de ranura sujetos a la plataforma superior y alineados con los discos ranurados de forma que estos giren libremente. P10. Sensores de ranura Necesitamos: - 2 sensores de ranura - 2 tornillos M3x10mm - 2 tuercas M3 - 2 arandelas M3 Sujetamos ambos sensores en su lugar. En las imagenes siguientes vemos mas en detalle el aspecto de estos sensores montados en su lugar. Sensores de ranura en fase de dise\u00f1o Sensores de ranura montados","title":"Sensores de ranura"},{"location":"ensamble-s/#aspecto-final-del-robot","text":"Una vez finalizado el montaje de todos los elementos el robot presenta, en fase de dise\u00f1o, el aspecto que vemos en las im\u00e1genes siguientes. Robot ensamblado en fase de dise\u00f1o Robot ensamblado en fase de dise\u00f1o sobre el soporte de pruebas En las im\u00e1genes siguientes vemos el robot con el ensamblado finalizado. Robot ensamblado Robot ensamblado En la imagen siguiente vemos el robot ensamblado colocado sobre el soporte de pruebas listo para comenzar el conexionado y pruebas del montaje. Robot ensamblado sobre su soporte","title":"Aspecto final del robot"},{"location":"ensamble/","text":"Materiales necesarios y ensamblado plataforma base \u00b6 Vamos a realizar el paso a paso de montaje del robot utilizando para ellos la versi\u00f3n MASAYLO-CRG-UNO . El montaje de las otras versiones es totalmente similar y la \u00fanica diferencia va a estar en la placa de control teniendo la plataforma superior habilitadas orificios para las distintas placas. En cada uno de los pasos iremos indicando los materiales necesarios para su consecuci\u00f3n. Las herramientas necesarias para llevar a cabo el proceso van a depender del tipo de cabeza de tornillo que utilicemos, pero en cualquier caso necesitaremos destornilladores adecuados y unos alicates de punta plana por si es necesario sujetar alg\u00fan tornillo. Para los motores y el interruptor necesitaremos unos trozos de cable de distintos colores (rojo y negro a ser posible para distinguir bien la alimentaci\u00f3n) de entre 10 y 15 cm de longitud. Estos cables ir\u00e1n directamente soldados a las patillas correspondientes de los motores y del interruptor. En el apartado correspondiente se detalla el proceso. Motores, Portapilas e interruptor \u00b6 P0. Motores Im\u00e1genes Si partimos de la base que los motores no vienen ya preinstalados con cables, necesitamos: - 2 motores DC de 3 a 6V con reductora - 4 trozos de hilos de diferentes colores - Tijeras o pelacables - Soldador para electr\u00f3nica - Se aconseja usar esta\u00f1o de 1mm sin plomo con n\u00facleo de resina y composici\u00f3n del 99% de Sn, 3% de Ag y 0.7% de Cu En la imagen vemos los motores y los cables sin soldar \u2192 En la imagen vemos los motores con los cables soldados \u2192 P0. Portapilas Im\u00e1genes Lo ideal es adquirirlo con los cables ya instalados, aunque existen otras opciones que tendremos que analizar en cada caso. Para este paso necesitamos - 1 portapilas 5xAA Aunque sobresaldr\u00e1 un poco por los laterales tambi\u00e9n nos puede valer un portapilas 6xAA En la imagen vemos el portapilas preparado con los cables \u2192 P0. Interruptor Im\u00e1genes Necesitamos: - 1 mini interruptor basculante de 2 Pines tipo SPST de 10.5x15mm - 2 trozos de hilos de diferentes colores, idealmente rojo y negro, para mantener el est\u00e1ndar de colores de alimentaci\u00f3n Debemos tener presente que con los cables soldados y la forma de colocaci\u00f3n del interruptor (por presi\u00f3n en la plataforma superior) no podemos tener realizadas las conexiones a priori, es mas interesante realizar estas conexiones mediante, por ejemplo una clema, que permite un montaje c\u00f3modo y que podemos quitar si es necesario en el futuro. En la imagen tenemos el interruptor preparado para la instalaci\u00f3n \u2192 Plataforma base \u00b6 En fase de dise\u00f1o el aspecto de la plataforma base lo vemos en la imagen siguiente. P1. Plataforma base Im\u00e1genes Necesitamos: - 1 plataforma base impresa - 1 portapilas - 2 motores DC de 3 a 6V con reductora ya cableados - 2 tornillos M3x8mm de cabeza avellanada - 4 tornillos M3x30mm - 6 tuercas M3 En la imagen vemos el aspecto de la plataforma base una vez impresa \u2192 Sujetamos el portapilas a la base utilizando los dos tornillos M3x8 y dos tuercas. Debe queda como observamos en la imagen quedando el portapilas bajo la base \u2192 Utilizando dos tornillos M3x30 y dos tuercas por cada motor los colocamos y atornillamos a la plataforma base, teniendo cuidado de que los motores queden bien pegados a la base. La posici\u00f3n exacta de los motores viene determinada por los orificios existentes en su carcasa y las ranuras de las pesta\u00f1as verticales de la pieza impresa, que deben quedar alineadas. En esta etapa es conveniente, tal y como se aprecia en la im\u00e1gen, que el disco perforado del encoder est\u00e9 situado en el eje del motor y que este quede mas o menos centrado en la ranura de la base. En la imagen vemos como debe quedar \u2192 En las im\u00e1genes siguientes vemos los pasos anteriores en fase de dise\u00f1o Plataforma base con portapilas Plataforma base con motores Opci\u00f3n zumbador pasivo \u00b6 Podemos optar por colocar el zumbador pasivo en la plataforma base o bien colocarlo en la plataforma superior. A continuaci\u00f3n vemos el aspecto de la pieza en fase de dise\u00f1o. P2. Zumbador pasivo Im\u00e1genes Necesitamos: - 1 soporte para buzzer impreso - 1 zumbador pasivo - 2 tornillos M3x8mm - 2 tuercas M3 - 2 cables tipo dupont H-H de 20 cm En la imagen vemos el aspecto de la pieza impresa \u2192 En la imagen siguiente vemos la plataforma base con el soporte para zumbador colocado en su lugar, tanto en fase de dise\u00f1o como en la realidad. Plataforma base con buzzer en fase de dise\u00f1o Plataforma base con buzzer Ballcaster y porta sensores IR \u00b6 En realidad esta pieza podr\u00eda ser una solamente pero se ha dividido en dos para evitar el uso de soportes en la impresi\u00f3n. El aspecto en tiempo de dise\u00f1o de ambas piezas lo vemos en las imagenes siguientes: | | | P3. Rueda loca y porta sensores de infrarrojos Im\u00e1genes Necesitamos: - 1 ballcaster impreso - 1 portasensores IR impreso - 2 tornillos M3x8mm - 4 tornillos M3x10mm - 6 tuercas M3 - 2 sensores IR de distancia ajustable detecci\u00f3n 2 a 30cm - 6 cables tipo dupont H-H de 20 cm Colocamos y atornillamos los sensores IR con los tornillos M3x8. Empotramos dos tuerca M3 en la pieza ballcaster y colocamos esta pieza en la parte posterior del porta sensores alineando con los agujeros inferiores y atornillando con dos tornillos M3x10. Finalmente atornillamos el conjunto a la plataforma base utilizando dos tornillos M3x10 y alineando con los agujeros centrales de la base en la parte que muestra un trozo plano En la imagen vemos el aspecto del conjunto montado sobre las piezas impresas \u2192 En la imagen siguiente vemos la plataforma base con el soporte para sensores de infrarrojos y rueda loca colocados en su lugar, tanto en fase de dise\u00f1o como en la fase montaje real. Plataforma base con sensor IR en fase de dise\u00f1o Plataforma base con sensor IR Ruedas \u00b6 Nuestra propuesta va a incluir tres dise\u00f1os que van a tener como diferencia el n\u00famero y la posici\u00f3n de juntas t\u00f3ricas. Las ruedas van a tener un radio exterior de 38 mm con una ranura que permite alojar una junta t\u00f3rica de 75 mm de di\u00e1metro exterior y secci\u00f3n transversal de 3mm de di\u00e1metro. En la imagen siguiente vemos a la izquierda el modelo para dos juntas con separaci\u00f3n de 10 mm entre ambas, en el centro la de una sola con la junta colocada y a la derecha tenemos el modelo de dos juntas sin distancia entre las mismas. Observamos como los dise\u00f1os interiores de las ruedas son iguales en cuanto a geometr\u00eda e indicaremos que el n\u00famero y la posici\u00f3n de las juntas se establece para dar soluci\u00f3n a las diferentes adherencias de superficies y evitar en lo posible que las ruedas derrapen cuando giran. El orificio con la forma del eje del motor est\u00e1 dimensionado para que la rueda quede bien acoplada simplemente presionando sobre el eje, pero somos conscientes de que las impresoras 3D tienen ciertas tolerancias y no todas van a darnos exactamente las mismas dimensiones, por ello hemos previsto la posibilidad de realizar la sujeci\u00f3n mediante tornillo que ejerza presi\u00f3n contra el eje del motor y tuerca empotrada en el cilindro de la rueda. Este paso de montaje va a depender de la opci\u00f3n escogida y de si usamos o no tornillo prisionero. P4. Ruedas Im\u00e1genes Necesitamos: - 2 ruedas impresas del modelo escogido - 2 (o 4) juntas t\u00f3ricas de 75x3mm - 2 tornillos M3x10mm - 2 tuercas M3 Colocamos haciendo presi\u00f3n si es necesario una rueda en cada eje de motor. Si es necesario porque el encaje anterior tiene holgura, empotramos una tuerca M3 en cada rueda y fijamos la posici\u00f3n de la rueda utilizando el tornillo prisionero. En la imagen inferior vemos el detalle del tornillo prisionero. En la imagen vemos el aspecto del conjunto montado con las ruedas de una junta \u2192 En las imagenes siguientes vemos la plataforma base con cada tipo de ruedas en fase de dise\u00f1o. Plataforma base con ruedas una junta Plataforma base con ruedas dos juntas Plataforma base con ruedas dos juntas separadas Soporte para servo SG-90 \u00b6 En esta pieza es donde colocamos y atornillamos el servo motor tanto para el brazo aparta objetos como para el sensor de ultrasonidos m\u00f3vil. Si vamos a optar por la opci\u00f3n de ultrasonidos fijo solamente debemos montar un servo pero si optamos por la opci\u00f3n con sensor de ultrasonidos m\u00f3vil debemos montar dos conjuntos. P5. Servo SG-90 Im\u00e1genes Necesitamos: - 1 (o 2) soporte para servo impreso - 1 (o 2) servomotores SG-90 - 2 (o 4) tornillos M2x10mm - 2 (o 4) tuercas M2 Colocamos el servo en la pieza y lo sujetamos utilizando los tornillos M2x10. En las im\u00e1genes vemos el aspecto de la pieza tanto en fase de dise\u00f1o como impresa \u2192 Es conveniente realizar el posicionamiento del engranaje del servo de forma adecuada antes de continuar. Teniendo en cuenta que el servo puede girar 180\u00ba colocamos el engranaje con la mano o con ayuda de una de las palas del servo en tal posici\u00f3n que permita el movimiento correcto del brazo o del sensor de ultrasonidos. En las imagenes siguientes vemos el soporte con el servo colocado. Portaservo con servo en fase de dise\u00f1o Portaservo impreso con servo Soporte sensor de ultrasonidos HC-SR04 \u00b6 Tenemos dos opciones disponibles, un soporte fijo que podemos colocar tanto en la parte superior del porta sensores IR o utilizando alguna de las ranuras de las plataformas superior o inferior, y un soporte m\u00f3vil accionado por un servo pensado para colocarlo a modo de cabeza giratoria tambi\u00e9n en la parte superior del porta sensores de IR. En ambos casos el sensor se coloca presionando ligeramente para que encaje en las pesta\u00f1as del porta sensores. En las im\u00e1genes siguientes tenemos ambos tipos de soportes tanto en modo dise\u00f1o como impresos. Porta HC-SR04 fijo fase dise\u00f1o Porta HC-SR04 fijo impreso Porta HC-SR04 m\u00f3vil fase dise\u00f1o Porta HC-SR04 m\u00f3vil impreso P6. Sensor de ultrasonidos HC-SR04 Im\u00e1genes Necesitamos: - 1 soporte fijo para sensor HC-SR04 impreso - 1 soporte m\u00f3vil para sensor HC-SR04 impreso - 1 (o 2) pala de un brazo para el servo - 1 (o 2) tornillos de rosca chapa de los que vienen con el servo - 1 servo montado en su soporte - 2 tornillos M3x10mm - 2 tuercas M3 Colocamos el sensor de ultrasonidos en su alojamiento en el soporte fijo o m\u00f3vil elegido. Si hemos escogido soporte fijo sujetamos este con dos tornillos M3x10 en el lugar escogido y si hemos escogido el soporte m\u00f3vil sujetamos el soporte del sensor al servo con el tornillo de rosca chapa colocando la pala en la cabeza del servo. En las im\u00e1genes vemos el aspecto de las piezas tanto en fase de dise\u00f1o como impresas \u2192 Es conveniente realizar el posicionamiento del engranaje del servo de forma adecuada antes de continuar. Teniendo en cuenta que el servo puede girar 180\u00ba colocamos el engranaje con la mano o con ayuda de una de las palas del servo en tal posici\u00f3n que permita el movimiento correcto del brazo o del sensor de ultrasonidos. En las imagenes siguientes vemos la plataforma base finalizada con todas sus opciones colocadas. Plataforma base finalizada en fase de dise\u00f1o Plataforma base finalizada","title":"Materiales necesarios y ensamblado plataforma base"},{"location":"ensamble/#materiales-necesarios-y-ensamblado-plataforma-base","text":"Vamos a realizar el paso a paso de montaje del robot utilizando para ellos la versi\u00f3n MASAYLO-CRG-UNO . El montaje de las otras versiones es totalmente similar y la \u00fanica diferencia va a estar en la placa de control teniendo la plataforma superior habilitadas orificios para las distintas placas. En cada uno de los pasos iremos indicando los materiales necesarios para su consecuci\u00f3n. Las herramientas necesarias para llevar a cabo el proceso van a depender del tipo de cabeza de tornillo que utilicemos, pero en cualquier caso necesitaremos destornilladores adecuados y unos alicates de punta plana por si es necesario sujetar alg\u00fan tornillo. Para los motores y el interruptor necesitaremos unos trozos de cable de distintos colores (rojo y negro a ser posible para distinguir bien la alimentaci\u00f3n) de entre 10 y 15 cm de longitud. Estos cables ir\u00e1n directamente soldados a las patillas correspondientes de los motores y del interruptor. En el apartado correspondiente se detalla el proceso.","title":"Materiales necesarios y ensamblado plataforma base"},{"location":"ensamble/#motores-portapilas-e-interruptor","text":"P0. Motores Im\u00e1genes Si partimos de la base que los motores no vienen ya preinstalados con cables, necesitamos: - 2 motores DC de 3 a 6V con reductora - 4 trozos de hilos de diferentes colores - Tijeras o pelacables - Soldador para electr\u00f3nica - Se aconseja usar esta\u00f1o de 1mm sin plomo con n\u00facleo de resina y composici\u00f3n del 99% de Sn, 3% de Ag y 0.7% de Cu En la imagen vemos los motores y los cables sin soldar \u2192 En la imagen vemos los motores con los cables soldados \u2192 P0. Portapilas Im\u00e1genes Lo ideal es adquirirlo con los cables ya instalados, aunque existen otras opciones que tendremos que analizar en cada caso. Para este paso necesitamos - 1 portapilas 5xAA Aunque sobresaldr\u00e1 un poco por los laterales tambi\u00e9n nos puede valer un portapilas 6xAA En la imagen vemos el portapilas preparado con los cables \u2192 P0. Interruptor Im\u00e1genes Necesitamos: - 1 mini interruptor basculante de 2 Pines tipo SPST de 10.5x15mm - 2 trozos de hilos de diferentes colores, idealmente rojo y negro, para mantener el est\u00e1ndar de colores de alimentaci\u00f3n Debemos tener presente que con los cables soldados y la forma de colocaci\u00f3n del interruptor (por presi\u00f3n en la plataforma superior) no podemos tener realizadas las conexiones a priori, es mas interesante realizar estas conexiones mediante, por ejemplo una clema, que permite un montaje c\u00f3modo y que podemos quitar si es necesario en el futuro. En la imagen tenemos el interruptor preparado para la instalaci\u00f3n \u2192","title":"Motores, Portapilas e interruptor"},{"location":"ensamble/#plataforma-base","text":"En fase de dise\u00f1o el aspecto de la plataforma base lo vemos en la imagen siguiente. P1. Plataforma base Im\u00e1genes Necesitamos: - 1 plataforma base impresa - 1 portapilas - 2 motores DC de 3 a 6V con reductora ya cableados - 2 tornillos M3x8mm de cabeza avellanada - 4 tornillos M3x30mm - 6 tuercas M3 En la imagen vemos el aspecto de la plataforma base una vez impresa \u2192 Sujetamos el portapilas a la base utilizando los dos tornillos M3x8 y dos tuercas. Debe queda como observamos en la imagen quedando el portapilas bajo la base \u2192 Utilizando dos tornillos M3x30 y dos tuercas por cada motor los colocamos y atornillamos a la plataforma base, teniendo cuidado de que los motores queden bien pegados a la base. La posici\u00f3n exacta de los motores viene determinada por los orificios existentes en su carcasa y las ranuras de las pesta\u00f1as verticales de la pieza impresa, que deben quedar alineadas. En esta etapa es conveniente, tal y como se aprecia en la im\u00e1gen, que el disco perforado del encoder est\u00e9 situado en el eje del motor y que este quede mas o menos centrado en la ranura de la base. En la imagen vemos como debe quedar \u2192 En las im\u00e1genes siguientes vemos los pasos anteriores en fase de dise\u00f1o Plataforma base con portapilas Plataforma base con motores","title":"Plataforma base"},{"location":"ensamble/#opcion-zumbador-pasivo","text":"Podemos optar por colocar el zumbador pasivo en la plataforma base o bien colocarlo en la plataforma superior. A continuaci\u00f3n vemos el aspecto de la pieza en fase de dise\u00f1o. P2. Zumbador pasivo Im\u00e1genes Necesitamos: - 1 soporte para buzzer impreso - 1 zumbador pasivo - 2 tornillos M3x8mm - 2 tuercas M3 - 2 cables tipo dupont H-H de 20 cm En la imagen vemos el aspecto de la pieza impresa \u2192 En la imagen siguiente vemos la plataforma base con el soporte para zumbador colocado en su lugar, tanto en fase de dise\u00f1o como en la realidad. Plataforma base con buzzer en fase de dise\u00f1o Plataforma base con buzzer","title":"Opci\u00f3n zumbador pasivo"},{"location":"ensamble/#ballcaster-y-porta-sensores-ir","text":"En realidad esta pieza podr\u00eda ser una solamente pero se ha dividido en dos para evitar el uso de soportes en la impresi\u00f3n. El aspecto en tiempo de dise\u00f1o de ambas piezas lo vemos en las imagenes siguientes: | | | P3. Rueda loca y porta sensores de infrarrojos Im\u00e1genes Necesitamos: - 1 ballcaster impreso - 1 portasensores IR impreso - 2 tornillos M3x8mm - 4 tornillos M3x10mm - 6 tuercas M3 - 2 sensores IR de distancia ajustable detecci\u00f3n 2 a 30cm - 6 cables tipo dupont H-H de 20 cm Colocamos y atornillamos los sensores IR con los tornillos M3x8. Empotramos dos tuerca M3 en la pieza ballcaster y colocamos esta pieza en la parte posterior del porta sensores alineando con los agujeros inferiores y atornillando con dos tornillos M3x10. Finalmente atornillamos el conjunto a la plataforma base utilizando dos tornillos M3x10 y alineando con los agujeros centrales de la base en la parte que muestra un trozo plano En la imagen vemos el aspecto del conjunto montado sobre las piezas impresas \u2192 En la imagen siguiente vemos la plataforma base con el soporte para sensores de infrarrojos y rueda loca colocados en su lugar, tanto en fase de dise\u00f1o como en la fase montaje real. Plataforma base con sensor IR en fase de dise\u00f1o Plataforma base con sensor IR","title":"Ballcaster y porta sensores IR"},{"location":"ensamble/#ruedas","text":"Nuestra propuesta va a incluir tres dise\u00f1os que van a tener como diferencia el n\u00famero y la posici\u00f3n de juntas t\u00f3ricas. Las ruedas van a tener un radio exterior de 38 mm con una ranura que permite alojar una junta t\u00f3rica de 75 mm de di\u00e1metro exterior y secci\u00f3n transversal de 3mm de di\u00e1metro. En la imagen siguiente vemos a la izquierda el modelo para dos juntas con separaci\u00f3n de 10 mm entre ambas, en el centro la de una sola con la junta colocada y a la derecha tenemos el modelo de dos juntas sin distancia entre las mismas. Observamos como los dise\u00f1os interiores de las ruedas son iguales en cuanto a geometr\u00eda e indicaremos que el n\u00famero y la posici\u00f3n de las juntas se establece para dar soluci\u00f3n a las diferentes adherencias de superficies y evitar en lo posible que las ruedas derrapen cuando giran. El orificio con la forma del eje del motor est\u00e1 dimensionado para que la rueda quede bien acoplada simplemente presionando sobre el eje, pero somos conscientes de que las impresoras 3D tienen ciertas tolerancias y no todas van a darnos exactamente las mismas dimensiones, por ello hemos previsto la posibilidad de realizar la sujeci\u00f3n mediante tornillo que ejerza presi\u00f3n contra el eje del motor y tuerca empotrada en el cilindro de la rueda. Este paso de montaje va a depender de la opci\u00f3n escogida y de si usamos o no tornillo prisionero. P4. Ruedas Im\u00e1genes Necesitamos: - 2 ruedas impresas del modelo escogido - 2 (o 4) juntas t\u00f3ricas de 75x3mm - 2 tornillos M3x10mm - 2 tuercas M3 Colocamos haciendo presi\u00f3n si es necesario una rueda en cada eje de motor. Si es necesario porque el encaje anterior tiene holgura, empotramos una tuerca M3 en cada rueda y fijamos la posici\u00f3n de la rueda utilizando el tornillo prisionero. En la imagen inferior vemos el detalle del tornillo prisionero. En la imagen vemos el aspecto del conjunto montado con las ruedas de una junta \u2192 En las imagenes siguientes vemos la plataforma base con cada tipo de ruedas en fase de dise\u00f1o. Plataforma base con ruedas una junta Plataforma base con ruedas dos juntas Plataforma base con ruedas dos juntas separadas","title":"Ruedas"},{"location":"ensamble/#soporte-para-servo-sg-90","text":"En esta pieza es donde colocamos y atornillamos el servo motor tanto para el brazo aparta objetos como para el sensor de ultrasonidos m\u00f3vil. Si vamos a optar por la opci\u00f3n de ultrasonidos fijo solamente debemos montar un servo pero si optamos por la opci\u00f3n con sensor de ultrasonidos m\u00f3vil debemos montar dos conjuntos. P5. Servo SG-90 Im\u00e1genes Necesitamos: - 1 (o 2) soporte para servo impreso - 1 (o 2) servomotores SG-90 - 2 (o 4) tornillos M2x10mm - 2 (o 4) tuercas M2 Colocamos el servo en la pieza y lo sujetamos utilizando los tornillos M2x10. En las im\u00e1genes vemos el aspecto de la pieza tanto en fase de dise\u00f1o como impresa \u2192 Es conveniente realizar el posicionamiento del engranaje del servo de forma adecuada antes de continuar. Teniendo en cuenta que el servo puede girar 180\u00ba colocamos el engranaje con la mano o con ayuda de una de las palas del servo en tal posici\u00f3n que permita el movimiento correcto del brazo o del sensor de ultrasonidos. En las imagenes siguientes vemos el soporte con el servo colocado. Portaservo con servo en fase de dise\u00f1o Portaservo impreso con servo","title":"Soporte para servo SG-90"},{"location":"ensamble/#soporte-sensor-de-ultrasonidos-hc-sr04","text":"Tenemos dos opciones disponibles, un soporte fijo que podemos colocar tanto en la parte superior del porta sensores IR o utilizando alguna de las ranuras de las plataformas superior o inferior, y un soporte m\u00f3vil accionado por un servo pensado para colocarlo a modo de cabeza giratoria tambi\u00e9n en la parte superior del porta sensores de IR. En ambos casos el sensor se coloca presionando ligeramente para que encaje en las pesta\u00f1as del porta sensores. En las im\u00e1genes siguientes tenemos ambos tipos de soportes tanto en modo dise\u00f1o como impresos. Porta HC-SR04 fijo fase dise\u00f1o Porta HC-SR04 fijo impreso Porta HC-SR04 m\u00f3vil fase dise\u00f1o Porta HC-SR04 m\u00f3vil impreso P6. Sensor de ultrasonidos HC-SR04 Im\u00e1genes Necesitamos: - 1 soporte fijo para sensor HC-SR04 impreso - 1 soporte m\u00f3vil para sensor HC-SR04 impreso - 1 (o 2) pala de un brazo para el servo - 1 (o 2) tornillos de rosca chapa de los que vienen con el servo - 1 servo montado en su soporte - 2 tornillos M3x10mm - 2 tuercas M3 Colocamos el sensor de ultrasonidos en su alojamiento en el soporte fijo o m\u00f3vil elegido. Si hemos escogido soporte fijo sujetamos este con dos tornillos M3x10 en el lugar escogido y si hemos escogido el soporte m\u00f3vil sujetamos el soporte del sensor al servo con el tornillo de rosca chapa colocando la pala en la cabeza del servo. En las im\u00e1genes vemos el aspecto de las piezas tanto en fase de dise\u00f1o como impresas \u2192 Es conveniente realizar el posicionamiento del engranaje del servo de forma adecuada antes de continuar. Teniendo en cuenta que el servo puede girar 180\u00ba colocamos el engranaje con la mano o con ayuda de una de las palas del servo en tal posici\u00f3n que permita el movimiento correcto del brazo o del sensor de ultrasonidos. En las imagenes siguientes vemos la plataforma base finalizada con todas sus opciones colocadas. Plataforma base finalizada en fase de dise\u00f1o Plataforma base finalizada","title":"Soporte sensor de ultrasonidos HC-SR04"},{"location":"ficheros-media/","text":"Ficheros 3D para impresoras de precisi\u00f3n media \u00b6 En este apartado se incluyen los enlaces a los archivos originales de dise\u00f1o y los archivos en formato stl y step. Los archivos disponibles en este apartado est\u00e1n dise\u00f1ados pensando en imprimir en impresoras 3D est\u00e1ndar de bajo coste. Estas impresoras se caracterizan por tener ciertas tolerancias en las impresiones finales, requerir calibraciones con cierta asiduidad, etc. Las impresiones con los archivos de este apartado est\u00e1n pensados para compensar estas tolerancias, en especial en los problemas t\u00edpicos que se no han presentado, como son el ajuste del eje de los motores a la ranura de la rueda o el encaje de las tuercas empotradas en su alojamientos. Archivos fuente de dise\u00f1o \u00b6 Creados con FreeCAD que puedes modificar, cambiar seg\u00fan necesidades o utilizar para aprender el manejo de esta potente herramienta. Archivo Comentarios ruedas Rueda con una sola junta t\u00f3rica y dos versiones para dos juntas, una con esta juntas y la otra separadas. soporte-ballcaster-media.FCStd Solamente contiene la pieza del ballcaster. El soporte de los sensores verticales de IR es el mismo que en alta precisi\u00f3n Archivos STL y STEP \u00b6 Archivos en formato stl , listos para llevar a tu programa de laminaci\u00f3n preferido y hacerlos realidad con tu impresora. La configuraci\u00f3n de impresi\u00f3n debe adaptarse en cada caso a la impresora disponible, aunque hacemos las siguientes recomendaciones: Balsas: No Soportes de impresi\u00f3n: No Resoluci\u00f3n: 0,2 mm Relleno: 15 - 20% Marca de filamento: cualquiera Color del filamento: el preferido Material: PLA Archivos en formato step , para poder cargarlos en otros programas de dise\u00f1o CAD. En la tabla siguiente est\u00e1n los enlaces a estos dos tipos de ficheros. Imagen Archivo STL Archivo STEP rueda-una-junta.stl rueda-una-junta.step rueda-dos-juntas.stl rueda-dos-juntas.step rueda-dos-juntas-ancha.stl rueda-dos-juntas-ancha.step soporte-ballcaster-media.stl soporte-ballcaster-media.step","title":"3D precisi\u00f3n media"},{"location":"ficheros-media/#ficheros-3d-para-impresoras-de-precision-media","text":"En este apartado se incluyen los enlaces a los archivos originales de dise\u00f1o y los archivos en formato stl y step. Los archivos disponibles en este apartado est\u00e1n dise\u00f1ados pensando en imprimir en impresoras 3D est\u00e1ndar de bajo coste. Estas impresoras se caracterizan por tener ciertas tolerancias en las impresiones finales, requerir calibraciones con cierta asiduidad, etc. Las impresiones con los archivos de este apartado est\u00e1n pensados para compensar estas tolerancias, en especial en los problemas t\u00edpicos que se no han presentado, como son el ajuste del eje de los motores a la ranura de la rueda o el encaje de las tuercas empotradas en su alojamientos.","title":"Ficheros 3D para impresoras de precisi\u00f3n media"},{"location":"ficheros-media/#archivos-fuente-de-diseno","text":"Creados con FreeCAD que puedes modificar, cambiar seg\u00fan necesidades o utilizar para aprender el manejo de esta potente herramienta. Archivo Comentarios ruedas Rueda con una sola junta t\u00f3rica y dos versiones para dos juntas, una con esta juntas y la otra separadas. soporte-ballcaster-media.FCStd Solamente contiene la pieza del ballcaster. El soporte de los sensores verticales de IR es el mismo que en alta precisi\u00f3n","title":"Archivos fuente de dise\u00f1o"},{"location":"ficheros-media/#archivos-stl-y-step","text":"Archivos en formato stl , listos para llevar a tu programa de laminaci\u00f3n preferido y hacerlos realidad con tu impresora. La configuraci\u00f3n de impresi\u00f3n debe adaptarse en cada caso a la impresora disponible, aunque hacemos las siguientes recomendaciones: Balsas: No Soportes de impresi\u00f3n: No Resoluci\u00f3n: 0,2 mm Relleno: 15 - 20% Marca de filamento: cualquiera Color del filamento: el preferido Material: PLA Archivos en formato step , para poder cargarlos en otros programas de dise\u00f1o CAD. En la tabla siguiente est\u00e1n los enlaces a estos dos tipos de ficheros. Imagen Archivo STL Archivo STEP rueda-una-junta.stl rueda-una-junta.step rueda-dos-juntas.stl rueda-dos-juntas.step rueda-dos-juntas-ancha.stl rueda-dos-juntas-ancha.step soporte-ballcaster-media.stl soporte-ballcaster-media.step","title":"Archivos STL y STEP"},{"location":"ficheros/","text":"Ficheros 3D para impresoras de alta precisi\u00f3n \u00b6 En este apartado se incluyen los enlaces a los archivos originales de dise\u00f1o y los archivos en formato stl y step. Los archivos disponibles en este apartado est\u00e1n dise\u00f1ados pensando en imprimir en una impresora del tipo Prusa MK3S, MK3S+, Prusa Mini o Prusa Mini+ Originales. Estas impresoras, adem\u00e1s de tener una calidad de impresi\u00f3n muy buena, est\u00e1n optimizadas para que las impresiones finales tengan muy poca tolerancia, en lo que respecta a dimensiones, con relaci\u00f3n a las medidas originales de dise\u00f1o. Es muy posible,si no disponemos de impresoras como estas o de calidades similares, que al imprimir estos dise\u00f1os tengamos alg\u00fan problema a la hora de ensamblar nuestro robot y tengamos que retocar a mano ciertas partes. Ejemplos t\u00edpicos de esto que se no han dado son el ajuste del eje de los motores a la ranura de la rueda o el encaje de las tuercas empotradas en su alojamientos. Si no dispones de una impresora como las citadas, o similar, te aconsejamos que utilices los archivos que se suministran en el apartado 3D precisi\u00f3n media para las piezas incluidas en dicho apartado. Archivos fuente de dise\u00f1o \u00b6 Creados con FreeCAD que puedes modificar, cambiar seg\u00fan necesidades o utilizar para aprender el manejo de esta potente herramienta. Archivo Comentarios plataforma-base-src.FCStd Para colocar el portapilas, los motores DC, el zumbador y el ballcaster o punto de apoyo estilo rueda loca soporte-zumbador-src.FCStd Para colocar un zumbador pasivo. Esta pieza tambi\u00e9n se puede colocar en la plataforma superior soporte-sensores-IR-ballcaster.FCStd Contiene dos piezas, el ballcaster y el soporte de los sensores verticales de IR soportes-ultrasonidos.FCStd Contiene los soporte fijo y m\u00f3vil para el sensor HC-SR04 plataforma-superior-src.FCStd Para colocar cualquiera de las placas, el interruptor y sujetar el servo del brazo ruedas.FCStd Rueda con una sola junta t\u00f3rica y dos versiones para dos juntas, una con esta juntas y la otra separadas. base-servo-src.FCStd Pieza para sujetar un servo tipo SG90 brazo-src.FCStd Brazo aparta objetos con alojamiento para la pala del servo separadores-src.FCStd M3x5 para placa UNO y driver y M3x28 para unir plataformas base y superior soporte-pruebas.FCStd Pieza pensada para poner encima el robot y poder hacer pruebas sin que este se mueva del sitio disco-encoder.FCStd Disco de 23 mm de di\u00e1metro con 20 ranuras acoplable a eje de motor para encoder optico conjunto-src.FCStd Muestra la colocaci\u00f3n de los distintos elementos en fase de dise\u00f1o Todo en un archivo zip Para descargar todos los archivos en un clic Archivos STL y STEP \u00b6 Archivos en formato stl , listos para llevar a tu programa de laminaci\u00f3n preferido y hacerlos realidad con tu impresora. La configuraci\u00f3n de impresi\u00f3n debe adaptarse en cada caso a la impresora disponible, aunque hacemos las siguientes recomendaciones: Balsas: No Soportes de impresi\u00f3n: No Resoluci\u00f3n: 0,2 mm Relleno: 15 - 20% Marca de filamento: cualquiera Color del filamento: el preferido Material: PLA Archivos en formato step , para poder cargarlos en otros programas de dise\u00f1o CAD. En la tabla siguiente est\u00e1n los enlaces a estos dos tipos de ficheros. Imagen Archivo STL Archivo STEP ballcaster.stl ballcaster.step base-servo.stl base-servo.step brazo.stl brazo.step disco-encoder.stl disco-encoder.step plataforma-base.stl plataforma-base.step plataforma-superior.stl plataforma-superior.step rueda-una-junta.stl rueda-una-junta.step rueda-dos-juntas.stl rueda-dos-juntas.step rueda-dos-juntas-ancha.stl rueda-dos-juntas-ancha.step porta-sensores-IR.stl porta-sensores-IR.step separador-M3x5.stl separador-M3x5.step separador-M3x28.stl separador-M3x28.step soporte-para-pruebas.stl soporte-para-pruebas.step soporte-zumbador.stl soporte-zumbador.step ultrasonidos-fijo.stl ultrasonidos-fijo.step ultrasonidos-movil.stl ultrasonidos-movil.step Todos los archivos en un zip Todos los stl en un zip Todos los step en un zip","title":"3D alta precisi\u00f3n"},{"location":"ficheros/#ficheros-3d-para-impresoras-de-alta-precision","text":"En este apartado se incluyen los enlaces a los archivos originales de dise\u00f1o y los archivos en formato stl y step. Los archivos disponibles en este apartado est\u00e1n dise\u00f1ados pensando en imprimir en una impresora del tipo Prusa MK3S, MK3S+, Prusa Mini o Prusa Mini+ Originales. Estas impresoras, adem\u00e1s de tener una calidad de impresi\u00f3n muy buena, est\u00e1n optimizadas para que las impresiones finales tengan muy poca tolerancia, en lo que respecta a dimensiones, con relaci\u00f3n a las medidas originales de dise\u00f1o. Es muy posible,si no disponemos de impresoras como estas o de calidades similares, que al imprimir estos dise\u00f1os tengamos alg\u00fan problema a la hora de ensamblar nuestro robot y tengamos que retocar a mano ciertas partes. Ejemplos t\u00edpicos de esto que se no han dado son el ajuste del eje de los motores a la ranura de la rueda o el encaje de las tuercas empotradas en su alojamientos. Si no dispones de una impresora como las citadas, o similar, te aconsejamos que utilices los archivos que se suministran en el apartado 3D precisi\u00f3n media para las piezas incluidas en dicho apartado.","title":"Ficheros 3D para impresoras de alta precisi\u00f3n"},{"location":"ficheros/#archivos-fuente-de-diseno","text":"Creados con FreeCAD que puedes modificar, cambiar seg\u00fan necesidades o utilizar para aprender el manejo de esta potente herramienta. Archivo Comentarios plataforma-base-src.FCStd Para colocar el portapilas, los motores DC, el zumbador y el ballcaster o punto de apoyo estilo rueda loca soporte-zumbador-src.FCStd Para colocar un zumbador pasivo. Esta pieza tambi\u00e9n se puede colocar en la plataforma superior soporte-sensores-IR-ballcaster.FCStd Contiene dos piezas, el ballcaster y el soporte de los sensores verticales de IR soportes-ultrasonidos.FCStd Contiene los soporte fijo y m\u00f3vil para el sensor HC-SR04 plataforma-superior-src.FCStd Para colocar cualquiera de las placas, el interruptor y sujetar el servo del brazo ruedas.FCStd Rueda con una sola junta t\u00f3rica y dos versiones para dos juntas, una con esta juntas y la otra separadas. base-servo-src.FCStd Pieza para sujetar un servo tipo SG90 brazo-src.FCStd Brazo aparta objetos con alojamiento para la pala del servo separadores-src.FCStd M3x5 para placa UNO y driver y M3x28 para unir plataformas base y superior soporte-pruebas.FCStd Pieza pensada para poner encima el robot y poder hacer pruebas sin que este se mueva del sitio disco-encoder.FCStd Disco de 23 mm de di\u00e1metro con 20 ranuras acoplable a eje de motor para encoder optico conjunto-src.FCStd Muestra la colocaci\u00f3n de los distintos elementos en fase de dise\u00f1o Todo en un archivo zip Para descargar todos los archivos en un clic","title":"Archivos fuente de dise\u00f1o"},{"location":"ficheros/#archivos-stl-y-step","text":"Archivos en formato stl , listos para llevar a tu programa de laminaci\u00f3n preferido y hacerlos realidad con tu impresora. La configuraci\u00f3n de impresi\u00f3n debe adaptarse en cada caso a la impresora disponible, aunque hacemos las siguientes recomendaciones: Balsas: No Soportes de impresi\u00f3n: No Resoluci\u00f3n: 0,2 mm Relleno: 15 - 20% Marca de filamento: cualquiera Color del filamento: el preferido Material: PLA Archivos en formato step , para poder cargarlos en otros programas de dise\u00f1o CAD. En la tabla siguiente est\u00e1n los enlaces a estos dos tipos de ficheros. Imagen Archivo STL Archivo STEP ballcaster.stl ballcaster.step base-servo.stl base-servo.step brazo.stl brazo.step disco-encoder.stl disco-encoder.step plataforma-base.stl plataforma-base.step plataforma-superior.stl plataforma-superior.step rueda-una-junta.stl rueda-una-junta.step rueda-dos-juntas.stl rueda-dos-juntas.step rueda-dos-juntas-ancha.stl rueda-dos-juntas-ancha.step porta-sensores-IR.stl porta-sensores-IR.step separador-M3x5.stl separador-M3x5.step separador-M3x28.stl separador-M3x28.step soporte-para-pruebas.stl soporte-para-pruebas.step soporte-zumbador.stl soporte-zumbador.step ultrasonidos-fijo.stl ultrasonidos-fijo.step ultrasonidos-movil.stl ultrasonidos-movil.step Todos los archivos en un zip Todos los stl en un zip Todos los step en un zip","title":"Archivos STL y STEP"},{"location":"Miscelanea/about/","text":"Autores \u00b6 Este proyecto es una colaboraci\u00f3n entre distintos miembros de Club Robotica Granada y Antonio G\u00f3mez Garc\u00eda . Club Robotica Granada Federico Coca Antonio G\u00f3mez Pedro Ruiz GitHub GitHub GitHub GitHub Twitter Twitter Twitter Twitter Manuel Hidalgo Prudencio Luna Jos\u00e9 Luis Bueno Maribel Ruiz GitHub GitHub --- GitHub Twitter Twitter Twitter ---","title":"Autores"},{"location":"Miscelanea/about/#autores","text":"Este proyecto es una colaboraci\u00f3n entre distintos miembros de Club Robotica Granada y Antonio G\u00f3mez Garc\u00eda . Club Robotica Granada Federico Coca Antonio G\u00f3mez Pedro Ruiz GitHub GitHub GitHub GitHub Twitter Twitter Twitter Twitter Manuel Hidalgo Prudencio Luna Jos\u00e9 Luis Bueno Maribel Ruiz GitHub GitHub --- GitHub Twitter Twitter Twitter ---","title":"Autores"},{"location":"Miscelanea/lic/","text":"Licencias \u00b6 Licencia MIT incluida en la creaci\u00f3n del repositorio. Creative Commons Atribuci\u00f3n-CompartirIgual 4.0 International (\"CC BY-SA\"). CC BY-SA 4.0 Open Source Hardware (OSHW). Enlace a la versi\u00f3n V 1.0 original de la licencia - Enlace a la traducci\u00f3n de la versi\u00f3n V 1.0 original de la licencia - Spanish - Open Source Hardware Association","title":"Licencias"},{"location":"Miscelanea/lic/#licencias","text":"Licencia MIT incluida en la creaci\u00f3n del repositorio. Creative Commons Atribuci\u00f3n-CompartirIgual 4.0 International (\"CC BY-SA\"). CC BY-SA 4.0 Open Source Hardware (OSHW). Enlace a la versi\u00f3n V 1.0 original de la licencia - Enlace a la traducci\u00f3n de la versi\u00f3n V 1.0 original de la licencia - Spanish - Open Source Hardware Association","title":"Licencias"},{"location":"Miscelanea/soft/","text":"Software utilizado \u00b6 Dibujo 3D FreeCAD 0.19 Sistema operativo principal: Ubuntu 20.04.4 LTS (Focal Fossa) Paquete ofim\u00e1tico de referencia: LibreOffice Libreria Material para MkDocs Visual Studio Code Creaci\u00f3n de GIF animados para Ubuntu Peek Sistema principal de capturas de pantalla: Shutter 0.94 Dibujo 2D vectorial Inkscape Retoque de im\u00e1genes GIMP Creaci\u00f3n de GIF animado a partir de video con FFMPEG y GIMP IDE de Arduino Masaylo Blockly releases","title":"Software utilizado"},{"location":"Miscelanea/soft/#software-utilizado","text":"Dibujo 3D FreeCAD 0.19 Sistema operativo principal: Ubuntu 20.04.4 LTS (Focal Fossa) Paquete ofim\u00e1tico de referencia: LibreOffice Libreria Material para MkDocs Visual Studio Code Creaci\u00f3n de GIF animados para Ubuntu Peek Sistema principal de capturas de pantalla: Shutter 0.94 Dibujo 2D vectorial Inkscape Retoque de im\u00e1genes GIMP Creaci\u00f3n de GIF animado a partir de video con FFMPEG y GIMP IDE de Arduino Masaylo Blockly releases","title":"Software utilizado"},{"location":"Miscelanea/webgrafia/","text":"Webgraf\u00eda y bibliograf\u00eda \u00b6 Wikipedia Wiki de Keyestudio Blog de Luis Llamas Detalles sobre Arduino Nano CH340","title":"Webgrafia/Bibliograf\u00eda"},{"location":"Miscelanea/webgrafia/#webgrafia-y-bibliografia","text":"Wikipedia Wiki de Keyestudio Blog de Luis Llamas Detalles sobre Arduino Nano CH340","title":"Webgraf\u00eda y bibliograf\u00eda"},{"location":"conexionado-pruebas/NANO/conex-N/","text":"Conexionado de los distintos elementos \u00b6 B\u00e1sicamente el conexionado es el mismo que el visto en la versi\u00f3n UNO salvo en lo referente al zumbador que ahora se va a conectar a un pin anal\u00f3gico, por ejemplo el A0, y el sensor de infrarrojos para detecci\u00f3n de l\u00ednea izquierdo lo llevaremos a uno de los dos extra que nos ofrece la placa Nano, por ejemplo el A6. Cabr\u00eda pensar en la posibilidad de conectar el buzzer en el pin A6 o A7, pero estos pines no se pueden configurar como salida ya que son de lectura anal\u00f3gica exclusivamente. No obstante, describimos gr\u00e1ficamente el conexionado que debemos realizar entre los distintos elementos. En este caso vamos a utilizar el pinout mostrado en la imagen siguiente. La fuente de esta imagen la tenemos en este archivo svg Masaylo-CRG NANO pinout Alimentaci\u00f3n \u00b6 Seguimos el mismo procedimiento que en la versi\u00f3n UNO. En la imagen siguiente tenemos el detalle de conexionado de la alimentaci\u00f3n para ambas placas que debemos realizar de forma cuidadosa en especial y no cambiar la polaridad de la alimentaci\u00f3n que se ha marcado y dibujado con los colores normalizados de la misma. Conexionado de alimentaci\u00f3n La forma m\u00e1s sencilla de conectar los elementos es utilizando un jack de alimentaci\u00f3n con clema como el que se ve en la imagen anterior aunque tambi\u00e9n podemos utilizar un jack normal realizando las correspondientes soldaduras. Se recomienda que una vez finalizadas las conexiones se revisen estas cuidadosamente, tanto en las conexiones en si mismas como en la polaridad, antes de alimentar el sistema o conectar el USB para grabar alg\u00fan programa, as\u00ed evitaremos en lo posible romper algo por mal conexionado. Motores DC 3 a 6V \u00b6 Procedemos a conectar los motores en las bornas del driver L298 de forma que el motor izquierdo quede conectado a OUT1 - OUT2 y el derecho a OUT3 - OUT4. En la imagen siguiente tenemos el conexionado de forma gr\u00e1fica. Conexionado de motores Los pines de control de cada motor se conectan como se indica en la imagen anterior y de id\u00e9ntica forma a la descrita en la versi\u00f3n UNO. Zumbador \u00b6 Al igual que en la versi\u00f3n UNO podemos usar el pin D1 o TxD y su Vcc asociado para conectarlo o alternativamente conectarlo a alguno de los pines reservados para Bluetooth en caso de no usar esta funcionalidad asignada en el pinout. En la imagen siguiente podemos ver el conexionado de estos elementos de forma gr\u00e1fica junto con los conectados anteriormente. Conexionado de conjunto incluyendo zumbador Pines de entrada anal\u00f3gica A0-A5 \u00b6 Antes de conectar los sensores de infrarrojos, que ir\u00e1n a los pines anal\u00f3gicos (aunque su salida es digital), vamos a explicar como usar los pines anal\u00f3gicos como pines digitales en las placas Arduino. La explicaci\u00f3n original en ingl\u00e9s la podemos encontrar en el enlace \"Analog Input Pins\" . Convertidor A/D Los controladores ATmega utilizados para Arduino contienen un convertidor de anal\u00f3gico a digital integrado de 6 canales (8 canales en el Mini y Nano y 16 en el Mega) con una resoluci\u00f3n de 10 bits, devolviendo n\u00fameros enteros de 0 a 1023. Si bien la funci\u00f3n principal de los pines anal\u00f3gicos para la mayor\u00eda de los usuarios es leer sensores anal\u00f3gicos, los pines anal\u00f3gicos tambi\u00e9n tienen toda la funcionalidad de los pines de entrada/salida de prop\u00f3sito general (GPIO) (lo mismo que los pines digitales 0-13). Por tanto, si necesitamos m\u00e1s pines de entrada y salida de prop\u00f3sito general, y todos los pines anal\u00f3gicos no est\u00e1n en uso, estos pueden usarse para GPIO. Mapeo de pines Los pines anal\u00f3gicos, excepto A6 y A7, se pueden usar de manera id\u00e9ntica a los pines digitales, usando los alias A0 (para la entrada anal\u00f3gica 0), A1, etc. Por ejemplo, el c\u00f3digo para configurar el pin A0 como salida y poner en alto ser\u00eda: pinMode(A0, OUTPUT); //Solo pines A0 a A5 digitalWrite(A0, HIGH); Resistencias de pull-up Los pines anal\u00f3gicos tambi\u00e9n tienen resistencias pull-up, que funcionan de manera id\u00e9ntica a las de los pines digitales. Se habilitan emitiendo un comando del tipo: pinMode(A0, INPUT_PULLUP); // set pull-up on analog pin 0 . Hay que tener en cuenta que activar un pull-up afectar\u00e1 a los valores entregados por analogRead() . Advertencias El comando analogRead() no funcionar\u00e1 correctamente si el pin lo hemos configurado previamente como salida. Si hemos puesto el pin en estado alto estando configurado como salida, la resistencia de pull-up se configurar\u00e1 de nuevo cuando se vuelva a cambiar a entrada. La hoja de datos de ATmega advierte que el cambio de pines anal\u00f3gicos a digitales puede introducir jitter o ruido no deseado en las lecturas anal\u00f3gicas del resto de pines. Se aconseja, despu\u00e9s de poner los pines anal\u00f3gicos en modo digital, agregar un retardo corto antes de usar analogRead() . Sensores de infrarrojos \u00b6 Una vez vista la explicaci\u00f3n sobre pines anal\u00f3gicos utilizados como digitales diremos que vamos a conectar el sensor de infrarrojos izquierdo al pin A0 y el derecho al pin A1. Hay que tener especial cuidado en que los pines marcados con VCC y GND se conecten a los pines V y G respectivamente de la shield. En la imagen siguiente podemos ver el conexionado de estos elementos de forma gr\u00e1fica junto con los conectados anteriormente. Conexionado del conjunto incluyendo los sensores de infrarrojos En la imagen siguiente vemos el detalle de conexionado de los sensores de infrarrojos. Detalle del conexionado de los sensores de infrarrojos Sensor de distancia HC-SR04 \u00b6 De nuevo utilizamos dos pines anal\u00f3gicos como digitales por lo que debemos tener en cuenta lo referido anteriormente sobre el tema. Vamos a conectar el Trigger del sensor al pin A2 que deberemos configurar como salida y el pin Echo a A3 que deberemos configurar como entrada. En caso de utilizar MasayloBlockly o la librer\u00eda descrita en este tutorial estas definiciones estar\u00e1n ya realizadas. En la imagen siguiente podemos ver el conexionado de estos elementos de forma gr\u00e1fica junto con los conectados anteriormente. Conexionado del conjunto incluyendo el sensor de ultrasonidos HC-SR04 En la imagen siguiente vemos el detalle de conexionado del sensor de ultrasonidos HC-SR04. Detalle del conexionado del sensor de ultrasonidos HC-SR04 Servomotores \u00b6 En este caso los pines que utilizaremos son los digitales 4 y 5, el primero para el brazo y el segundo para la cabeza. En la imagen siguiente podemos ver el conexionado de estos elementos de forma gr\u00e1fica junto con los conectados anteriormente. Conexionado del conjunto incluyendo los servos de brazo y cabeza En la imagen siguiente vemos el detalle de conexionado de los dos servos SG90. Detalle del conexionado de los servos de brazo y cabeza Encoder infrarrojos FC-03 \u00b6 En este caso los pines que utilizaremos son los digitales 2 y 3, que son los pines que admiten interrupciones en las placas tipo UNO, Nano, Mega, Mini y Leonardo. En la imagen siguiente podemos ver el conexionado de estos elementos de forma gr\u00e1fica junto con los conectados anteriormente. Conexionado del conjunto incluyendo los encoders En la imagen siguiente vemos el detalle de conexionado de los dos encoder FC-03. Detalle del conexionado de los encoder FC-03","title":"Conexionado"},{"location":"conexionado-pruebas/NANO/conex-N/#conexionado-de-los-distintos-elementos","text":"B\u00e1sicamente el conexionado es el mismo que el visto en la versi\u00f3n UNO salvo en lo referente al zumbador que ahora se va a conectar a un pin anal\u00f3gico, por ejemplo el A0, y el sensor de infrarrojos para detecci\u00f3n de l\u00ednea izquierdo lo llevaremos a uno de los dos extra que nos ofrece la placa Nano, por ejemplo el A6. Cabr\u00eda pensar en la posibilidad de conectar el buzzer en el pin A6 o A7, pero estos pines no se pueden configurar como salida ya que son de lectura anal\u00f3gica exclusivamente. No obstante, describimos gr\u00e1ficamente el conexionado que debemos realizar entre los distintos elementos. En este caso vamos a utilizar el pinout mostrado en la imagen siguiente. La fuente de esta imagen la tenemos en este archivo svg Masaylo-CRG NANO pinout","title":"Conexionado de los distintos elementos"},{"location":"conexionado-pruebas/NANO/conex-N/#alimentacion","text":"Seguimos el mismo procedimiento que en la versi\u00f3n UNO. En la imagen siguiente tenemos el detalle de conexionado de la alimentaci\u00f3n para ambas placas que debemos realizar de forma cuidadosa en especial y no cambiar la polaridad de la alimentaci\u00f3n que se ha marcado y dibujado con los colores normalizados de la misma. Conexionado de alimentaci\u00f3n La forma m\u00e1s sencilla de conectar los elementos es utilizando un jack de alimentaci\u00f3n con clema como el que se ve en la imagen anterior aunque tambi\u00e9n podemos utilizar un jack normal realizando las correspondientes soldaduras. Se recomienda que una vez finalizadas las conexiones se revisen estas cuidadosamente, tanto en las conexiones en si mismas como en la polaridad, antes de alimentar el sistema o conectar el USB para grabar alg\u00fan programa, as\u00ed evitaremos en lo posible romper algo por mal conexionado.","title":"Alimentaci\u00f3n"},{"location":"conexionado-pruebas/NANO/conex-N/#motores-dc-3-a-6v","text":"Procedemos a conectar los motores en las bornas del driver L298 de forma que el motor izquierdo quede conectado a OUT1 - OUT2 y el derecho a OUT3 - OUT4. En la imagen siguiente tenemos el conexionado de forma gr\u00e1fica. Conexionado de motores Los pines de control de cada motor se conectan como se indica en la imagen anterior y de id\u00e9ntica forma a la descrita en la versi\u00f3n UNO.","title":"Motores DC 3 a 6V"},{"location":"conexionado-pruebas/NANO/conex-N/#zumbador","text":"Al igual que en la versi\u00f3n UNO podemos usar el pin D1 o TxD y su Vcc asociado para conectarlo o alternativamente conectarlo a alguno de los pines reservados para Bluetooth en caso de no usar esta funcionalidad asignada en el pinout. En la imagen siguiente podemos ver el conexionado de estos elementos de forma gr\u00e1fica junto con los conectados anteriormente. Conexionado de conjunto incluyendo zumbador","title":"Zumbador"},{"location":"conexionado-pruebas/NANO/conex-N/#pines-de-entrada-analogica-a0-a5","text":"Antes de conectar los sensores de infrarrojos, que ir\u00e1n a los pines anal\u00f3gicos (aunque su salida es digital), vamos a explicar como usar los pines anal\u00f3gicos como pines digitales en las placas Arduino. La explicaci\u00f3n original en ingl\u00e9s la podemos encontrar en el enlace \"Analog Input Pins\" . Convertidor A/D Los controladores ATmega utilizados para Arduino contienen un convertidor de anal\u00f3gico a digital integrado de 6 canales (8 canales en el Mini y Nano y 16 en el Mega) con una resoluci\u00f3n de 10 bits, devolviendo n\u00fameros enteros de 0 a 1023. Si bien la funci\u00f3n principal de los pines anal\u00f3gicos para la mayor\u00eda de los usuarios es leer sensores anal\u00f3gicos, los pines anal\u00f3gicos tambi\u00e9n tienen toda la funcionalidad de los pines de entrada/salida de prop\u00f3sito general (GPIO) (lo mismo que los pines digitales 0-13). Por tanto, si necesitamos m\u00e1s pines de entrada y salida de prop\u00f3sito general, y todos los pines anal\u00f3gicos no est\u00e1n en uso, estos pueden usarse para GPIO. Mapeo de pines Los pines anal\u00f3gicos, excepto A6 y A7, se pueden usar de manera id\u00e9ntica a los pines digitales, usando los alias A0 (para la entrada anal\u00f3gica 0), A1, etc. Por ejemplo, el c\u00f3digo para configurar el pin A0 como salida y poner en alto ser\u00eda: pinMode(A0, OUTPUT); //Solo pines A0 a A5 digitalWrite(A0, HIGH); Resistencias de pull-up Los pines anal\u00f3gicos tambi\u00e9n tienen resistencias pull-up, que funcionan de manera id\u00e9ntica a las de los pines digitales. Se habilitan emitiendo un comando del tipo: pinMode(A0, INPUT_PULLUP); // set pull-up on analog pin 0 . Hay que tener en cuenta que activar un pull-up afectar\u00e1 a los valores entregados por analogRead() . Advertencias El comando analogRead() no funcionar\u00e1 correctamente si el pin lo hemos configurado previamente como salida. Si hemos puesto el pin en estado alto estando configurado como salida, la resistencia de pull-up se configurar\u00e1 de nuevo cuando se vuelva a cambiar a entrada. La hoja de datos de ATmega advierte que el cambio de pines anal\u00f3gicos a digitales puede introducir jitter o ruido no deseado en las lecturas anal\u00f3gicas del resto de pines. Se aconseja, despu\u00e9s de poner los pines anal\u00f3gicos en modo digital, agregar un retardo corto antes de usar analogRead() .","title":"Pines de entrada anal\u00f3gica A0-A5"},{"location":"conexionado-pruebas/NANO/conex-N/#sensores-de-infrarrojos","text":"Una vez vista la explicaci\u00f3n sobre pines anal\u00f3gicos utilizados como digitales diremos que vamos a conectar el sensor de infrarrojos izquierdo al pin A0 y el derecho al pin A1. Hay que tener especial cuidado en que los pines marcados con VCC y GND se conecten a los pines V y G respectivamente de la shield. En la imagen siguiente podemos ver el conexionado de estos elementos de forma gr\u00e1fica junto con los conectados anteriormente. Conexionado del conjunto incluyendo los sensores de infrarrojos En la imagen siguiente vemos el detalle de conexionado de los sensores de infrarrojos. Detalle del conexionado de los sensores de infrarrojos","title":"Sensores de infrarrojos"},{"location":"conexionado-pruebas/NANO/conex-N/#sensor-de-distancia-hc-sr04","text":"De nuevo utilizamos dos pines anal\u00f3gicos como digitales por lo que debemos tener en cuenta lo referido anteriormente sobre el tema. Vamos a conectar el Trigger del sensor al pin A2 que deberemos configurar como salida y el pin Echo a A3 que deberemos configurar como entrada. En caso de utilizar MasayloBlockly o la librer\u00eda descrita en este tutorial estas definiciones estar\u00e1n ya realizadas. En la imagen siguiente podemos ver el conexionado de estos elementos de forma gr\u00e1fica junto con los conectados anteriormente. Conexionado del conjunto incluyendo el sensor de ultrasonidos HC-SR04 En la imagen siguiente vemos el detalle de conexionado del sensor de ultrasonidos HC-SR04. Detalle del conexionado del sensor de ultrasonidos HC-SR04","title":"Sensor de distancia HC-SR04"},{"location":"conexionado-pruebas/NANO/conex-N/#servomotores","text":"En este caso los pines que utilizaremos son los digitales 4 y 5, el primero para el brazo y el segundo para la cabeza. En la imagen siguiente podemos ver el conexionado de estos elementos de forma gr\u00e1fica junto con los conectados anteriormente. Conexionado del conjunto incluyendo los servos de brazo y cabeza En la imagen siguiente vemos el detalle de conexionado de los dos servos SG90. Detalle del conexionado de los servos de brazo y cabeza","title":"Servomotores"},{"location":"conexionado-pruebas/NANO/conex-N/#encoder-infrarrojos-fc-03","text":"En este caso los pines que utilizaremos son los digitales 2 y 3, que son los pines que admiten interrupciones en las placas tipo UNO, Nano, Mega, Mini y Leonardo. En la imagen siguiente podemos ver el conexionado de estos elementos de forma gr\u00e1fica junto con los conectados anteriormente. Conexionado del conjunto incluyendo los encoders En la imagen siguiente vemos el detalle de conexionado de los dos encoder FC-03. Detalle del conexionado de los encoder FC-03","title":"Encoder infrarrojos FC-03"},{"location":"conexionado-pruebas/NANO/elementos-N/","text":"Descripci\u00f3n de placas y sensores \u00b6 En este apartado vamos a realizar una descripci\u00f3n b\u00e1sica de las distintas placas que se utilizan para esta versi\u00f3n del robot y que sean diferentes a los elementos ya descritos en la entrada de \u00edndice correspondiente a la versi\u00f3n UNO. Indicar tambi\u00e9n que el montaje del robot sigue las mismas pautas que las descritas en los ensamblados y que se utilizan exactamente las mismas piezas 3D. Placa Shield para Nano V3.0 \u00b6 Se trata de una placa que b\u00e1sicamente lo que hace es transformar a formato UNO la versi\u00f3n de placa Nano V3. La placa incorpora conectores de 3 pines que incluyen la patilla asociada y la alimentaci\u00f3n y que facilita el conexionado de elementos sin necesidad de utilizar protoboard. En la imagen siguiente podemos ver esta placa con sus descripciones b\u00e1sicas y este es el enlace al archivo fuente . Placa Shield Nano V3.0 Tambi\u00e9n es importante tener disponible un gr\u00e1fico con la funcionalidad de cada pin o diagrama pinout como el que vemos en la imagen siguiente correspondiente a la placa Nano. En este enlace tenemos su archivo fuente Pinout de la Placa Nano V3.0 En la imagen siguiente podemos observar la shield con la placa Nano montada y vemos como tiene el mismo formato que una placa UNO. Shield para la placa Nano V3.0 Elementos descritos en la versi\u00f3n UNO \u00b6 Los elementos que se relacionan a continuaci\u00f3n son exactamente los mismo que los usados en la versi\u00f3n UNO: Placa Drivers L298 Motores DC 3 a 6V Zumbador Sensores de infrarrojos Sensor de distancia HC-SR04 Servomotores Encoder infrarrojos FC-03","title":"An\u00e1lisis de elementos"},{"location":"conexionado-pruebas/NANO/elementos-N/#descripcion-de-placas-y-sensores","text":"En este apartado vamos a realizar una descripci\u00f3n b\u00e1sica de las distintas placas que se utilizan para esta versi\u00f3n del robot y que sean diferentes a los elementos ya descritos en la entrada de \u00edndice correspondiente a la versi\u00f3n UNO. Indicar tambi\u00e9n que el montaje del robot sigue las mismas pautas que las descritas en los ensamblados y que se utilizan exactamente las mismas piezas 3D.","title":"Descripci\u00f3n de placas y sensores"},{"location":"conexionado-pruebas/NANO/elementos-N/#placa-shield-para-nano-v30","text":"Se trata de una placa que b\u00e1sicamente lo que hace es transformar a formato UNO la versi\u00f3n de placa Nano V3. La placa incorpora conectores de 3 pines que incluyen la patilla asociada y la alimentaci\u00f3n y que facilita el conexionado de elementos sin necesidad de utilizar protoboard. En la imagen siguiente podemos ver esta placa con sus descripciones b\u00e1sicas y este es el enlace al archivo fuente . Placa Shield Nano V3.0 Tambi\u00e9n es importante tener disponible un gr\u00e1fico con la funcionalidad de cada pin o diagrama pinout como el que vemos en la imagen siguiente correspondiente a la placa Nano. En este enlace tenemos su archivo fuente Pinout de la Placa Nano V3.0 En la imagen siguiente podemos observar la shield con la placa Nano montada y vemos como tiene el mismo formato que una placa UNO. Shield para la placa Nano V3.0","title":"Placa Shield para Nano V3.0"},{"location":"conexionado-pruebas/NANO/elementos-N/#elementos-descritos-en-la-version-uno","text":"Los elementos que se relacionan a continuaci\u00f3n son exactamente los mismo que los usados en la versi\u00f3n UNO: Placa Drivers L298 Motores DC 3 a 6V Zumbador Sensores de infrarrojos Sensor de distancia HC-SR04 Servomotores Encoder infrarrojos FC-03","title":"Elementos descritos en la versi\u00f3n UNO"},{"location":"conexionado-pruebas/NANO/leer-antes/","text":"Aclaraciones sobre placas Nano \u00b6 Vamos a analizar y establecer las diferencias entre un Arduino Nano original y las versiones econ\u00f3micas de este, al menos en dos versiones de estas. si vamos a trabajar con placas Arduino Nano originales podemos omitir la lectura de este apartado, pero si vamos a trabajar con clones (las conocidas como nanos chinos) es MUY IMPORTANTE que leamos detenidamente este apartado con el fin de averiguar que placa nano es la que tenemos en nuestras manos y as\u00ed poder actuar en consecuencia. Si hay que aclarar que este estudio se realiza para la versi\u00f3n nano convencional implementada con microcontroladores ATMega y no para la nueva l\u00ednea de productos cuyo cerebro se implementa con dispositivos microcontroladores SAMD21G18A. An\u00e1lisis del problema \u00b6 Conocemos que la alimentaci\u00f3n de la placas nano se puede hacer por mini-USB, por el conector 5V o por la entrada de alimentaci\u00f3n externa VIN, que se aconseja que est\u00e9 entre 7V y 12V de corriente continua. Aconsejamos consultar el tutorial Alimentar el Arduino: La gu\u00eda definitiva de Geek factory si no sabes bien de lo que estamos hablando. Cuando descendemos a nivel de esquema, las placas tipo Nano utilizan un diodo Schottky (diodo semiconductor que proporciona conmutaciones de menos de 1ns entre los estados de conducci\u00f3n directa e inversa) entre la alimentaci\u00f3n USB y Vcc que tiene como misi\u00f3n evitar que pueda pasar corriente desde la placa Nano al ordenador al que la tengamos conectada a trav\u00e9s del puerto USB cuando alimentamos con una fuente externa 6 a 12V en el pin VIN, que podr\u00eda provocar da\u00f1os en el mismo. En la imagen siguiente podemos ver este diodo en el esquema de un Arduino Nano original Diodo Schottky USB en Arduino Nano original Imagen obtenida a partir del esquema encontrado en arduino.cc En la imagen anterior vemos que el diodo es un SS1P3L, en algunas versiones podemos encontrar que el diodo es un MBR0520 (ya obsoleto) y en una placa real como la de la imagen siguiente que este diodo es un SKL14 de Diotec. Diodo Schottky USB SKL14 en Arduino Nano original Si consultamos los datasheet de estos diodos nos vamos a encontrar con los valores de corriente directa media que vemos en la tabla siguiente: Par\u00e1metro SS1P3L MBR0520 SKL14 Average Forward Rectified Current 1A 500mA 1A Si hacemos el mismo an\u00e1lisis para un clon como el de AZ-Delivery nos encontramos que ese diodo es un SD101CWS, tal y como vemos en la imagen siguiente: Diodo Schottky USB en Nano clon Imagen obtenida a partir del esquema encontrado en AZ-Delivery Si consultamos el datasheet de este diodo nos vamos a encontrar con el valor de corriente directa media que vemos en la tabla siguiente: Par\u00e1metro SD101CWS Average Forward Current 30mA Un poco mas de investigaci\u00f3n la podemos ver en la imagen siguiente, que se corresponde con la fotograf\u00eda de una placa Nano de AZ-Delivery. Diodo Schottky USB S4 en una Nano de AZ-Delivery Una b\u00fasqueda del datasheet de este componente nos lleva a obtenerla de Diodes y en este pdf obtenemos los datos que vemos en la imagen siguiente: Datasheet del diodo S4 Imagen obtenida a partir del datasheet de Diodes Observamos claramente que la corriente directa del diodo est\u00e1 por debajo de las especificaciones requeridas para una placa Nano por lo que debemos asegurarnos, cuando adquirimos este tipo de placas, de que diodo llevan y que al menos presente las especificaciones de 500mA en adelante. La experiencia indica que, aunque con estas placas podemos trabajar grabando el firmware, desconectando el USB y aliment\u00e1ndola con una fuente externa, tarde o temprano dejaremos conectado el USB, accionaremos la alimentaci\u00f3n externa y provocaremos una circulaci\u00f3n de corriente (si tenemos conectados suficientes dispositivos a la placa) mayor a la que soporta el diodo que se quemar\u00e1 y dejar\u00e1 la placa inservible. Recomendaciones \u00b6 L\u00f3gicamente la primera va a ser trabajar con placas originales que nos ofrecer\u00e1n todas las garant\u00edas por su contrastada calidad y su precio tampoco es demasiado elevado ya que podemos encontrarlas por unos 20\u20ac. Por ejemplo BricoGeek es un distribuidor que env\u00eda con bastante rapidez. En segundo lugar la recomendaci\u00f3n ser\u00eda la placa de Keyestudio ks0173 que distribuye oficialmente para Espa\u00f1a Innova Didactic por un precio de unos 7\u20ac y que tambi\u00e9n tiene una distribuci\u00f3n muy r\u00e1pida. En tercer lugar, aunque l\u00f3gicamente existen otros muchos fabricante de clones, ser\u00eda Elegoo que en Espa\u00f1a podemos comprar a trav\u00e9s de Amazon un kit de tres placas muy bien embaladas y por unos 14\u20ac. Las versiones de Keyestudio (derecha) y Elegoo (izquierda) se construyen con un diodo tipo B2 tal y como vemos destacado en la imagen siguiente: Placas con diodo B2 B2 es el c\u00f3digo de dispositivo de los diodos tipo MBR0520LT1G, SBR80520LT1G, MBR0520LT3G, SBR80520LT3G tal y como podemos observar en la siguiente imagen: Datasheet diodo tipo B2 Imagen obtenida a partir del datasheet de On Semiconductor En esta hoja de datos podemos comprobar que la corriente directa de este diodo es la que se indica a continuaci\u00f3n: Par\u00e1metro MBR0520LT1G B2 Average Forward Current 500mA Es decir, la recomendaci\u00f3n final ser\u00eda que antes de comprar a la ligera este tipo de producto no nos guiemos solamente por su precio y miremos tambi\u00e9n la calidad.","title":"\u00a1MUY IMPORTANTE! Leer antes de seguir"},{"location":"conexionado-pruebas/NANO/leer-antes/#aclaraciones-sobre-placas-nano","text":"Vamos a analizar y establecer las diferencias entre un Arduino Nano original y las versiones econ\u00f3micas de este, al menos en dos versiones de estas. si vamos a trabajar con placas Arduino Nano originales podemos omitir la lectura de este apartado, pero si vamos a trabajar con clones (las conocidas como nanos chinos) es MUY IMPORTANTE que leamos detenidamente este apartado con el fin de averiguar que placa nano es la que tenemos en nuestras manos y as\u00ed poder actuar en consecuencia. Si hay que aclarar que este estudio se realiza para la versi\u00f3n nano convencional implementada con microcontroladores ATMega y no para la nueva l\u00ednea de productos cuyo cerebro se implementa con dispositivos microcontroladores SAMD21G18A.","title":"Aclaraciones sobre placas Nano"},{"location":"conexionado-pruebas/NANO/leer-antes/#analisis-del-problema","text":"Conocemos que la alimentaci\u00f3n de la placas nano se puede hacer por mini-USB, por el conector 5V o por la entrada de alimentaci\u00f3n externa VIN, que se aconseja que est\u00e9 entre 7V y 12V de corriente continua. Aconsejamos consultar el tutorial Alimentar el Arduino: La gu\u00eda definitiva de Geek factory si no sabes bien de lo que estamos hablando. Cuando descendemos a nivel de esquema, las placas tipo Nano utilizan un diodo Schottky (diodo semiconductor que proporciona conmutaciones de menos de 1ns entre los estados de conducci\u00f3n directa e inversa) entre la alimentaci\u00f3n USB y Vcc que tiene como misi\u00f3n evitar que pueda pasar corriente desde la placa Nano al ordenador al que la tengamos conectada a trav\u00e9s del puerto USB cuando alimentamos con una fuente externa 6 a 12V en el pin VIN, que podr\u00eda provocar da\u00f1os en el mismo. En la imagen siguiente podemos ver este diodo en el esquema de un Arduino Nano original Diodo Schottky USB en Arduino Nano original Imagen obtenida a partir del esquema encontrado en arduino.cc En la imagen anterior vemos que el diodo es un SS1P3L, en algunas versiones podemos encontrar que el diodo es un MBR0520 (ya obsoleto) y en una placa real como la de la imagen siguiente que este diodo es un SKL14 de Diotec. Diodo Schottky USB SKL14 en Arduino Nano original Si consultamos los datasheet de estos diodos nos vamos a encontrar con los valores de corriente directa media que vemos en la tabla siguiente: Par\u00e1metro SS1P3L MBR0520 SKL14 Average Forward Rectified Current 1A 500mA 1A Si hacemos el mismo an\u00e1lisis para un clon como el de AZ-Delivery nos encontramos que ese diodo es un SD101CWS, tal y como vemos en la imagen siguiente: Diodo Schottky USB en Nano clon Imagen obtenida a partir del esquema encontrado en AZ-Delivery Si consultamos el datasheet de este diodo nos vamos a encontrar con el valor de corriente directa media que vemos en la tabla siguiente: Par\u00e1metro SD101CWS Average Forward Current 30mA Un poco mas de investigaci\u00f3n la podemos ver en la imagen siguiente, que se corresponde con la fotograf\u00eda de una placa Nano de AZ-Delivery. Diodo Schottky USB S4 en una Nano de AZ-Delivery Una b\u00fasqueda del datasheet de este componente nos lleva a obtenerla de Diodes y en este pdf obtenemos los datos que vemos en la imagen siguiente: Datasheet del diodo S4 Imagen obtenida a partir del datasheet de Diodes Observamos claramente que la corriente directa del diodo est\u00e1 por debajo de las especificaciones requeridas para una placa Nano por lo que debemos asegurarnos, cuando adquirimos este tipo de placas, de que diodo llevan y que al menos presente las especificaciones de 500mA en adelante. La experiencia indica que, aunque con estas placas podemos trabajar grabando el firmware, desconectando el USB y aliment\u00e1ndola con una fuente externa, tarde o temprano dejaremos conectado el USB, accionaremos la alimentaci\u00f3n externa y provocaremos una circulaci\u00f3n de corriente (si tenemos conectados suficientes dispositivos a la placa) mayor a la que soporta el diodo que se quemar\u00e1 y dejar\u00e1 la placa inservible.","title":"An\u00e1lisis del problema"},{"location":"conexionado-pruebas/NANO/leer-antes/#recomendaciones","text":"L\u00f3gicamente la primera va a ser trabajar con placas originales que nos ofrecer\u00e1n todas las garant\u00edas por su contrastada calidad y su precio tampoco es demasiado elevado ya que podemos encontrarlas por unos 20\u20ac. Por ejemplo BricoGeek es un distribuidor que env\u00eda con bastante rapidez. En segundo lugar la recomendaci\u00f3n ser\u00eda la placa de Keyestudio ks0173 que distribuye oficialmente para Espa\u00f1a Innova Didactic por un precio de unos 7\u20ac y que tambi\u00e9n tiene una distribuci\u00f3n muy r\u00e1pida. En tercer lugar, aunque l\u00f3gicamente existen otros muchos fabricante de clones, ser\u00eda Elegoo que en Espa\u00f1a podemos comprar a trav\u00e9s de Amazon un kit de tres placas muy bien embaladas y por unos 14\u20ac. Las versiones de Keyestudio (derecha) y Elegoo (izquierda) se construyen con un diodo tipo B2 tal y como vemos destacado en la imagen siguiente: Placas con diodo B2 B2 es el c\u00f3digo de dispositivo de los diodos tipo MBR0520LT1G, SBR80520LT1G, MBR0520LT3G, SBR80520LT3G tal y como podemos observar en la siguiente imagen: Datasheet diodo tipo B2 Imagen obtenida a partir del datasheet de On Semiconductor En esta hoja de datos podemos comprobar que la corriente directa de este diodo es la que se indica a continuaci\u00f3n: Par\u00e1metro MBR0520LT1G B2 Average Forward Current 500mA Es decir, la recomendaci\u00f3n final ser\u00eda que antes de comprar a la ligera este tipo de producto no nos guiemos solamente por su precio y miremos tambi\u00e9n la calidad.","title":"Recomendaciones"},{"location":"conexionado-pruebas/NANO/test-N/","text":"Pruebas b\u00e1sicas de funcionamiento \u00b6 B\u00e1sicamente los ejemplos que utilizaremos para esta versi\u00f3n Nano son los mismos que los utilizados para la versi\u00f3n UNO realizando los cambios a la placa adecuada, que en nuestro caso va a ser una Nano con Old bootloader. En el apartado de software se pueden encontrar los enlaces de descarga y toda la informaci\u00f3n de la aplicaci\u00f3n. Alimentaci\u00f3n \u00b6 Colocamos las pilas AA en su lugar respetando la polaridad de las mismas y accionamos el interruptor. Si todo es correcto en la placa shield y en la del driver L298 se debe encender un diodo LED rojo y en la placa Nano un LED verde, todos ellos indicativos de que est\u00e1n alimentadas, tal y como observamos en la imagen siguiente: Primer encendido Reutilizamos el programa blink.bloc para probar tambi\u00e9n que se graba correctamente firmware en la placa NANO. Para ello debemos seleccionar la placa adecuada, tal y como vemos en la imagen siguiente. Programa blink.bloc Si cargamos el programa y dejamos sin accionar el interruptor observaremos como parpadea el LED asociado al pin 13, de color rojo, en la placa Nano pero la placa del driver no est\u00e1 alimentada y por tanto su LED permanece apagado. En la animaci\u00f3n siguiente vemos el parpadeo del LED y el resultado de accionar el interruptor. Animaci\u00f3n que muestra el funcionamiento del programa blink.bloc y del interruptor Este GIF se ha creado a partir de un video en formato mp4 utilizando FFMPEG y GIMP y la informaci\u00f3n obtenida en este enlace . Pruebas id\u00e9nticas a las realizadas en la versi\u00f3n UNO \u00b6 Para las pruebas siguientes podemos simplemente cargar los ejemplos dados para la versi\u00f3n UNO y sin mas que cambiar el tipo de placa ya podemos proceder a cargarlos y comprobar el funcionamiento de los elementos en cuesti\u00f3n. Motores Zumbador Sensores de infrarrojos Sensor de distancia HC-SR04 Servomotores Encoder infrarrojos FC-03","title":"Pruebas b\u00e1sicas de funcionamiento"},{"location":"conexionado-pruebas/NANO/test-N/#pruebas-basicas-de-funcionamiento","text":"B\u00e1sicamente los ejemplos que utilizaremos para esta versi\u00f3n Nano son los mismos que los utilizados para la versi\u00f3n UNO realizando los cambios a la placa adecuada, que en nuestro caso va a ser una Nano con Old bootloader. En el apartado de software se pueden encontrar los enlaces de descarga y toda la informaci\u00f3n de la aplicaci\u00f3n.","title":"Pruebas b\u00e1sicas de funcionamiento"},{"location":"conexionado-pruebas/NANO/test-N/#alimentacion","text":"Colocamos las pilas AA en su lugar respetando la polaridad de las mismas y accionamos el interruptor. Si todo es correcto en la placa shield y en la del driver L298 se debe encender un diodo LED rojo y en la placa Nano un LED verde, todos ellos indicativos de que est\u00e1n alimentadas, tal y como observamos en la imagen siguiente: Primer encendido Reutilizamos el programa blink.bloc para probar tambi\u00e9n que se graba correctamente firmware en la placa NANO. Para ello debemos seleccionar la placa adecuada, tal y como vemos en la imagen siguiente. Programa blink.bloc Si cargamos el programa y dejamos sin accionar el interruptor observaremos como parpadea el LED asociado al pin 13, de color rojo, en la placa Nano pero la placa del driver no est\u00e1 alimentada y por tanto su LED permanece apagado. En la animaci\u00f3n siguiente vemos el parpadeo del LED y el resultado de accionar el interruptor. Animaci\u00f3n que muestra el funcionamiento del programa blink.bloc y del interruptor Este GIF se ha creado a partir de un video en formato mp4 utilizando FFMPEG y GIMP y la informaci\u00f3n obtenida en este enlace .","title":"Alimentaci\u00f3n"},{"location":"conexionado-pruebas/NANO/test-N/#pruebas-identicas-a-las-realizadas-en-la-version-uno","text":"Para las pruebas siguientes podemos simplemente cargar los ejemplos dados para la versi\u00f3n UNO y sin mas que cambiar el tipo de placa ya podemos proceder a cargarlos y comprobar el funcionamiento de los elementos en cuesti\u00f3n. Motores Zumbador Sensores de infrarrojos Sensor de distancia HC-SR04 Servomotores Encoder infrarrojos FC-03","title":"Pruebas id\u00e9nticas a las realizadas en la versi\u00f3n UNO"},{"location":"conexionado-pruebas/UNO/conex/","text":"Conexionado de los distintos elementos \u00b6 Describimos el conexionado que debemos realizar entre los distintos elementos, y lo haremos fundamentalmente en forma de gr\u00e1fico y utilizando el pinout mostrado en la imagen siguiente. La fuente de esta imagen la tenemos en este archivo svg Masaylo-CRG UNO pinout Alimentaci\u00f3n \u00b6 Antes de nada vamos a resolver las conexiones de alimentaci\u00f3n de nuestra placa UNO y del driver de motores L298 junto con el portapilas y el interruptor. El resto de elementos se alimentar\u00e1n directamente de la placa UNO. El conexionado es v\u00e1lido si sustituimos las cinco (o seis) pilas AA por dos bater\u00edas tipo 18650. Para que la placa UNO y el driver queden conectados con el interruptor utilizaremos una clema de la que sacaremos un cable para el jack de alimentaci\u00f3n del UNO y otro para el positivo del driver, siendo este cable el que previamente pasa por el interruptor procedente del portapilas. El negativo es un cable doble que va al UNO y al driver sin pasar por el interruptor. En estas condiciones el junper Regulador del driver debe estar colocado en su lugar y debemos tener en cuenta que la tensi\u00f3n de entrada caer\u00e1 en 0.7V debido al diodo protector de inversi\u00f3n de polaridad que lleva la placa. Esto lo podemos evitar utilizando el pin Vin de la tira de pines de alimentaci\u00f3n, pero debemos tener en cuenta que as\u00ed no hay protecci\u00f3n y que se recomienda no usar tensiones superiores a 6V. En nuestro caso usamos 5 pilas AA con lo que partimos de una tensi\u00f3n de 7.5V que bajar\u00e1 aproximadamente a 6.8V y si usamos 2x18650 tendremos 7.2V que se quedar\u00e1n en 6.5V. En la imagen siguiente tenemos el detalle de conexionado de la alimentaci\u00f3n para ambas placas que debemos realizar de forma cuidadosa en especial y no cambiar la polaridad de la alimentaci\u00f3n que se ha marcado y dibujado con los colores normalizados de la misma. Conexionado de alimentaci\u00f3n La forma m\u00e1s sencilla de conectar los elementos es utilizando un jack de alimentaci\u00f3n con clema como el que se ve en la imagen anterior aunque tambi\u00e9n podemos utilizar un jack normal realizando las correspondientes soldaduras. Se recomienda que una vez finalizadas las conexiones se revisen estas cuidadosamente, tanto en las conexiones en si mismas como en la polaridad, antes de alimentar el sistema o conectar el USB para grabar alg\u00fan programa, as\u00ed evitaremos en lo posible romper algo por mal conexionado. Motores DC 3 a 6V \u00b6 Procedemos a conectar los motores en las bornas del driver L298 de forma que el motor izquierdo quede conectado a OUT1 - OUT2 y el derecho a OUT3 - OUT4 que son los pines encaargados de entregar energia a los motores. Por ahora no nos preocupamos de la polaridad ya que lo haremos en las pruebas y si alg\u00fan motor girar en sentido contrario al esperado bastar\u00e1 con intercambiar sus conexiones de posici\u00f3n. En la imagen siguiente tenemos el conexionado de forma gr\u00e1fica. Conexionado de motores Los pines de control de cada motor se conectan como se indica en la gr\u00e1fica, de forma que ENA ser\u00e1 el control PWM del motor izquierdo que se har\u00e1 en el pin 6, e IN1 e IN2 los conectamos seg\u00fan el sentido de giro adecuado a los pines 7 y 8. Para el motor derecho el pin PWM es el 11 que ir\u00e1 a ENB y los IN3 e IN4 a los pines 12 y 13. Zumbador \u00b6 Usamos el pin D1 o TxD y su Vcc asociado para conectarlo. En principio esta conexi\u00f3n no debe interferir en la grabaci\u00f3n de programas en la placa que siempre se realiza utilizando los pines D0 y D1 de la misma, pero si nos da alg\u00fan problema basta con que desconectemos el pin D0 del sensor en uno de sus extremos, procedamos a grabar el programa correspondiente y una vez cargado este volvemos a conectar el pin en su lugar. Si no queremos estar escuchando pitidos de manera continuada cuando subimos c\u00f3digo a la placa o cuando usamos el monitor serie tambi\u00e9n debemos desconectar esta patilla. Alternativamente y en caso de no usar la funcionalidad Bluetooth podemos conectar el buzzer a uno de los pines reservados para esta funcionalidad en el pinout. En la imagen siguiente podemos ver el conexionado de estos elementos de forma gr\u00e1fica junto con los conectados anteriormente. Conexionado de conjunto incluyendo zumbador En la imagen siguiente observamos una pareja de cables, uno blanco que va al pin D1 y uno negro que va a GND. Conexionado del zumbador Pines de entrada anal\u00f3gica \u00b6 Antes de conectar los sensores de infrarrojos, que ir\u00e1n a los pines anal\u00f3gicos (aunque su salida es digital), vamos a explicar como usar los pines anal\u00f3gicos como pines digitales en las placas Arduino. La explicaci\u00f3n original en ingl\u00e9s la podemos encontrar en el enlace \"Analog Input Pins\" . Convertidor A/D Los controladores ATmega utilizados para Arduino contienen un convertidor de anal\u00f3gico a digital integrado de 6 canales (8 canales en el Mini y Nano y 16 en el Mega) con una resoluci\u00f3n de 10 bits, devolviendo n\u00fameros enteros de 0 a 1023. Si bien la funci\u00f3n principal de los pines anal\u00f3gicos para la mayor\u00eda de los usuarios es leer sensores anal\u00f3gicos, los pines anal\u00f3gicos tambi\u00e9n tienen toda la funcionalidad de los pines de entrada/salida de prop\u00f3sito general (GPIO) (lo mismo que los pines digitales 0-13). Por tanto, si necesitamos m\u00e1s pines de entrada y salida de prop\u00f3sito general, y todos los pines anal\u00f3gicos no est\u00e1n en uso, estos pueden usarse para GPIO. Mapeo de pines Los pines anal\u00f3gicos se pueden usar de manera id\u00e9ntica a los pines digitales, usando los alias A0 (para la entrada anal\u00f3gica 0), A1, etc. Por ejemplo, el c\u00f3digo para configurar el pin A0 como salida y poner en alto ser\u00eda: pinMode(A0, OUTPUT); digitalWrite(A0, HIGH); Resistencias de pull-up Los pines anal\u00f3gicos tambi\u00e9n tienen resistencias pull-up, que funcionan de manera id\u00e9ntica a las de los pines digitales. Se habilitan emitiendo un comando del tipo: pinMode(A0, INPUT_PULLUP); // set pull-up on analog pin 0 . Hay que tener en cuenta que activar un pull-up afectar\u00e1 a los valores entregados por analogRead() . Advertencias El comando analogRead() no funcionar\u00e1 correctamente si el pin lo hemos configurado previamente como salida. Si hemos puesto el pin en estado alto estando configurado como salida, la resistencia de pull-up se configurar\u00e1 de nuevo cuando se vuelva a cambiar a entrada. La hoja de datos de ATmega advierte que el cambio de pines anal\u00f3gicos a digitales puede introducir jitter o ruido no deseado en las lecturas anal\u00f3gicas del resto de pines. Se aconseja, despu\u00e9s de poner los pines anal\u00f3gicos en modo digital, agregar un retardo corto antes de usar analogRead() . Sensores de infrarrojos \u00b6 Una vez vista la explicaci\u00f3n sobre pines anal\u00f3gicos utilizados como digitales diremos que vamos a conectar el sensor de infrarrojos izquierdo al pin A0 y el derecho al pin A1. Hay que tener especial cuidado en que los pines marcados con VCC y GND se conecten a los pines V y G respectivamente de la placa UNO. En la imagen siguiente podemos ver el conexionado de estos elementos de forma gr\u00e1fica junto con los conectados anteriormente. Conexionado del conjunto incluyendo los sensores de infrarrojos En la imagen siguiente vemos el detalle de conexionado de los sensores de infrarrojos. Detalle del conexionado de los sensores de infrarrojos Una fotograf\u00eda del detalle del conexionado en el robot la vemos a continuaci\u00f3n. Fotograf\u00eda del conexionado de los sensores de infrarrojos Sensor de distancia HC-SR04 \u00b6 De nuevo utilizamos dos pines anal\u00f3gicos como digitales por lo que debemos tener en cuenta lo referido anteriormente sobre el tema. Vamos a conectar el Trigger del sensor al pin A2 que deberemos configurar como salida y el pin Echo a A3 que deberemos configurar como entrada. En caso de utilizar MasayloBlockly o la librer\u00eda descrita en este tutorial estas definiciones estar\u00e1n ya realizadas. En la imagen siguiente podemos ver el conexionado de estos elementos de forma gr\u00e1fica junto con los conectados anteriormente. Se han omitido intencionadamente los cables de alimentaci\u00f3n del sensor para mayor claridad de la imagen. Conexionado del conjunto incluyendo el sensor de ultrasonidos HC-SR04 En la imagen siguiente vemos el detalle de conexionado del sensor de ultrasonidos HC-SR04 incluidos los pines de alimentaci\u00f3n. Detalle del conexionado del sensor de ultrasonidos HC-SR04 Una fotograf\u00eda del detalle del conexionado en el robot la vemos a continuaci\u00f3n. Fotograf\u00eda del conexionado del sensor de ultrasonidos HC-SR04 Servomotores \u00b6 En este caso los pines que utilizaremos son los digitales 4 y 5, el primero para el brazo y el segundo para la cabeza. En la imagen siguiente podemos ver el conexionado de estos elementos de forma gr\u00e1fica junto con los conectados anteriormente. Se han omitido de nuevo las conexiones de alimentaci\u00f3n. Conexionado del conjunto incluyendo los servos de brazo y cabeza En la imagen siguiente vemos el detalle de conexionado de los dos servos SG90. Detalle del conexionado de los servos de brazo y cabeza Una fotograf\u00eda del detalle del conexionado en el robot la vemos a continuaci\u00f3n. Fotograf\u00eda del conexionado de los servos de brazo y cabeza Encoder infrarrojos FC-03 \u00b6 En este caso los pines que utilizaremos son los digitales 2 y 3, que son los pines que admiten interrupciones en las placas tipo UNO, Nano, Mega, Mini y Leonardo. En la imagen siguiente (se omiten los cables de alimentaci\u00f3n para mayor claridad) podemos ver el conexionado de estos elementos de forma gr\u00e1fica junto con los conectados anteriormente. Conexionado del conjunto incluyendo los encoders En la imagen siguiente vemos el detalle de conexionado de los dos encoder FC-03. Detalle del conexionado de los encoder FC-03 Una fotograf\u00eda del detalle del conexionado en el robot la vemos a continuaci\u00f3n. Fotograf\u00eda del conexionado de los encoder FC-03","title":"Conexionado"},{"location":"conexionado-pruebas/UNO/conex/#conexionado-de-los-distintos-elementos","text":"Describimos el conexionado que debemos realizar entre los distintos elementos, y lo haremos fundamentalmente en forma de gr\u00e1fico y utilizando el pinout mostrado en la imagen siguiente. La fuente de esta imagen la tenemos en este archivo svg Masaylo-CRG UNO pinout","title":"Conexionado de los distintos elementos"},{"location":"conexionado-pruebas/UNO/conex/#alimentacion","text":"Antes de nada vamos a resolver las conexiones de alimentaci\u00f3n de nuestra placa UNO y del driver de motores L298 junto con el portapilas y el interruptor. El resto de elementos se alimentar\u00e1n directamente de la placa UNO. El conexionado es v\u00e1lido si sustituimos las cinco (o seis) pilas AA por dos bater\u00edas tipo 18650. Para que la placa UNO y el driver queden conectados con el interruptor utilizaremos una clema de la que sacaremos un cable para el jack de alimentaci\u00f3n del UNO y otro para el positivo del driver, siendo este cable el que previamente pasa por el interruptor procedente del portapilas. El negativo es un cable doble que va al UNO y al driver sin pasar por el interruptor. En estas condiciones el junper Regulador del driver debe estar colocado en su lugar y debemos tener en cuenta que la tensi\u00f3n de entrada caer\u00e1 en 0.7V debido al diodo protector de inversi\u00f3n de polaridad que lleva la placa. Esto lo podemos evitar utilizando el pin Vin de la tira de pines de alimentaci\u00f3n, pero debemos tener en cuenta que as\u00ed no hay protecci\u00f3n y que se recomienda no usar tensiones superiores a 6V. En nuestro caso usamos 5 pilas AA con lo que partimos de una tensi\u00f3n de 7.5V que bajar\u00e1 aproximadamente a 6.8V y si usamos 2x18650 tendremos 7.2V que se quedar\u00e1n en 6.5V. En la imagen siguiente tenemos el detalle de conexionado de la alimentaci\u00f3n para ambas placas que debemos realizar de forma cuidadosa en especial y no cambiar la polaridad de la alimentaci\u00f3n que se ha marcado y dibujado con los colores normalizados de la misma. Conexionado de alimentaci\u00f3n La forma m\u00e1s sencilla de conectar los elementos es utilizando un jack de alimentaci\u00f3n con clema como el que se ve en la imagen anterior aunque tambi\u00e9n podemos utilizar un jack normal realizando las correspondientes soldaduras. Se recomienda que una vez finalizadas las conexiones se revisen estas cuidadosamente, tanto en las conexiones en si mismas como en la polaridad, antes de alimentar el sistema o conectar el USB para grabar alg\u00fan programa, as\u00ed evitaremos en lo posible romper algo por mal conexionado.","title":"Alimentaci\u00f3n"},{"location":"conexionado-pruebas/UNO/conex/#motores-dc-3-a-6v","text":"Procedemos a conectar los motores en las bornas del driver L298 de forma que el motor izquierdo quede conectado a OUT1 - OUT2 y el derecho a OUT3 - OUT4 que son los pines encaargados de entregar energia a los motores. Por ahora no nos preocupamos de la polaridad ya que lo haremos en las pruebas y si alg\u00fan motor girar en sentido contrario al esperado bastar\u00e1 con intercambiar sus conexiones de posici\u00f3n. En la imagen siguiente tenemos el conexionado de forma gr\u00e1fica. Conexionado de motores Los pines de control de cada motor se conectan como se indica en la gr\u00e1fica, de forma que ENA ser\u00e1 el control PWM del motor izquierdo que se har\u00e1 en el pin 6, e IN1 e IN2 los conectamos seg\u00fan el sentido de giro adecuado a los pines 7 y 8. Para el motor derecho el pin PWM es el 11 que ir\u00e1 a ENB y los IN3 e IN4 a los pines 12 y 13.","title":"Motores DC 3 a 6V"},{"location":"conexionado-pruebas/UNO/conex/#zumbador","text":"Usamos el pin D1 o TxD y su Vcc asociado para conectarlo. En principio esta conexi\u00f3n no debe interferir en la grabaci\u00f3n de programas en la placa que siempre se realiza utilizando los pines D0 y D1 de la misma, pero si nos da alg\u00fan problema basta con que desconectemos el pin D0 del sensor en uno de sus extremos, procedamos a grabar el programa correspondiente y una vez cargado este volvemos a conectar el pin en su lugar. Si no queremos estar escuchando pitidos de manera continuada cuando subimos c\u00f3digo a la placa o cuando usamos el monitor serie tambi\u00e9n debemos desconectar esta patilla. Alternativamente y en caso de no usar la funcionalidad Bluetooth podemos conectar el buzzer a uno de los pines reservados para esta funcionalidad en el pinout. En la imagen siguiente podemos ver el conexionado de estos elementos de forma gr\u00e1fica junto con los conectados anteriormente. Conexionado de conjunto incluyendo zumbador En la imagen siguiente observamos una pareja de cables, uno blanco que va al pin D1 y uno negro que va a GND. Conexionado del zumbador","title":"Zumbador"},{"location":"conexionado-pruebas/UNO/conex/#pines-de-entrada-analogica","text":"Antes de conectar los sensores de infrarrojos, que ir\u00e1n a los pines anal\u00f3gicos (aunque su salida es digital), vamos a explicar como usar los pines anal\u00f3gicos como pines digitales en las placas Arduino. La explicaci\u00f3n original en ingl\u00e9s la podemos encontrar en el enlace \"Analog Input Pins\" . Convertidor A/D Los controladores ATmega utilizados para Arduino contienen un convertidor de anal\u00f3gico a digital integrado de 6 canales (8 canales en el Mini y Nano y 16 en el Mega) con una resoluci\u00f3n de 10 bits, devolviendo n\u00fameros enteros de 0 a 1023. Si bien la funci\u00f3n principal de los pines anal\u00f3gicos para la mayor\u00eda de los usuarios es leer sensores anal\u00f3gicos, los pines anal\u00f3gicos tambi\u00e9n tienen toda la funcionalidad de los pines de entrada/salida de prop\u00f3sito general (GPIO) (lo mismo que los pines digitales 0-13). Por tanto, si necesitamos m\u00e1s pines de entrada y salida de prop\u00f3sito general, y todos los pines anal\u00f3gicos no est\u00e1n en uso, estos pueden usarse para GPIO. Mapeo de pines Los pines anal\u00f3gicos se pueden usar de manera id\u00e9ntica a los pines digitales, usando los alias A0 (para la entrada anal\u00f3gica 0), A1, etc. Por ejemplo, el c\u00f3digo para configurar el pin A0 como salida y poner en alto ser\u00eda: pinMode(A0, OUTPUT); digitalWrite(A0, HIGH); Resistencias de pull-up Los pines anal\u00f3gicos tambi\u00e9n tienen resistencias pull-up, que funcionan de manera id\u00e9ntica a las de los pines digitales. Se habilitan emitiendo un comando del tipo: pinMode(A0, INPUT_PULLUP); // set pull-up on analog pin 0 . Hay que tener en cuenta que activar un pull-up afectar\u00e1 a los valores entregados por analogRead() . Advertencias El comando analogRead() no funcionar\u00e1 correctamente si el pin lo hemos configurado previamente como salida. Si hemos puesto el pin en estado alto estando configurado como salida, la resistencia de pull-up se configurar\u00e1 de nuevo cuando se vuelva a cambiar a entrada. La hoja de datos de ATmega advierte que el cambio de pines anal\u00f3gicos a digitales puede introducir jitter o ruido no deseado en las lecturas anal\u00f3gicas del resto de pines. Se aconseja, despu\u00e9s de poner los pines anal\u00f3gicos en modo digital, agregar un retardo corto antes de usar analogRead() .","title":"Pines de entrada anal\u00f3gica"},{"location":"conexionado-pruebas/UNO/conex/#sensores-de-infrarrojos","text":"Una vez vista la explicaci\u00f3n sobre pines anal\u00f3gicos utilizados como digitales diremos que vamos a conectar el sensor de infrarrojos izquierdo al pin A0 y el derecho al pin A1. Hay que tener especial cuidado en que los pines marcados con VCC y GND se conecten a los pines V y G respectivamente de la placa UNO. En la imagen siguiente podemos ver el conexionado de estos elementos de forma gr\u00e1fica junto con los conectados anteriormente. Conexionado del conjunto incluyendo los sensores de infrarrojos En la imagen siguiente vemos el detalle de conexionado de los sensores de infrarrojos. Detalle del conexionado de los sensores de infrarrojos Una fotograf\u00eda del detalle del conexionado en el robot la vemos a continuaci\u00f3n. Fotograf\u00eda del conexionado de los sensores de infrarrojos","title":"Sensores de infrarrojos"},{"location":"conexionado-pruebas/UNO/conex/#sensor-de-distancia-hc-sr04","text":"De nuevo utilizamos dos pines anal\u00f3gicos como digitales por lo que debemos tener en cuenta lo referido anteriormente sobre el tema. Vamos a conectar el Trigger del sensor al pin A2 que deberemos configurar como salida y el pin Echo a A3 que deberemos configurar como entrada. En caso de utilizar MasayloBlockly o la librer\u00eda descrita en este tutorial estas definiciones estar\u00e1n ya realizadas. En la imagen siguiente podemos ver el conexionado de estos elementos de forma gr\u00e1fica junto con los conectados anteriormente. Se han omitido intencionadamente los cables de alimentaci\u00f3n del sensor para mayor claridad de la imagen. Conexionado del conjunto incluyendo el sensor de ultrasonidos HC-SR04 En la imagen siguiente vemos el detalle de conexionado del sensor de ultrasonidos HC-SR04 incluidos los pines de alimentaci\u00f3n. Detalle del conexionado del sensor de ultrasonidos HC-SR04 Una fotograf\u00eda del detalle del conexionado en el robot la vemos a continuaci\u00f3n. Fotograf\u00eda del conexionado del sensor de ultrasonidos HC-SR04","title":"Sensor de distancia HC-SR04"},{"location":"conexionado-pruebas/UNO/conex/#servomotores","text":"En este caso los pines que utilizaremos son los digitales 4 y 5, el primero para el brazo y el segundo para la cabeza. En la imagen siguiente podemos ver el conexionado de estos elementos de forma gr\u00e1fica junto con los conectados anteriormente. Se han omitido de nuevo las conexiones de alimentaci\u00f3n. Conexionado del conjunto incluyendo los servos de brazo y cabeza En la imagen siguiente vemos el detalle de conexionado de los dos servos SG90. Detalle del conexionado de los servos de brazo y cabeza Una fotograf\u00eda del detalle del conexionado en el robot la vemos a continuaci\u00f3n. Fotograf\u00eda del conexionado de los servos de brazo y cabeza","title":"Servomotores"},{"location":"conexionado-pruebas/UNO/conex/#encoder-infrarrojos-fc-03","text":"En este caso los pines que utilizaremos son los digitales 2 y 3, que son los pines que admiten interrupciones en las placas tipo UNO, Nano, Mega, Mini y Leonardo. En la imagen siguiente (se omiten los cables de alimentaci\u00f3n para mayor claridad) podemos ver el conexionado de estos elementos de forma gr\u00e1fica junto con los conectados anteriormente. Conexionado del conjunto incluyendo los encoders En la imagen siguiente vemos el detalle de conexionado de los dos encoder FC-03. Detalle del conexionado de los encoder FC-03 Una fotograf\u00eda del detalle del conexionado en el robot la vemos a continuaci\u00f3n. Fotograf\u00eda del conexionado de los encoder FC-03","title":"Encoder infrarrojos FC-03"},{"location":"conexionado-pruebas/UNO/elementos/","text":"Descripci\u00f3n de placas y sensores \u00b6 En este apartado vamos a realizar una descripci\u00f3n b\u00e1sica de las distintas placas, sensores y elementos que se utilizan en la construcci\u00f3n del robot. Placa Keyestudio UNO Ks0172 \u00b6 Se trata de la placa Ks0172 basada en Arduino UNO con el microcontrolador ATmega328P que incorpora conectores de 3 pines que incluyen la patilla asociada y la alimentaci\u00f3n y que facilita el conexionado de elementos sin necesidad de utilizar protoboard. En la imagen siguiente podemos ver esta placa con sus descripciones b\u00e1sicas y este es el enlace al archivo fuente . Placa Keyestudio UNO Ks0172 IMPORTANTE: El interruptor deslizante permite escoger entre las alimentaciones de 5V o 3.3V. En nuestro caso nos aseguraremos de que est\u00e1 en la posici\u00f3n 5V . Tambi\u00e9n es importante tener disponible un gr\u00e1fico con la funcionalidad de cada pin o diagrama pinout como el que vemos en la imagen siguiente y este es el enlace a su archivo fuente Pinout de la Placa Keyestudio UNO Ks0172 Placa Drivers L298 \u00b6 Esta placa est\u00e1 basada en el chip L298N y permite controlar la velocidad y el sentido de giro de dos motores de corriente continua o un motor paso a paso bipolar con un consumo m\u00e1ximo de dos amperios. Cuenta con diodos de protecci\u00f3n y un regulador LM7805 que suministra 5V a la parte l\u00f3gica del integrado L298N. Se disponen jumpers de selecci\u00f3n para habilitar cada una de las salidas del m\u00f3dulo (A y B). La salida A esta conformada por OUT1 y OUT2 y la salida B por OUT3 y OUT4. Los pines de habilitaci\u00f3n son ENA y ENB (Enable A y Enable B) respectivamente. En la siguiente imagen vemos esta placa con sus descripciones b\u00e1sicas y este es el enlace al archivo fuente . Placa L298 Este m\u00f3dulo con el L298N nos permite alimentar nuestro Arduino a partir de la salida de 5V con un l\u00edmite de 500 mA. Debemos tambi\u00e9n tener presente que el m\u00f3dulo entrega una tensi\u00f3n a los motores en torno a 3V menor que la tensi\u00f3n a la que lo alimentamos. Los pines Vin y GND son los de alimentaci\u00f3n del m\u00f3dulo con una tensi\u00f3n que puede ir de 3V a 35V. El pin Vlog (Vl\u00f3gico) tiene dos modos de funcionamiento dependiendo de que el jumper Regulador est\u00e9 o no colocado. Las condiciones de funcionamiento son: Jumper colocado: El regulador LM7805 est\u00e1 activado y en Vlog habr\u00e1 una tensi\u00f3n de 5V siempre que el m\u00f3dulo est\u00e9 alimentado con una tensi\u00f3n m\u00e1xima de hasta 12V. Si lo alimentamos con mas tensi\u00f3n tendremos que quitar el jumper y alimentar con 5V la l\u00f3gica del m\u00f3dulo a trav\u00e9s de este pin. Jumper sin colocar: El regulador LM7805 est\u00e1 desactivado y tenemos que alimentar la l\u00f3gica del m\u00f3dulo a trav\u00e9s de Vlog. Debemos tener \u00a1Cuidado! si introducimos corriente por Vog con el jumper de regulaci\u00f3n colocado podemos provocar da\u00f1os en el m\u00f3dulo. El resto de conexiones se utilizan para el control de motores y para el caso de motores DC su utilizaci\u00f3n es la siguiente: Salidas para motores: Entregan la energ\u00eda para mover los motores y debemos conectarlo de forma que cuando marquemos, por ejemplo, mover adelante ambos motores giren en el mismo sentido. Si no lo hacen basta con invertir la polaridad de la conexi\u00f3n. Pines IN1 a IN4: IN1 e IN2 permiten controlar el sentido de giro del motor A mientras que IN3 e IN4 lo hacen con el del motor B. En la tabla siguiente se resume el funcionamiento de estos pines. IN1 IN2 IN3 IN4 Sentido de Giro High Low High Low Directo Low High Low High Inverso Low Low Low Low Paro Velocidad de giro: Tenemos que quitar los jumpers y usar los pines ENA y ENB. Estos pines debemos conectarlos a dos salidas PWM de la placa Arduino para poder enviarle un valor entre 0 y 255 que controle la velocidad de giro. Con los jumpers colocados, los motores girar\u00e1n siempre a la misma velocidad. Motores DC 3 a 6V \u00b6 Motor de continua de 3V a 6V con doble eje y caja reductora. El doble eje facilita la colocaci\u00f3n de un encoder \u00f3ptico para realizar un control de velocidad en lazo cerrado. En la tabla siguiente se resumen los principales par\u00e1metros de estos motores con una reductora 48:1 para distintas tensiones de alimentaci\u00f3n. 3V 5V 6V Velocidad sin carga 125 rpm 200 rpm 230 rpm velocidad con carga 95 rpm 160 rpm 175 rpm Torque 7.8 Ncm 9.8 Ncm 10.8 Ncm Consumo 100 a 130 mA 120 a 140 mA 130 a 150 mA El aspecto f\u00edsico de estos motores lo vemos en la imagen siguiente. Motores DC 3 a 6V Zumbador \u00b6 Si queremos reproducir sonidos de forma sencilla y econ\u00f3mica debemos sutilizar un zumbador o buzzer pasivo como el que vemos en la imagen siguiente. Zumbador pasivo El dispositivo suele venir con una pegatina que debemos retirar para que el sonido salga con toda su potencia del mismo. Esta pegatina tiene utilidad en procesos de fabricaci\u00f3n automatizada para proteger al buzzer en la fase de lavado. Normalmente no tienen polaridad, pero si est\u00e1 marcada en la carcasa o es distinguible por la diferente longitud de los pines lo mejor es respetarla, siendo normalmente el pin marcado el positivo o patilla mas larga. El buzzer pasivo, a diferencia del activo, no tiene un oscilador interno y esto obliga a generar la frecuencia desde Arduino, para ello disponemos de la funci\u00f3n tone() que implementa el IDE. Sensores de infrarrojos \u00b6 Hemos optado por poner al robot una pareja de sensores de reflexi\u00f3n fotoel\u00e9ctrica con distancia de detecci\u00f3n ajustable entre 2 y 30cm, conocido como sensor de infrarrojos FC-51, como el que vemos en la imagen siguiente, donde se indica el potenciometro de ajuste de distancia, el diodo emisor de IR y el fototransistor o detector de reflexi\u00f3n. Modelo de sensor IR escogido Recordemos el funcionamiento b\u00e1sico del sistema. El LED infrarrojo emite luz infrarroja, o sea, de menor frecuencia (o mayor longitud de onda) que la nuestros ojos nos permiten ver, es decir, para nosotros es invisible. El sensor que hemos elegido funciona cuando esta luz choca contra una superficie negra que la reflejar\u00e1 reflejar\u00e1 y llegar\u00e1 al fototransistor. Existen muchas clases de sensores de este tipo y hemos escogido este por su amplio rango de ajuste y su posibilidad de montaje vertical. Utilizando un par de estos sensores podemos seguir una linea detectando si se sale a derecha o izquierda de la l\u00ednea y redireccionarlo de nuevo a la linea. Este sensor tiene 3 pines de conexi\u00f3n, Vcc o 5V y GND para la alimentaci\u00f3n y D0 u OUT como salida de se\u00f1al que indicar\u00e1 si est\u00e1 llegando o no el reflejo del LED al fototransistor. En el esquema de la imagen siguiente se puede estudiar el funcionamiento electr\u00f3nico de esta plaquita. Esquema sensor infrarrojos El LM393 est\u00e1 configurado como comparador entre el nivel de tensi\u00f3n ajustado mediante VR1 que es entregado al terminal inversor y el nivel de entrada en el terminal no inversor, que va a depender de si el fototransistor recibe o no reflexi\u00f3n del infrarrojo emitido por el LED, si est\u00e1 recibiendo reflexi\u00f3n el fototransistor se encender\u00e1 el LED indicador de estado y tenemos el estado bajo o LOW en D0. Si no se recibe reflexi\u00f3n el LED no se iluminar\u00e1 y se env\u00eda un estado alto o HIGH a D0. Mediante el potenci\u00f3metro ajustamos la sensibilidad del fotorreceptor. Sensor de distancia HC-SR04 \u00b6 El sensor genera y emite una serie de tonos de ultrasonidos a una frecuencia de 40 kHz (no perceptibles al o\u00eddo humano) que si rebotan en una superficie vuelven y son captados por un micr\u00f3fono receptor de ultrasonidos que incorpora el propio sensor. Midiendo el tiempo que tardan en volver los tonos enviados podemos calcular la distancia a la que se encuentra el objeto sobre el que han rebotado. El propio circuito realiza los c\u00e1lculos necesarios para determinar la distancia que mas adelante veremos como se calcula. El sistema es similar al que usan algunos animales como ballenas, murci\u00e9lagos y delfines, para localizar obst\u00e1culos y presas. El HC-SR04 es un sensor de distancia de baja precisi\u00f3n, en teor\u00eda con una rango de medici\u00f3n de 2cm a 400 cm, con una resoluci\u00f3n de 0.3cm, pero en la pr\u00e1ctica se limita a un rango entre 20cm y 2 metros. El aspecto del HC-SR04 es muy caracter\u00edstico y se reconoce con facilidad porque tiene dos \"ojos\" que realmente son los dispositivos de emisi\u00f3n y recepci\u00f3n de ultrasonidos que integra este m\u00f3dulo, y es justo por esto por lo que hemos dotado al robot de una cabeza giratoria que en el funcionamiento parecer\u00e1 que el robot mira a un lado y otro. En la imagen siguiente vemos el aspecto real del sensor y el principio de funcionamiento de forma gr\u00e1fica. Aspecto del HC-SR04 y principio de funcionamiento Las caracter\u00edsticas t\u00e9cnicas m\u00e1s relevantes del HC-SR04 son: Dispone de 4 pines, dos son para alimentaci\u00f3n (Vcc) y masa (GND), disparador (Trigger) y receptor (Echo). En la imagen siguiente se aprecian claramente como est\u00e1n distribuidos estos pines en el sensor. Pinout del HC-SR04 Imagen basada en la publicada en theengineeringprojects Alimentaci\u00f3n: 5v Frecuencia de ultrasonidos: 40 Khz Consumos: en stand-by menor de 2mA y trabajando en torno a 15mA \u00c1ngulo: menor de 15\u00ba Veamos ahora en que se basan los c\u00e1lculos que realiza el sensor. En principio lo que hace, como ya se ha indicado, es contar el tiempo desde que se envia el pulso hasta que se recibe respuesta con lo que se puede determinar la distancia. Recordemos que: velocidad=\\dfrac{espacio}{tiempo}\\Rightarrow espacio=velocidad\\cdot tiempo velocidad=\\dfrac{espacio}{tiempo}\\Rightarrow espacio=velocidad\\cdot tiempo La velocidad es la del sonido es de 343 m/s a 20 \u00baC y un 50% de humedad relativa. A nosotros nos va a interesar expresar esta velocidad en cm/us, para lo que hacemos lo siguiente: 343\\dfrac{m}{s}\\cdot 100\\dfrac{cm}{m}\\cdot \\dfrac{1}{1000000}\\dfrac{s}{\\mu s}=0.0343\\dfrac{cm}{\\mu s}\\Rightarrow espacio-ida=0.0343\\cdot tiempo 343\\dfrac{m}{s}\\cdot 100\\dfrac{cm}{m}\\cdot \\dfrac{1}{1000000}\\dfrac{s}{\\mu s}=0.0343\\dfrac{cm}{\\mu s}\\Rightarrow espacio-ida=0.0343\\cdot tiempo Es decir, el sonido tarda 0.0343 microsegundos en recorrer un cent\u00edmetro, que ser\u00e1 el tiempo que tarda el sonido en ir desde el amisor al objeto en el que rebota. Teniendo en cuenta que desde que se emite el pulso, rebota y es recibido el espacio recorrido ser\u00e1 aproximadamente el doble que el calculado podemos expresar la distancia o espacio recorrido como: espacio=\\dfrac{espacio-ida}{2}=0.01715\\cdot tiempo espacio=\\dfrac{espacio-ida}{2}=0.01715\\cdot tiempo Ecuaci\u00f3n que nos permite saber la distancia a la que se encuentra un determinado objeto. Servomotores \u00b6 Los servomotores, abreviado servos, son motores de corriente continua que adem\u00e1s tienen una reductora con el fin de disminuir su velocidad de giro y aumentar el par motor en el eje. Tambi\u00e9n incorporan sistema electr\u00f3nico de control que permite hacerlos girar un determinado \u00e1ngulo. Esa electr\u00f3nica permite al servo saber en todo momento cual es su posici\u00f3n. Generalmente giran menos de una vuelta completa, 180\u00ba es bastante com\u00fan, aunque tienen un \u00e1ngulo variable seg\u00fan el modelo, pero existen ya servos de rotaci\u00f3n continua que giran 360 grados. Existen infinidad de modelos de servomotor y en nuestro caso vamos a utilizar Micro Servos del tipo 9g SG90. En la imagen siguiente vemos el aspecto y los elementos que incorporan este tipo de servos. Aspecto y elementos de los servos 9g SG90 Los servos tienen un funcionamiento muy parecido y la programaci\u00f3n suele variar muy poco de unos a otros, aunque siempre es conveniente mirar el datasheet del que vamos a utilizar para mayor seguridad. Debido a que la resoluci\u00f3n de la se\u00f1al PWM que podemos conseguir con una placa tipo UNO el \u00e1ngulo de giro que podremos mover un servo ser\u00e1 mayor de un grado, aunque el servo puede moverse con una resoluci\u00f3n mayor. Las caracter\u00edsticas de la se\u00f1al PWM nos indican que debemos generar un pulso de trabajo entre 1 ms y 2 ms y con un periodo de 20 ms (50 Hz), es decir, solamente podremos cambiar de posici\u00f3n del servo cada 20 ms. Los microservos se pueden alimentar directamente de la placa UNO dado que su consumo es lo suficientemente bajo para ello, pero si es necesario, dependiendo del modelo de servo, habr\u00e1 que alimentarlo con una fuente externa teniendo siempre la precauci\u00f3n de que las GNDs de la placa UNO y del servo queden interconectadas. Los colores usuales de los tres cables que salen del servo son los siguientes: Negro o Marr\u00f3n: GND Rojo: Alimentaci\u00f3n Blanco o Naranja: Se\u00f1al de control del servo (pulso enviado al servomotor) En la imagen siguiente se corrobora esta informaci\u00f3n. Colores de los cables en los servos 9g SG90 Encoder infrarrojos FC-03 \u00b6 Se trata de elementos basados en fotointerruptores de ranura como los que vemos en la imagen izquierda siguiente. A partir de estos se fabrican placas preparadas para conectar a Arduino como las que se ven en la imagen de la derecha siguiente. Izquierda: fotointerruptor de ranura - Derecha: sensor FC-03 Los dispositivos basados en optointerruptores son ampliamente utilizados como encoders para detectar la velocidad de giro y la posici\u00f3n del eje de motores. Para realizar esta tarea se emplean discos opacos ranurados que se acoplan al eje del motor, aunque tambi\u00e9n se pueden emplear elementos translucidos sobre los que se dibujan franjas negras. En la imagen siguiente vemos algunos de estos discos. Diferentes tipos de discos para encoder \u00f3ptico Con el sensor FC-03, que incluye comparador LM393 , podemos calcular la velocidad de rotaci\u00f3n de las ruedas de un robot. El funcionamiento b\u00e1sico del sensor es el siguiente; Si hacemos pasar una rueda dentada entre la ranura del sensor, este crea un pulso digital TTL en el pin D0, que podemos leer sin ning\u00fan problema en nuestra placa UNO. En la imagen siguiente vemos detalladas las diferentes partes del encoder. Pinout y partes del sensor FC-03 Los pines de conexi\u00f3n del encoder FC-03 de la imagen anterior los podemos describir de la siguiente forma: Vcc: Tensi\u00f3n de alimentaci\u00f3n del m\u00f3dulo de 3,3V a 12V. Se recomienda 3,3V GND: Masa o referencia 0V D0: Salida de se\u00f1al digital de pulsos TTL A0: Salida de se\u00f1al anal\u00f3gica de los pulsos de salida. Se trata de la se\u00f1al de salida en tiempo real que usualmente no se utiliza Como principales caracter\u00edsticas t\u00e9cnicas definimos las siguientes: Anchura de la ranura: 5mm LED indicador de alimentaci\u00f3n LED indicador de los pulsos de salida del pin D0. Este tipo de encoder suele dar problemas a la hora de leer los pulsos digitales generados por el comparador LM393, y estos consisten en que la placa UNO lee m\u00e1s pulsos de los que se generan realmente, en la pr\u00e1ctica del orden de cuatro veces m\u00e1s. En la imagen siguiente vemos el esquema del circuito que monta este encoder FC-03. Esquema interno del sensor FC-03 Podemos observar en este esquema como el comparador LM393 est\u00e1 configurado como de lazo abierto (no existe realimentaci\u00f3n) lo que hace que el mismo sea extremadamente sensible a los cambios que se producen en la entrada, bien sean provocados por el sensor de ranura (los deseados) o bien por ruidos generados por la propia alimentaci\u00f3n del sensor, los motores u otros elementos (pulsos no deseados) que puedan afectar a la se\u00f1al de salida. Es decir, que la se\u00f1al TTL presentar\u00e1 tanto en los flancos de subida como de bajada una serie de pulsos o rebotes que la placa UNO es capaz de leer e interpretar. La soluci\u00f3n al problema de los pulsos no deseados puede implementarse por hardware o por software. Por hardware: Una primera soluci\u00f3n puede ser alimentar el FC-03 con 3,3V, pero no siempre es sencillo ni darnos una buena se\u00f1al. La otra opci\u00f3n, mucho m\u00e1s eficaz y definitiva, es soldar un condensador de entre 10 y 100 nF entre los pines D0 y GND que filtrar\u00e1 dichos pulsos no deseados. Por software: Lo normal cuando usamos este tipo de sensores es que empleemos las interrupciones de Arduino, de ah\u00ed que los pines reservados para estos sensores sean los digitales 2 y 3, que es donde se implementan las interrupciones en la placa UNO. El punto en contra de esto es que tendremos que implementar un sistema antirrebotes (debounce) para estas dos entradas. En lo que respecta a hacer funcionar al robot no debemos preocuparnos por el tema ya que la librer\u00eda incorpora la implementaci\u00f3n del debounce por software. Si queremos entender algo mejor el tema del debounce podemos recurrir a multitud de tutoriales existente en la red siendo el que recomendamos el que aparece en el blog de Luis Llamas .","title":"An\u00e1lisis de elementos"},{"location":"conexionado-pruebas/UNO/elementos/#descripcion-de-placas-y-sensores","text":"En este apartado vamos a realizar una descripci\u00f3n b\u00e1sica de las distintas placas, sensores y elementos que se utilizan en la construcci\u00f3n del robot.","title":"Descripci\u00f3n de placas y sensores"},{"location":"conexionado-pruebas/UNO/elementos/#placa-keyestudio-uno-ks0172","text":"Se trata de la placa Ks0172 basada en Arduino UNO con el microcontrolador ATmega328P que incorpora conectores de 3 pines que incluyen la patilla asociada y la alimentaci\u00f3n y que facilita el conexionado de elementos sin necesidad de utilizar protoboard. En la imagen siguiente podemos ver esta placa con sus descripciones b\u00e1sicas y este es el enlace al archivo fuente . Placa Keyestudio UNO Ks0172 IMPORTANTE: El interruptor deslizante permite escoger entre las alimentaciones de 5V o 3.3V. En nuestro caso nos aseguraremos de que est\u00e1 en la posici\u00f3n 5V . Tambi\u00e9n es importante tener disponible un gr\u00e1fico con la funcionalidad de cada pin o diagrama pinout como el que vemos en la imagen siguiente y este es el enlace a su archivo fuente Pinout de la Placa Keyestudio UNO Ks0172","title":"Placa Keyestudio UNO Ks0172"},{"location":"conexionado-pruebas/UNO/elementos/#placa-drivers-l298","text":"Esta placa est\u00e1 basada en el chip L298N y permite controlar la velocidad y el sentido de giro de dos motores de corriente continua o un motor paso a paso bipolar con un consumo m\u00e1ximo de dos amperios. Cuenta con diodos de protecci\u00f3n y un regulador LM7805 que suministra 5V a la parte l\u00f3gica del integrado L298N. Se disponen jumpers de selecci\u00f3n para habilitar cada una de las salidas del m\u00f3dulo (A y B). La salida A esta conformada por OUT1 y OUT2 y la salida B por OUT3 y OUT4. Los pines de habilitaci\u00f3n son ENA y ENB (Enable A y Enable B) respectivamente. En la siguiente imagen vemos esta placa con sus descripciones b\u00e1sicas y este es el enlace al archivo fuente . Placa L298 Este m\u00f3dulo con el L298N nos permite alimentar nuestro Arduino a partir de la salida de 5V con un l\u00edmite de 500 mA. Debemos tambi\u00e9n tener presente que el m\u00f3dulo entrega una tensi\u00f3n a los motores en torno a 3V menor que la tensi\u00f3n a la que lo alimentamos. Los pines Vin y GND son los de alimentaci\u00f3n del m\u00f3dulo con una tensi\u00f3n que puede ir de 3V a 35V. El pin Vlog (Vl\u00f3gico) tiene dos modos de funcionamiento dependiendo de que el jumper Regulador est\u00e9 o no colocado. Las condiciones de funcionamiento son: Jumper colocado: El regulador LM7805 est\u00e1 activado y en Vlog habr\u00e1 una tensi\u00f3n de 5V siempre que el m\u00f3dulo est\u00e9 alimentado con una tensi\u00f3n m\u00e1xima de hasta 12V. Si lo alimentamos con mas tensi\u00f3n tendremos que quitar el jumper y alimentar con 5V la l\u00f3gica del m\u00f3dulo a trav\u00e9s de este pin. Jumper sin colocar: El regulador LM7805 est\u00e1 desactivado y tenemos que alimentar la l\u00f3gica del m\u00f3dulo a trav\u00e9s de Vlog. Debemos tener \u00a1Cuidado! si introducimos corriente por Vog con el jumper de regulaci\u00f3n colocado podemos provocar da\u00f1os en el m\u00f3dulo. El resto de conexiones se utilizan para el control de motores y para el caso de motores DC su utilizaci\u00f3n es la siguiente: Salidas para motores: Entregan la energ\u00eda para mover los motores y debemos conectarlo de forma que cuando marquemos, por ejemplo, mover adelante ambos motores giren en el mismo sentido. Si no lo hacen basta con invertir la polaridad de la conexi\u00f3n. Pines IN1 a IN4: IN1 e IN2 permiten controlar el sentido de giro del motor A mientras que IN3 e IN4 lo hacen con el del motor B. En la tabla siguiente se resume el funcionamiento de estos pines. IN1 IN2 IN3 IN4 Sentido de Giro High Low High Low Directo Low High Low High Inverso Low Low Low Low Paro Velocidad de giro: Tenemos que quitar los jumpers y usar los pines ENA y ENB. Estos pines debemos conectarlos a dos salidas PWM de la placa Arduino para poder enviarle un valor entre 0 y 255 que controle la velocidad de giro. Con los jumpers colocados, los motores girar\u00e1n siempre a la misma velocidad.","title":"Placa Drivers L298"},{"location":"conexionado-pruebas/UNO/elementos/#motores-dc-3-a-6v","text":"Motor de continua de 3V a 6V con doble eje y caja reductora. El doble eje facilita la colocaci\u00f3n de un encoder \u00f3ptico para realizar un control de velocidad en lazo cerrado. En la tabla siguiente se resumen los principales par\u00e1metros de estos motores con una reductora 48:1 para distintas tensiones de alimentaci\u00f3n. 3V 5V 6V Velocidad sin carga 125 rpm 200 rpm 230 rpm velocidad con carga 95 rpm 160 rpm 175 rpm Torque 7.8 Ncm 9.8 Ncm 10.8 Ncm Consumo 100 a 130 mA 120 a 140 mA 130 a 150 mA El aspecto f\u00edsico de estos motores lo vemos en la imagen siguiente. Motores DC 3 a 6V","title":"Motores DC 3 a 6V"},{"location":"conexionado-pruebas/UNO/elementos/#zumbador","text":"Si queremos reproducir sonidos de forma sencilla y econ\u00f3mica debemos sutilizar un zumbador o buzzer pasivo como el que vemos en la imagen siguiente. Zumbador pasivo El dispositivo suele venir con una pegatina que debemos retirar para que el sonido salga con toda su potencia del mismo. Esta pegatina tiene utilidad en procesos de fabricaci\u00f3n automatizada para proteger al buzzer en la fase de lavado. Normalmente no tienen polaridad, pero si est\u00e1 marcada en la carcasa o es distinguible por la diferente longitud de los pines lo mejor es respetarla, siendo normalmente el pin marcado el positivo o patilla mas larga. El buzzer pasivo, a diferencia del activo, no tiene un oscilador interno y esto obliga a generar la frecuencia desde Arduino, para ello disponemos de la funci\u00f3n tone() que implementa el IDE.","title":"Zumbador"},{"location":"conexionado-pruebas/UNO/elementos/#sensores-de-infrarrojos","text":"Hemos optado por poner al robot una pareja de sensores de reflexi\u00f3n fotoel\u00e9ctrica con distancia de detecci\u00f3n ajustable entre 2 y 30cm, conocido como sensor de infrarrojos FC-51, como el que vemos en la imagen siguiente, donde se indica el potenciometro de ajuste de distancia, el diodo emisor de IR y el fototransistor o detector de reflexi\u00f3n. Modelo de sensor IR escogido Recordemos el funcionamiento b\u00e1sico del sistema. El LED infrarrojo emite luz infrarroja, o sea, de menor frecuencia (o mayor longitud de onda) que la nuestros ojos nos permiten ver, es decir, para nosotros es invisible. El sensor que hemos elegido funciona cuando esta luz choca contra una superficie negra que la reflejar\u00e1 reflejar\u00e1 y llegar\u00e1 al fototransistor. Existen muchas clases de sensores de este tipo y hemos escogido este por su amplio rango de ajuste y su posibilidad de montaje vertical. Utilizando un par de estos sensores podemos seguir una linea detectando si se sale a derecha o izquierda de la l\u00ednea y redireccionarlo de nuevo a la linea. Este sensor tiene 3 pines de conexi\u00f3n, Vcc o 5V y GND para la alimentaci\u00f3n y D0 u OUT como salida de se\u00f1al que indicar\u00e1 si est\u00e1 llegando o no el reflejo del LED al fototransistor. En el esquema de la imagen siguiente se puede estudiar el funcionamiento electr\u00f3nico de esta plaquita. Esquema sensor infrarrojos El LM393 est\u00e1 configurado como comparador entre el nivel de tensi\u00f3n ajustado mediante VR1 que es entregado al terminal inversor y el nivel de entrada en el terminal no inversor, que va a depender de si el fototransistor recibe o no reflexi\u00f3n del infrarrojo emitido por el LED, si est\u00e1 recibiendo reflexi\u00f3n el fototransistor se encender\u00e1 el LED indicador de estado y tenemos el estado bajo o LOW en D0. Si no se recibe reflexi\u00f3n el LED no se iluminar\u00e1 y se env\u00eda un estado alto o HIGH a D0. Mediante el potenci\u00f3metro ajustamos la sensibilidad del fotorreceptor.","title":"Sensores de infrarrojos"},{"location":"conexionado-pruebas/UNO/elementos/#sensor-de-distancia-hc-sr04","text":"El sensor genera y emite una serie de tonos de ultrasonidos a una frecuencia de 40 kHz (no perceptibles al o\u00eddo humano) que si rebotan en una superficie vuelven y son captados por un micr\u00f3fono receptor de ultrasonidos que incorpora el propio sensor. Midiendo el tiempo que tardan en volver los tonos enviados podemos calcular la distancia a la que se encuentra el objeto sobre el que han rebotado. El propio circuito realiza los c\u00e1lculos necesarios para determinar la distancia que mas adelante veremos como se calcula. El sistema es similar al que usan algunos animales como ballenas, murci\u00e9lagos y delfines, para localizar obst\u00e1culos y presas. El HC-SR04 es un sensor de distancia de baja precisi\u00f3n, en teor\u00eda con una rango de medici\u00f3n de 2cm a 400 cm, con una resoluci\u00f3n de 0.3cm, pero en la pr\u00e1ctica se limita a un rango entre 20cm y 2 metros. El aspecto del HC-SR04 es muy caracter\u00edstico y se reconoce con facilidad porque tiene dos \"ojos\" que realmente son los dispositivos de emisi\u00f3n y recepci\u00f3n de ultrasonidos que integra este m\u00f3dulo, y es justo por esto por lo que hemos dotado al robot de una cabeza giratoria que en el funcionamiento parecer\u00e1 que el robot mira a un lado y otro. En la imagen siguiente vemos el aspecto real del sensor y el principio de funcionamiento de forma gr\u00e1fica. Aspecto del HC-SR04 y principio de funcionamiento Las caracter\u00edsticas t\u00e9cnicas m\u00e1s relevantes del HC-SR04 son: Dispone de 4 pines, dos son para alimentaci\u00f3n (Vcc) y masa (GND), disparador (Trigger) y receptor (Echo). En la imagen siguiente se aprecian claramente como est\u00e1n distribuidos estos pines en el sensor. Pinout del HC-SR04 Imagen basada en la publicada en theengineeringprojects Alimentaci\u00f3n: 5v Frecuencia de ultrasonidos: 40 Khz Consumos: en stand-by menor de 2mA y trabajando en torno a 15mA \u00c1ngulo: menor de 15\u00ba Veamos ahora en que se basan los c\u00e1lculos que realiza el sensor. En principio lo que hace, como ya se ha indicado, es contar el tiempo desde que se envia el pulso hasta que se recibe respuesta con lo que se puede determinar la distancia. Recordemos que: velocidad=\\dfrac{espacio}{tiempo}\\Rightarrow espacio=velocidad\\cdot tiempo velocidad=\\dfrac{espacio}{tiempo}\\Rightarrow espacio=velocidad\\cdot tiempo La velocidad es la del sonido es de 343 m/s a 20 \u00baC y un 50% de humedad relativa. A nosotros nos va a interesar expresar esta velocidad en cm/us, para lo que hacemos lo siguiente: 343\\dfrac{m}{s}\\cdot 100\\dfrac{cm}{m}\\cdot \\dfrac{1}{1000000}\\dfrac{s}{\\mu s}=0.0343\\dfrac{cm}{\\mu s}\\Rightarrow espacio-ida=0.0343\\cdot tiempo 343\\dfrac{m}{s}\\cdot 100\\dfrac{cm}{m}\\cdot \\dfrac{1}{1000000}\\dfrac{s}{\\mu s}=0.0343\\dfrac{cm}{\\mu s}\\Rightarrow espacio-ida=0.0343\\cdot tiempo Es decir, el sonido tarda 0.0343 microsegundos en recorrer un cent\u00edmetro, que ser\u00e1 el tiempo que tarda el sonido en ir desde el amisor al objeto en el que rebota. Teniendo en cuenta que desde que se emite el pulso, rebota y es recibido el espacio recorrido ser\u00e1 aproximadamente el doble que el calculado podemos expresar la distancia o espacio recorrido como: espacio=\\dfrac{espacio-ida}{2}=0.01715\\cdot tiempo espacio=\\dfrac{espacio-ida}{2}=0.01715\\cdot tiempo Ecuaci\u00f3n que nos permite saber la distancia a la que se encuentra un determinado objeto.","title":"Sensor de distancia HC-SR04"},{"location":"conexionado-pruebas/UNO/elementos/#servomotores","text":"Los servomotores, abreviado servos, son motores de corriente continua que adem\u00e1s tienen una reductora con el fin de disminuir su velocidad de giro y aumentar el par motor en el eje. Tambi\u00e9n incorporan sistema electr\u00f3nico de control que permite hacerlos girar un determinado \u00e1ngulo. Esa electr\u00f3nica permite al servo saber en todo momento cual es su posici\u00f3n. Generalmente giran menos de una vuelta completa, 180\u00ba es bastante com\u00fan, aunque tienen un \u00e1ngulo variable seg\u00fan el modelo, pero existen ya servos de rotaci\u00f3n continua que giran 360 grados. Existen infinidad de modelos de servomotor y en nuestro caso vamos a utilizar Micro Servos del tipo 9g SG90. En la imagen siguiente vemos el aspecto y los elementos que incorporan este tipo de servos. Aspecto y elementos de los servos 9g SG90 Los servos tienen un funcionamiento muy parecido y la programaci\u00f3n suele variar muy poco de unos a otros, aunque siempre es conveniente mirar el datasheet del que vamos a utilizar para mayor seguridad. Debido a que la resoluci\u00f3n de la se\u00f1al PWM que podemos conseguir con una placa tipo UNO el \u00e1ngulo de giro que podremos mover un servo ser\u00e1 mayor de un grado, aunque el servo puede moverse con una resoluci\u00f3n mayor. Las caracter\u00edsticas de la se\u00f1al PWM nos indican que debemos generar un pulso de trabajo entre 1 ms y 2 ms y con un periodo de 20 ms (50 Hz), es decir, solamente podremos cambiar de posici\u00f3n del servo cada 20 ms. Los microservos se pueden alimentar directamente de la placa UNO dado que su consumo es lo suficientemente bajo para ello, pero si es necesario, dependiendo del modelo de servo, habr\u00e1 que alimentarlo con una fuente externa teniendo siempre la precauci\u00f3n de que las GNDs de la placa UNO y del servo queden interconectadas. Los colores usuales de los tres cables que salen del servo son los siguientes: Negro o Marr\u00f3n: GND Rojo: Alimentaci\u00f3n Blanco o Naranja: Se\u00f1al de control del servo (pulso enviado al servomotor) En la imagen siguiente se corrobora esta informaci\u00f3n. Colores de los cables en los servos 9g SG90","title":"Servomotores"},{"location":"conexionado-pruebas/UNO/elementos/#encoder-infrarrojos-fc-03","text":"Se trata de elementos basados en fotointerruptores de ranura como los que vemos en la imagen izquierda siguiente. A partir de estos se fabrican placas preparadas para conectar a Arduino como las que se ven en la imagen de la derecha siguiente. Izquierda: fotointerruptor de ranura - Derecha: sensor FC-03 Los dispositivos basados en optointerruptores son ampliamente utilizados como encoders para detectar la velocidad de giro y la posici\u00f3n del eje de motores. Para realizar esta tarea se emplean discos opacos ranurados que se acoplan al eje del motor, aunque tambi\u00e9n se pueden emplear elementos translucidos sobre los que se dibujan franjas negras. En la imagen siguiente vemos algunos de estos discos. Diferentes tipos de discos para encoder \u00f3ptico Con el sensor FC-03, que incluye comparador LM393 , podemos calcular la velocidad de rotaci\u00f3n de las ruedas de un robot. El funcionamiento b\u00e1sico del sensor es el siguiente; Si hacemos pasar una rueda dentada entre la ranura del sensor, este crea un pulso digital TTL en el pin D0, que podemos leer sin ning\u00fan problema en nuestra placa UNO. En la imagen siguiente vemos detalladas las diferentes partes del encoder. Pinout y partes del sensor FC-03 Los pines de conexi\u00f3n del encoder FC-03 de la imagen anterior los podemos describir de la siguiente forma: Vcc: Tensi\u00f3n de alimentaci\u00f3n del m\u00f3dulo de 3,3V a 12V. Se recomienda 3,3V GND: Masa o referencia 0V D0: Salida de se\u00f1al digital de pulsos TTL A0: Salida de se\u00f1al anal\u00f3gica de los pulsos de salida. Se trata de la se\u00f1al de salida en tiempo real que usualmente no se utiliza Como principales caracter\u00edsticas t\u00e9cnicas definimos las siguientes: Anchura de la ranura: 5mm LED indicador de alimentaci\u00f3n LED indicador de los pulsos de salida del pin D0. Este tipo de encoder suele dar problemas a la hora de leer los pulsos digitales generados por el comparador LM393, y estos consisten en que la placa UNO lee m\u00e1s pulsos de los que se generan realmente, en la pr\u00e1ctica del orden de cuatro veces m\u00e1s. En la imagen siguiente vemos el esquema del circuito que monta este encoder FC-03. Esquema interno del sensor FC-03 Podemos observar en este esquema como el comparador LM393 est\u00e1 configurado como de lazo abierto (no existe realimentaci\u00f3n) lo que hace que el mismo sea extremadamente sensible a los cambios que se producen en la entrada, bien sean provocados por el sensor de ranura (los deseados) o bien por ruidos generados por la propia alimentaci\u00f3n del sensor, los motores u otros elementos (pulsos no deseados) que puedan afectar a la se\u00f1al de salida. Es decir, que la se\u00f1al TTL presentar\u00e1 tanto en los flancos de subida como de bajada una serie de pulsos o rebotes que la placa UNO es capaz de leer e interpretar. La soluci\u00f3n al problema de los pulsos no deseados puede implementarse por hardware o por software. Por hardware: Una primera soluci\u00f3n puede ser alimentar el FC-03 con 3,3V, pero no siempre es sencillo ni darnos una buena se\u00f1al. La otra opci\u00f3n, mucho m\u00e1s eficaz y definitiva, es soldar un condensador de entre 10 y 100 nF entre los pines D0 y GND que filtrar\u00e1 dichos pulsos no deseados. Por software: Lo normal cuando usamos este tipo de sensores es que empleemos las interrupciones de Arduino, de ah\u00ed que los pines reservados para estos sensores sean los digitales 2 y 3, que es donde se implementan las interrupciones en la placa UNO. El punto en contra de esto es que tendremos que implementar un sistema antirrebotes (debounce) para estas dos entradas. En lo que respecta a hacer funcionar al robot no debemos preocuparnos por el tema ya que la librer\u00eda incorpora la implementaci\u00f3n del debounce por software. Si queremos entender algo mejor el tema del debounce podemos recurrir a multitud de tutoriales existente en la red siendo el que recomendamos el que aparece en el blog de Luis Llamas .","title":"Encoder infrarrojos FC-03"},{"location":"conexionado-pruebas/UNO/test/","text":"Pruebas b\u00e1sicas de funcionamiento \u00b6 Una vez analizados y conectados los distintos elementos iremos haciendo peque\u00f1os programas bien mediante la aplicaci\u00f3n Masaylo Blockly basada en Blocklino de Fontaine Jean Philippe , y pensada para programar robots utilizando un entorno gr\u00e1fico o de programaci\u00f3n por bloques, o bien utilizando el IDE de Arduino. En el apartado de software se pueden encontrar los enlaces de descarga y toda la informaci\u00f3n de la aplicaci\u00f3n. Alimentaci\u00f3n \u00b6 Colocamos las pilas AA en su lugar respetando la polaridad de las mismas y accionamos el interruptor. Si todo es correcto en ambas placas se debe encender un diodo LED rojo indicativo de que est\u00e1n alimentadas, tal y como observamos en la imagen siguiente: Primer encendido En este punto vamos a probar tambi\u00e9n que se graba correctamente firmware en la placa UNO a partir de Masaylo Blockly 1.1.1 Beta o posterior . Para ello hemos creado y almacenado el programa blink.bloc que vemos en la imagen siguiente. Programa blink.bloc Si cargamos el programa y dejamos sin accionar el interruptor observaremos como parpadea el LED asociado al pin 13 en la placa UNO pero la placa del driver no est\u00e1 alimentada y por tanto su LED permanece apagado. En la animaci\u00f3n siguiente vemos el parpadeo del LED y el resultado de accionar el interruptor. Animaci\u00f3n que muestra el funcionamiento del programa blink.bloc y del interruptor Este GIF se ha creado a partir de un video en formato mp4 utilizando FFMPEG y GIMP y la informaci\u00f3n obtenida en este enlace . Motores \u00b6 Vamos a realizar una primera prueba del funcionamiento de los motores a partir de los ejemplos suministrados con la librer\u00eda y disponibles en la aplicaci\u00f3n Masaylo Blockly que estamos usando en estas pruebas de funcionamiento. En la imagen siguiente tenemos cargado el ejemplo Aprende a controlar los movimientos b\u00e1sicos del robot Masaylo y hemos destacado el icono desde el que podemos seleccionarlo de la lista que se abre en una ventana emergente y que al hacer clic nos lo carga en el entorno de la aplicaci\u00f3n. Ejemplo Aprende a controlar los movimientos b\u00e1sicos del robot Masaylo cargado Si conectamos la placa al puerto USB del ordenador y cargamos el ejemplo en la placa, cuando accionemos el interruptor (o con este accionado pulsemos el bot\u00f3n de reset) se producir\u00e1 la secuencia de movimiento establecida en el programa que podemos apreciar en la animaci\u00f3n siguiente. Animaci\u00f3n que muestra el funcionamiento del programa motores-ej1.bloc El ejemplo siguiente est\u00e1 basado en Utiliza PWM para controlar la velocidad de movimientos del Masaylo suministrado con la aplicaci\u00f3n pero ligeramente modificado ( motores-ej2.bloc ) para poner todos los valores de PWM al 50% y todos los retardos a 3 segundos. Ejemplo con control PWM de Masaylo El funcionamiento es muy similar al de la animaci\u00f3n anterior pero a la mitad de velocidad. An\u00edmate y prueba el ejemplo y haz cambios para analizar lo que est\u00e1 ocurriendo. Zumbador \u00b6 En esta ocasi\u00f3n vamos a programar el robot desde el IDE de Arduino, en concreto utilizando la versi\u00f3n 1.8.13 o posterior. Para la prueba del zumbador vamos a utilizar la informaci\u00f3n que podemos ver en la web de Input makers con el t\u00edtulo Programar melod\u00eda de Star Wars con Arduino y zumbador . El c\u00f3digo que vamos a grabar en la placa lo vemos a continuaci\u00f3n y basta con utilizar el bot\u00f3n copiar para seleccionarlo y ponerlo en el portapapeles desde el que lo podemos llevar al IDE de Arduino. Este bot\u00f3n se hace mas visible al pasar el cursor por el cuadro del c\u00f3digo en la zona superior derecha del mismo. Tambi\u00e9n puedes descargar el programa comprimido haciendo clic en el enlace buzzer-star-wars que puedes descomprimir y utilizar a conveniencia. int pin = 1; // definimos el pin al que conectaremos el zumbador. /* Definimos cada una de las frecuencias de las notas musicales. * Cuando van acompa\u00f1adas de la letra S significa que esa nota es sostenido. * Cuando van acompa\u00f1adas de la letra H significa que esa nota est\u00e1 en una octava superior (High). */ int c=261; int d=294; int e=329; int f=349; int g=391; int gS=415; int a=440; int aS=455; int b=466; int cH=523; int cSH=554; int dH=587; int dSH=622; int eH=659; int fH=698; int fSH=740; int gH=783; int gSH=830; int aH=880; void setup() { pinMode(pin, OUTPUT); // Hacemos que el pin 1 sea salida. } void loop() { /* Utilizamos la funci\u00f3n tone incluida en el IDE con el formato: tone(N\u00ba-pin, nota, duracion) */ tone(pin, a, 500); delay(550); tone(pin, a, 500); delay(550); tone(pin, a, 500); delay(550); tone(pin, f, 350); delay(350); tone(pin, cH, 150); delay(200); tone(pin, a, 500); delay(550); tone(pin, f, 350); delay(350); tone(pin, cH, 150); delay(200); tone(pin, a, 1000); delay(1050); tone(pin, eH, 500); delay(550); tone(pin, eH, 500); delay(550); tone(pin, eH, 500); delay(550); tone(pin, fH, 350); delay(350); tone(pin, cH, 150); delay(200); tone(pin, gS, 500); delay(550); tone(pin, f, 350); delay(350); tone(pin, cH, 150); delay(200); tone(pin, a, 1000); delay(1050); tone(pin, aH, 500); delay(550); tone(pin, a, 350); delay(350); tone(pin, a, 150); delay(200); tone(pin, aH, 500); delay(550); tone(pin, gSH, 250);delay(250); tone(pin, gH, 250); delay(250); tone(pin, fSH, 125);delay(150); tone(pin, fH, 125); delay(150); tone(pin, fSH, 250);delay(250); delay(250); tone(pin, aS, 250); delay(250); tone(pin, dSH, 500);delay(550); tone(pin, dH, 250); delay(250); tone(pin, cSH, 250);delay(250); tone(pin, cH, 125); delay(150); tone(pin, b, 125); delay(150); tone(pin, cH, 250); delay(250); delay(250); tone(pin, f, 125); delay(150); tone(pin, gS, 500); delay(550); tone(pin, f, 375); delay(375+50); tone(pin, a, 125); delay(150); tone(pin, cH, 500); delay(550); tone(pin, a, 375); delay(400); tone(pin, cH, 125); delay(150); tone(pin, eH, 1000);delay(1050); tone(pin, aH, 500); delay(550); tone(pin, a, 350); delay(350); tone(pin, a, 150); delay(200); tone(pin, aH, 500); delay(550); tone(pin, gSH, 250);delay(250); tone(pin, gH, 250); delay(250); tone(pin, fSH, 125);delay(150); tone(pin, fH, 125); delay(150); tone(pin, fSH, 250);delay(250); delay(250); tone(pin, aS, 250); delay(250); tone(pin, dSH, 500);delay(550); tone(pin, dH, 250); delay(250); tone(pin, cSH, 250);delay(250); tone(pin, cH, 125); delay(150); tone(pin, b, 125); delay(150); tone(pin, cH, 250); delay(250); delay(250); tone(pin, f, 250); delay(250); tone(pin, gS, 500); delay(550); tone(pin, f, 375); delay(400); tone(pin, cH, 125); delay(150); tone(pin, a, 500); delay(550); tone(pin, f, 375); delay(400); tone(pin, c, 125); delay(150); tone(pin, a, 1000); delay(1050); delay(5000); } En el video \"prueba del zumbador en Masaylo-CRG\" que tenemos a continuaci\u00f3n podemos escuchar el resultado de grabar el c\u00f3digo anterior en el robot. Sensores de infrarrojos \u00b6 Para probar y ajustar los sensores de infrarrojos vamos a realizar un sencillo programa en MasayloBlockly como el que vemos en la imagen siguiente. Ejemplo para prueba de los sensores de infrarrojos Si es necesario retocaremos la posici\u00f3n del cursor del potenciometro de ajuste de sensibilidad teniendo en cuenta que es extremadamente sensible y que debemos dejarlo en una posici\u00f3n tal que al situar el sensor sobre una superficie negra el sensor onboard se apague y cuando lo sacamos del negro se encienda. El programa sensores-IR.bloc es muy sencillo y simplemente comprueba si el sensor izquierdo est\u00e1 sobre negro est\u00e1ndo el derecho sobre blanco, si esta condici\u00f3n es cierta el LED onboard del UNO har\u00e1 un parpadeo que repetir\u00e1 dos veces de forma lenta y nos mostrar\u00e1 un mensaje en el monitor serie. Un proceso similar se realiza con el sensor derecho sobre negro siendo esta vez el parpadeo r\u00e1pido y lo har\u00e1 tres veces. Si ninguno de los sensores detecta negro mostrar\u00e1 el correspondiente mensaje permaneciendo el LED apagado. En la imagen siguiente vemos el resultado que muestra el monitor serie al hacer que los sensores lean negro. Resultados obtenidos con el programa de prueba de los sensores de infrarrojos Sensor de distancia HC-SR04 \u00b6 El datasheet del sensor nos indica que debemos generar un pulso de al menos 10us en el pin Trigger o disparador. Si queremos asegurar un trigger bueno podemos poner el pin a nivel bajo durante 4us antes de general el pulso en si. En c\u00f3digo esto es algo como lo siguiente: digitalWrite(Pin_Trigger, LOW); delayMicroseconds(4); digitalWrite(Pin_Trigger, HIGH); delayMicroseconds(10); digitalWrite(Pin_Trigger, LOW); Este c\u00f3digo ya est\u00e1 implementado en la librer\u00eda que se describe en estas notas y, por supuesto lo est\u00e1 en Masaylo Blockly por lo que no debemos preocuparnos por ello. En este caso como ejemplo vamos a utilizar el que viene con la versi\u00f3n 1.1.4 de Masaylo Blockly titulado \"Env\u00eda la distancia al obst\u00e1culo detectado al puerto serie de tu ordenador\" y que podemos ver cargado en la imagen siguiente. Ejemplo \"Env\u00eda la distancia al obst\u00e1culo detectado al puerto serie de tu ordenador\" En la imagen siguiente vemos este mismo ejemplo con la definici\u00f3n de pines que se da en el pinout. Ejemplo \"Env\u00eda la distancia al obst\u00e1culo detectado al puerto serie de tu ordenador\" con A2 y A3 Se puede utilizar una u otra nomenclatura de forma indiferente y en cualquier caso lo que hace el ejemplo es enviarnos al puerto serie la distancia en cent\u00edmetros que est\u00e1 midiendo el sensor una vez por segundo. En la imagen siguiente vemos una ventana con resultados de diferentes distancias medidas por el sensor. Ejemplo \"Env\u00eda la distancia al obst\u00e1culo detectado al puerto serie de tu ordenador\" resultados Servomotores \u00b6 En nuestro caso el robot va dotado de dos servos SG90, uno para accionar el brazo aparta obst\u00e1culos y el otro para accionar la cabeza y que el robot \"mire\" a un lado y otro. Para ambos servos vamos a crear unos programas muy simples que nos sirvan para verificar su funcionamiento. Prueba de funcionamiento del servo de cabeza . Implementamos, o descargamos el programa que vemos en la imagen siguiente: Ejemplo b\u00e1sico de funcionamiento del servo de cabeza En los ejemplos que acompa\u00f1an a la librer\u00eda y que se incluyen en Masaylo Blockly encontramos otras muchas funcionalidades de este servo. En la animaci\u00f3n siguiente vemos el resultado de programar el robot con el ejemplo anterior y como realiza movimientos de izquierda a derecha pasando por la posici\u00f3n central o mirar al frente. Animaci\u00f3n del ejemplo b\u00e1sico de funcionamiento del servo de cabeza Prueba de funcionamiento del servo del brazo . En el caso del brazo hay que tener en cuenta que, si posicionamos la placa UNO como hemos ido viendo en las distintas im\u00e1genes, al grabar este programa (o cualquier otro que trabaje con el servo del brazo) y mientras mantegamos conectado el cable USB, este va a molestar a los movimientos del brazo porque chocar\u00e1 con el mismo. Las opciones que tenemos para evitar que esto ocurra son: girar la placa UNO 180\u00ba sobre la posici\u00f3n indicada hasta ahora retirar el brazo en tanto trabajamos con la conexi\u00f3n USB y colocarlo en el robot para su funcionamiento aut\u00f3nomo colocar el servo junto con el brazo en el otro costado del robot En la imagen siguiente vemos el robot con el servo cambiado de costado. Servo del brazo posicionado a la izquierda Implementamos, o descargamos el programa que vemos en la imagen siguiente: Ejemplo b\u00e1sico de funcionamiento del servo del brazo En los ejemplos que acompa\u00f1an a la librer\u00eda y que se incluyen en Masaylo Blockly encontramos otras muchas funcionalidades de este servo. En la animaci\u00f3n siguiente vemos el resultado de programar el robot con un ejemplo en el que el brazo est\u00e1 colocado en el costado derecho y como realiza movimientos de posicionado del brazo envolviendo al objeto que supuestamente habr\u00eda delante y retracci\u00f3n del brazo a su posici\u00f3n de replegado pasando por la posici\u00f3n central o posici\u00f3n vertical del brazo. Animaci\u00f3n del ejemplo b\u00e1sico de funcionamiento del servo del brazo Encoder infrarrojos FC-03 \u00b6 Para probar el funcionamiento de los encoders vamos a recurrir de nuevo al IDE 1.8.15 de Arduino montando dos ejemplos totalmente similares pero probando cada encoder por separado. Estos ejemplos est\u00e1n inspirados en la implementaci\u00f3n que se hace de los mismos en el robot Andromina OFF ROAD y los detalles analizados en el blog Andromina robot V.2.0 Posteriormente podremos probar distintos ejemplos integrados en la librer\u00eda que l\u00f3gicamente utilizar\u00e1n ambos encoders simult\u00e1neamente. Encoder izquierdo A continuaci\u00f3n vemos el c\u00f3digo comentado de la prueba que vamos a realizar y que puedes descargar o copiar para grabarlo en tu robot y as\u00ed comprobar que el encoder izquierdo funciona correctamente. const int pwm_izdo = 6; //pines y variables motor y encoder izquierdo const int IN1 = 7; const int IN2 = 8; int encoder_izdo = 2; unsigned int rpm_izdo = 0; float vel_izdo = 0; //en Km/h volatile byte pulsos_leidos = 0; // N\u00famero de pulsos leidos en un segundo unsigned long tiempo_anterior = 0; // Tiempo unsigned int muescas = 20; //n\u00famero de muescas del disco del encoder. const int diametro_rueda = 75; //Di\u00e1metro de las ruedas en mm static volatile unsigned long debounce = 0; //Tiempo del rebote. void setup(){ pinMode(pwm_izdo,OUTPUT); pinMode(IN1,OUTPUT); pinMode(IN2,OUTPUT); Serial.begin(9600); pinMode(encoder_izdo, INPUT); attachInterrupt(0, contador, RISING); //Configuraci\u00f3n de la interrupci\u00f3n 0 pulsos_leidos = 0; rpm_izdo = 0; tiempo_anterior = 0; Serial.println(\"MOTOR IZQUIERDO:\"); Serial.print(\"Segundos - \"); Serial.print(\"RPM - \"); Serial.print(\"Pulsos leidos - \"); Serial.println(\"Velocidad (Km/h)\"); Serial.println(\"======== === ============= ================\"); } void loop(){ if (millis() - tiempo_anterior >= 1000){ //Se actualiza cada segundo noInterrupts(); // Desconectamos la interrupci\u00f3n para que no actu\u00e9 en esta parte del programa. digitalWrite(IN1,HIGH); digitalWrite(IN2,LOW); analogWrite(pwm_izdo,255); //a m\u00e1xima velocidad rpm_izdo = (60 * 1000 / muescas )/ (millis() - tiempo_anterior)* pulsos_leidos; //C\u00e1lculo de las revoluciones por minuto vel_izdo = rpm_izdo * 3.1416 * diametro_rueda * 60 / 1000000; //C\u00e1lculo de la vel_izdo en Km/h tiempo_anterior = millis(); //Almacenamos el tiempo actual. Serial.print(\" \"); Serial.print(millis()/1000); Serial.print(\" \"); Serial.print(rpm_izdo,DEC); Serial.print(\" \"); Serial.print(pulsos_leidos,DEC); Serial.print(\" \"); Serial.println(vel_izdo,2); pulsos_leidos = 0; //Inicializamos los pulsos interrupts(); //Reiniciamos la interrupci\u00f3n } } //La funci\u00f3n contador se encarga de contar los pulsos buenos void contador(){ if(digitalRead(encoder_izdo) && (micros()-debounce > 500) && digitalRead (encoder_izdo)){ debounce = micros(); //para comprobar que no contamos rebotes pulsos_leidos++;} //Cuen ta el pulso como bueno } En la imagen siguiente tenemos una captura del terminal serie con los resultados para el encoder izquierdo. Resultados del ejemplo b\u00e1sico para prueba del encoder izquierdo Encoder derecho A continuaci\u00f3n vemos el c\u00f3digo comentado de la prueba que vamos a realizar y que puedes descargar o copiar para grabarlo en tu robot y as\u00ed comprobar que el encoder derecho funciona correctamente. const int pwm_dcho = 11; //pines y variables motor y encoder derecho const int IN3 = 12; const int IN4 = 13; int encoder_dcho = 3; unsigned int rpm_dcho = 0; float vel_dcho = 0; //en Km/h volatile byte pulsos_leidos = 0; // N\u00famero de pulsos leidos en un segundo unsigned long tiempo_anterior = 0; // Tiempo unsigned int muescas = 20; //n\u00famero de muescas del disco del encoder. const int diametro_rueda = 75; //Di\u00e1metro de las ruedas en mm static volatile unsigned long debounce = 0; //Tiempo del rebote. void setup(){ pinMode(pwm_dcho,OUTPUT); pinMode(IN3,OUTPUT); pinMode(IN4,OUTPUT); Serial.begin(9600); pinMode(encoder_dcho, INPUT); attachInterrupt(1, contador, RISING); //Configuraci\u00f3n de la interrupci\u00f3n 1 pulsos_leidos = 0; rpm_dcho = 0; tiempo_anterior = 0; Serial.println(\"MOTOR DERECHO:\"); Serial.print(\"Segundos - \"); Serial.print(\"RPM - \"); Serial.print(\"Pulsos leidos - \"); Serial.println(\"Velocidad (Km/h)\"); Serial.println(\"======== === ============= ================\"); } void loop(){ if (millis() - tiempo_anterior >= 1000){ //Se actualiza cada segundo noInterrupts(); // Desconectamos la interrupci\u00f3n para que no actu\u00e9 en esta parte del programa. digitalWrite(IN3,HIGH); digitalWrite(IN4,LOW); analogWrite(pwm_dcho,255); //a m\u00e1xima velocidad rpm_dcho = (60 * 1000 / muescas )/ (millis() - tiempo_anterior)* pulsos_leidos; //C\u00e1lculo de las revoluciones por minuto vel_dcho = rpm_dcho * 3.1416 * diametro_rueda * 60 / 1000000; //C\u00e1lculo de la vel_dcho en Km/h tiempo_anterior = millis(); //Almacenamos el tiempo actual. Serial.print(\" \"); Serial.print(millis()/1000); Serial.print(\" \"); Serial.print(rpm_dcho,DEC); Serial.print(\" \"); Serial.print(pulsos_leidos,DEC); Serial.print(\" \"); Serial.println(vel_dcho,2); pulsos_leidos = 0; //Inicializamos los pulsos interrupts(); //Reiniciamos la interrupci\u00f3n } } //La funci\u00f3n contador se encarga de contar los pulsos buenos void contador(){ if(digitalRead(encoder_dcho) && (micros()-debounce > 500) && digitalRead (encoder_dcho)){ debounce = micros(); //para comprobar que no contamos rebotes pulsos_leidos++;} //Cuen ta el pulso como bueno } En la imagen siguiente tenemos una captura del terminal serie con los resultados para el encoder derecho. Resultados del ejemplo b\u00e1sico para prueba del encoder derecho","title":"Pruebas b\u00e1sicas de funcionamiento"},{"location":"conexionado-pruebas/UNO/test/#pruebas-basicas-de-funcionamiento","text":"Una vez analizados y conectados los distintos elementos iremos haciendo peque\u00f1os programas bien mediante la aplicaci\u00f3n Masaylo Blockly basada en Blocklino de Fontaine Jean Philippe , y pensada para programar robots utilizando un entorno gr\u00e1fico o de programaci\u00f3n por bloques, o bien utilizando el IDE de Arduino. En el apartado de software se pueden encontrar los enlaces de descarga y toda la informaci\u00f3n de la aplicaci\u00f3n.","title":"Pruebas b\u00e1sicas de funcionamiento"},{"location":"conexionado-pruebas/UNO/test/#alimentacion","text":"Colocamos las pilas AA en su lugar respetando la polaridad de las mismas y accionamos el interruptor. Si todo es correcto en ambas placas se debe encender un diodo LED rojo indicativo de que est\u00e1n alimentadas, tal y como observamos en la imagen siguiente: Primer encendido En este punto vamos a probar tambi\u00e9n que se graba correctamente firmware en la placa UNO a partir de Masaylo Blockly 1.1.1 Beta o posterior . Para ello hemos creado y almacenado el programa blink.bloc que vemos en la imagen siguiente. Programa blink.bloc Si cargamos el programa y dejamos sin accionar el interruptor observaremos como parpadea el LED asociado al pin 13 en la placa UNO pero la placa del driver no est\u00e1 alimentada y por tanto su LED permanece apagado. En la animaci\u00f3n siguiente vemos el parpadeo del LED y el resultado de accionar el interruptor. Animaci\u00f3n que muestra el funcionamiento del programa blink.bloc y del interruptor Este GIF se ha creado a partir de un video en formato mp4 utilizando FFMPEG y GIMP y la informaci\u00f3n obtenida en este enlace .","title":"Alimentaci\u00f3n"},{"location":"conexionado-pruebas/UNO/test/#motores","text":"Vamos a realizar una primera prueba del funcionamiento de los motores a partir de los ejemplos suministrados con la librer\u00eda y disponibles en la aplicaci\u00f3n Masaylo Blockly que estamos usando en estas pruebas de funcionamiento. En la imagen siguiente tenemos cargado el ejemplo Aprende a controlar los movimientos b\u00e1sicos del robot Masaylo y hemos destacado el icono desde el que podemos seleccionarlo de la lista que se abre en una ventana emergente y que al hacer clic nos lo carga en el entorno de la aplicaci\u00f3n. Ejemplo Aprende a controlar los movimientos b\u00e1sicos del robot Masaylo cargado Si conectamos la placa al puerto USB del ordenador y cargamos el ejemplo en la placa, cuando accionemos el interruptor (o con este accionado pulsemos el bot\u00f3n de reset) se producir\u00e1 la secuencia de movimiento establecida en el programa que podemos apreciar en la animaci\u00f3n siguiente. Animaci\u00f3n que muestra el funcionamiento del programa motores-ej1.bloc El ejemplo siguiente est\u00e1 basado en Utiliza PWM para controlar la velocidad de movimientos del Masaylo suministrado con la aplicaci\u00f3n pero ligeramente modificado ( motores-ej2.bloc ) para poner todos los valores de PWM al 50% y todos los retardos a 3 segundos. Ejemplo con control PWM de Masaylo El funcionamiento es muy similar al de la animaci\u00f3n anterior pero a la mitad de velocidad. An\u00edmate y prueba el ejemplo y haz cambios para analizar lo que est\u00e1 ocurriendo.","title":"Motores"},{"location":"conexionado-pruebas/UNO/test/#zumbador","text":"En esta ocasi\u00f3n vamos a programar el robot desde el IDE de Arduino, en concreto utilizando la versi\u00f3n 1.8.13 o posterior. Para la prueba del zumbador vamos a utilizar la informaci\u00f3n que podemos ver en la web de Input makers con el t\u00edtulo Programar melod\u00eda de Star Wars con Arduino y zumbador . El c\u00f3digo que vamos a grabar en la placa lo vemos a continuaci\u00f3n y basta con utilizar el bot\u00f3n copiar para seleccionarlo y ponerlo en el portapapeles desde el que lo podemos llevar al IDE de Arduino. Este bot\u00f3n se hace mas visible al pasar el cursor por el cuadro del c\u00f3digo en la zona superior derecha del mismo. Tambi\u00e9n puedes descargar el programa comprimido haciendo clic en el enlace buzzer-star-wars que puedes descomprimir y utilizar a conveniencia. int pin = 1; // definimos el pin al que conectaremos el zumbador. /* Definimos cada una de las frecuencias de las notas musicales. * Cuando van acompa\u00f1adas de la letra S significa que esa nota es sostenido. * Cuando van acompa\u00f1adas de la letra H significa que esa nota est\u00e1 en una octava superior (High). */ int c=261; int d=294; int e=329; int f=349; int g=391; int gS=415; int a=440; int aS=455; int b=466; int cH=523; int cSH=554; int dH=587; int dSH=622; int eH=659; int fH=698; int fSH=740; int gH=783; int gSH=830; int aH=880; void setup() { pinMode(pin, OUTPUT); // Hacemos que el pin 1 sea salida. } void loop() { /* Utilizamos la funci\u00f3n tone incluida en el IDE con el formato: tone(N\u00ba-pin, nota, duracion) */ tone(pin, a, 500); delay(550); tone(pin, a, 500); delay(550); tone(pin, a, 500); delay(550); tone(pin, f, 350); delay(350); tone(pin, cH, 150); delay(200); tone(pin, a, 500); delay(550); tone(pin, f, 350); delay(350); tone(pin, cH, 150); delay(200); tone(pin, a, 1000); delay(1050); tone(pin, eH, 500); delay(550); tone(pin, eH, 500); delay(550); tone(pin, eH, 500); delay(550); tone(pin, fH, 350); delay(350); tone(pin, cH, 150); delay(200); tone(pin, gS, 500); delay(550); tone(pin, f, 350); delay(350); tone(pin, cH, 150); delay(200); tone(pin, a, 1000); delay(1050); tone(pin, aH, 500); delay(550); tone(pin, a, 350); delay(350); tone(pin, a, 150); delay(200); tone(pin, aH, 500); delay(550); tone(pin, gSH, 250);delay(250); tone(pin, gH, 250); delay(250); tone(pin, fSH, 125);delay(150); tone(pin, fH, 125); delay(150); tone(pin, fSH, 250);delay(250); delay(250); tone(pin, aS, 250); delay(250); tone(pin, dSH, 500);delay(550); tone(pin, dH, 250); delay(250); tone(pin, cSH, 250);delay(250); tone(pin, cH, 125); delay(150); tone(pin, b, 125); delay(150); tone(pin, cH, 250); delay(250); delay(250); tone(pin, f, 125); delay(150); tone(pin, gS, 500); delay(550); tone(pin, f, 375); delay(375+50); tone(pin, a, 125); delay(150); tone(pin, cH, 500); delay(550); tone(pin, a, 375); delay(400); tone(pin, cH, 125); delay(150); tone(pin, eH, 1000);delay(1050); tone(pin, aH, 500); delay(550); tone(pin, a, 350); delay(350); tone(pin, a, 150); delay(200); tone(pin, aH, 500); delay(550); tone(pin, gSH, 250);delay(250); tone(pin, gH, 250); delay(250); tone(pin, fSH, 125);delay(150); tone(pin, fH, 125); delay(150); tone(pin, fSH, 250);delay(250); delay(250); tone(pin, aS, 250); delay(250); tone(pin, dSH, 500);delay(550); tone(pin, dH, 250); delay(250); tone(pin, cSH, 250);delay(250); tone(pin, cH, 125); delay(150); tone(pin, b, 125); delay(150); tone(pin, cH, 250); delay(250); delay(250); tone(pin, f, 250); delay(250); tone(pin, gS, 500); delay(550); tone(pin, f, 375); delay(400); tone(pin, cH, 125); delay(150); tone(pin, a, 500); delay(550); tone(pin, f, 375); delay(400); tone(pin, c, 125); delay(150); tone(pin, a, 1000); delay(1050); delay(5000); } En el video \"prueba del zumbador en Masaylo-CRG\" que tenemos a continuaci\u00f3n podemos escuchar el resultado de grabar el c\u00f3digo anterior en el robot.","title":"Zumbador"},{"location":"conexionado-pruebas/UNO/test/#sensores-de-infrarrojos","text":"Para probar y ajustar los sensores de infrarrojos vamos a realizar un sencillo programa en MasayloBlockly como el que vemos en la imagen siguiente. Ejemplo para prueba de los sensores de infrarrojos Si es necesario retocaremos la posici\u00f3n del cursor del potenciometro de ajuste de sensibilidad teniendo en cuenta que es extremadamente sensible y que debemos dejarlo en una posici\u00f3n tal que al situar el sensor sobre una superficie negra el sensor onboard se apague y cuando lo sacamos del negro se encienda. El programa sensores-IR.bloc es muy sencillo y simplemente comprueba si el sensor izquierdo est\u00e1 sobre negro est\u00e1ndo el derecho sobre blanco, si esta condici\u00f3n es cierta el LED onboard del UNO har\u00e1 un parpadeo que repetir\u00e1 dos veces de forma lenta y nos mostrar\u00e1 un mensaje en el monitor serie. Un proceso similar se realiza con el sensor derecho sobre negro siendo esta vez el parpadeo r\u00e1pido y lo har\u00e1 tres veces. Si ninguno de los sensores detecta negro mostrar\u00e1 el correspondiente mensaje permaneciendo el LED apagado. En la imagen siguiente vemos el resultado que muestra el monitor serie al hacer que los sensores lean negro. Resultados obtenidos con el programa de prueba de los sensores de infrarrojos","title":"Sensores de infrarrojos"},{"location":"conexionado-pruebas/UNO/test/#sensor-de-distancia-hc-sr04","text":"El datasheet del sensor nos indica que debemos generar un pulso de al menos 10us en el pin Trigger o disparador. Si queremos asegurar un trigger bueno podemos poner el pin a nivel bajo durante 4us antes de general el pulso en si. En c\u00f3digo esto es algo como lo siguiente: digitalWrite(Pin_Trigger, LOW); delayMicroseconds(4); digitalWrite(Pin_Trigger, HIGH); delayMicroseconds(10); digitalWrite(Pin_Trigger, LOW); Este c\u00f3digo ya est\u00e1 implementado en la librer\u00eda que se describe en estas notas y, por supuesto lo est\u00e1 en Masaylo Blockly por lo que no debemos preocuparnos por ello. En este caso como ejemplo vamos a utilizar el que viene con la versi\u00f3n 1.1.4 de Masaylo Blockly titulado \"Env\u00eda la distancia al obst\u00e1culo detectado al puerto serie de tu ordenador\" y que podemos ver cargado en la imagen siguiente. Ejemplo \"Env\u00eda la distancia al obst\u00e1culo detectado al puerto serie de tu ordenador\" En la imagen siguiente vemos este mismo ejemplo con la definici\u00f3n de pines que se da en el pinout. Ejemplo \"Env\u00eda la distancia al obst\u00e1culo detectado al puerto serie de tu ordenador\" con A2 y A3 Se puede utilizar una u otra nomenclatura de forma indiferente y en cualquier caso lo que hace el ejemplo es enviarnos al puerto serie la distancia en cent\u00edmetros que est\u00e1 midiendo el sensor una vez por segundo. En la imagen siguiente vemos una ventana con resultados de diferentes distancias medidas por el sensor. Ejemplo \"Env\u00eda la distancia al obst\u00e1culo detectado al puerto serie de tu ordenador\" resultados","title":"Sensor de distancia HC-SR04"},{"location":"conexionado-pruebas/UNO/test/#servomotores","text":"En nuestro caso el robot va dotado de dos servos SG90, uno para accionar el brazo aparta obst\u00e1culos y el otro para accionar la cabeza y que el robot \"mire\" a un lado y otro. Para ambos servos vamos a crear unos programas muy simples que nos sirvan para verificar su funcionamiento. Prueba de funcionamiento del servo de cabeza . Implementamos, o descargamos el programa que vemos en la imagen siguiente: Ejemplo b\u00e1sico de funcionamiento del servo de cabeza En los ejemplos que acompa\u00f1an a la librer\u00eda y que se incluyen en Masaylo Blockly encontramos otras muchas funcionalidades de este servo. En la animaci\u00f3n siguiente vemos el resultado de programar el robot con el ejemplo anterior y como realiza movimientos de izquierda a derecha pasando por la posici\u00f3n central o mirar al frente. Animaci\u00f3n del ejemplo b\u00e1sico de funcionamiento del servo de cabeza Prueba de funcionamiento del servo del brazo . En el caso del brazo hay que tener en cuenta que, si posicionamos la placa UNO como hemos ido viendo en las distintas im\u00e1genes, al grabar este programa (o cualquier otro que trabaje con el servo del brazo) y mientras mantegamos conectado el cable USB, este va a molestar a los movimientos del brazo porque chocar\u00e1 con el mismo. Las opciones que tenemos para evitar que esto ocurra son: girar la placa UNO 180\u00ba sobre la posici\u00f3n indicada hasta ahora retirar el brazo en tanto trabajamos con la conexi\u00f3n USB y colocarlo en el robot para su funcionamiento aut\u00f3nomo colocar el servo junto con el brazo en el otro costado del robot En la imagen siguiente vemos el robot con el servo cambiado de costado. Servo del brazo posicionado a la izquierda Implementamos, o descargamos el programa que vemos en la imagen siguiente: Ejemplo b\u00e1sico de funcionamiento del servo del brazo En los ejemplos que acompa\u00f1an a la librer\u00eda y que se incluyen en Masaylo Blockly encontramos otras muchas funcionalidades de este servo. En la animaci\u00f3n siguiente vemos el resultado de programar el robot con un ejemplo en el que el brazo est\u00e1 colocado en el costado derecho y como realiza movimientos de posicionado del brazo envolviendo al objeto que supuestamente habr\u00eda delante y retracci\u00f3n del brazo a su posici\u00f3n de replegado pasando por la posici\u00f3n central o posici\u00f3n vertical del brazo. Animaci\u00f3n del ejemplo b\u00e1sico de funcionamiento del servo del brazo","title":"Servomotores"},{"location":"conexionado-pruebas/UNO/test/#encoder-infrarrojos-fc-03","text":"Para probar el funcionamiento de los encoders vamos a recurrir de nuevo al IDE 1.8.15 de Arduino montando dos ejemplos totalmente similares pero probando cada encoder por separado. Estos ejemplos est\u00e1n inspirados en la implementaci\u00f3n que se hace de los mismos en el robot Andromina OFF ROAD y los detalles analizados en el blog Andromina robot V.2.0 Posteriormente podremos probar distintos ejemplos integrados en la librer\u00eda que l\u00f3gicamente utilizar\u00e1n ambos encoders simult\u00e1neamente. Encoder izquierdo A continuaci\u00f3n vemos el c\u00f3digo comentado de la prueba que vamos a realizar y que puedes descargar o copiar para grabarlo en tu robot y as\u00ed comprobar que el encoder izquierdo funciona correctamente. const int pwm_izdo = 6; //pines y variables motor y encoder izquierdo const int IN1 = 7; const int IN2 = 8; int encoder_izdo = 2; unsigned int rpm_izdo = 0; float vel_izdo = 0; //en Km/h volatile byte pulsos_leidos = 0; // N\u00famero de pulsos leidos en un segundo unsigned long tiempo_anterior = 0; // Tiempo unsigned int muescas = 20; //n\u00famero de muescas del disco del encoder. const int diametro_rueda = 75; //Di\u00e1metro de las ruedas en mm static volatile unsigned long debounce = 0; //Tiempo del rebote. void setup(){ pinMode(pwm_izdo,OUTPUT); pinMode(IN1,OUTPUT); pinMode(IN2,OUTPUT); Serial.begin(9600); pinMode(encoder_izdo, INPUT); attachInterrupt(0, contador, RISING); //Configuraci\u00f3n de la interrupci\u00f3n 0 pulsos_leidos = 0; rpm_izdo = 0; tiempo_anterior = 0; Serial.println(\"MOTOR IZQUIERDO:\"); Serial.print(\"Segundos - \"); Serial.print(\"RPM - \"); Serial.print(\"Pulsos leidos - \"); Serial.println(\"Velocidad (Km/h)\"); Serial.println(\"======== === ============= ================\"); } void loop(){ if (millis() - tiempo_anterior >= 1000){ //Se actualiza cada segundo noInterrupts(); // Desconectamos la interrupci\u00f3n para que no actu\u00e9 en esta parte del programa. digitalWrite(IN1,HIGH); digitalWrite(IN2,LOW); analogWrite(pwm_izdo,255); //a m\u00e1xima velocidad rpm_izdo = (60 * 1000 / muescas )/ (millis() - tiempo_anterior)* pulsos_leidos; //C\u00e1lculo de las revoluciones por minuto vel_izdo = rpm_izdo * 3.1416 * diametro_rueda * 60 / 1000000; //C\u00e1lculo de la vel_izdo en Km/h tiempo_anterior = millis(); //Almacenamos el tiempo actual. Serial.print(\" \"); Serial.print(millis()/1000); Serial.print(\" \"); Serial.print(rpm_izdo,DEC); Serial.print(\" \"); Serial.print(pulsos_leidos,DEC); Serial.print(\" \"); Serial.println(vel_izdo,2); pulsos_leidos = 0; //Inicializamos los pulsos interrupts(); //Reiniciamos la interrupci\u00f3n } } //La funci\u00f3n contador se encarga de contar los pulsos buenos void contador(){ if(digitalRead(encoder_izdo) && (micros()-debounce > 500) && digitalRead (encoder_izdo)){ debounce = micros(); //para comprobar que no contamos rebotes pulsos_leidos++;} //Cuen ta el pulso como bueno } En la imagen siguiente tenemos una captura del terminal serie con los resultados para el encoder izquierdo. Resultados del ejemplo b\u00e1sico para prueba del encoder izquierdo Encoder derecho A continuaci\u00f3n vemos el c\u00f3digo comentado de la prueba que vamos a realizar y que puedes descargar o copiar para grabarlo en tu robot y as\u00ed comprobar que el encoder derecho funciona correctamente. const int pwm_dcho = 11; //pines y variables motor y encoder derecho const int IN3 = 12; const int IN4 = 13; int encoder_dcho = 3; unsigned int rpm_dcho = 0; float vel_dcho = 0; //en Km/h volatile byte pulsos_leidos = 0; // N\u00famero de pulsos leidos en un segundo unsigned long tiempo_anterior = 0; // Tiempo unsigned int muescas = 20; //n\u00famero de muescas del disco del encoder. const int diametro_rueda = 75; //Di\u00e1metro de las ruedas en mm static volatile unsigned long debounce = 0; //Tiempo del rebote. void setup(){ pinMode(pwm_dcho,OUTPUT); pinMode(IN3,OUTPUT); pinMode(IN4,OUTPUT); Serial.begin(9600); pinMode(encoder_dcho, INPUT); attachInterrupt(1, contador, RISING); //Configuraci\u00f3n de la interrupci\u00f3n 1 pulsos_leidos = 0; rpm_dcho = 0; tiempo_anterior = 0; Serial.println(\"MOTOR DERECHO:\"); Serial.print(\"Segundos - \"); Serial.print(\"RPM - \"); Serial.print(\"Pulsos leidos - \"); Serial.println(\"Velocidad (Km/h)\"); Serial.println(\"======== === ============= ================\"); } void loop(){ if (millis() - tiempo_anterior >= 1000){ //Se actualiza cada segundo noInterrupts(); // Desconectamos la interrupci\u00f3n para que no actu\u00e9 en esta parte del programa. digitalWrite(IN3,HIGH); digitalWrite(IN4,LOW); analogWrite(pwm_dcho,255); //a m\u00e1xima velocidad rpm_dcho = (60 * 1000 / muescas )/ (millis() - tiempo_anterior)* pulsos_leidos; //C\u00e1lculo de las revoluciones por minuto vel_dcho = rpm_dcho * 3.1416 * diametro_rueda * 60 / 1000000; //C\u00e1lculo de la vel_dcho en Km/h tiempo_anterior = millis(); //Almacenamos el tiempo actual. Serial.print(\" \"); Serial.print(millis()/1000); Serial.print(\" \"); Serial.print(rpm_dcho,DEC); Serial.print(\" \"); Serial.print(pulsos_leidos,DEC); Serial.print(\" \"); Serial.println(vel_dcho,2); pulsos_leidos = 0; //Inicializamos los pulsos interrupts(); //Reiniciamos la interrupci\u00f3n } } //La funci\u00f3n contador se encarga de contar los pulsos buenos void contador(){ if(digitalRead(encoder_dcho) && (micros()-debounce > 500) && digitalRead (encoder_dcho)){ debounce = micros(); //para comprobar que no contamos rebotes pulsos_leidos++;} //Cuen ta el pulso como bueno } En la imagen siguiente tenemos una captura del terminal serie con los resultados para el encoder derecho. Resultados del ejemplo b\u00e1sico para prueba del encoder derecho","title":"Encoder infrarrojos FC-03"},{"location":"libreria/ejemplos/","text":"Ejemplos de Masaylo \u00b6 La librer\u00eda de Masaylo incorpora una serie de ejemplos para poder aplicar al robot de forma directa, para ello vamos al men\u00fa Archivo > Ejemplos > Masaylo, y escogemos el ejemplo que nos interese. Ejemplos de Masaylo","title":"Ejemplos de Masaylo"},{"location":"libreria/ejemplos/#ejemplos-de-masaylo","text":"La librer\u00eda de Masaylo incorpora una serie de ejemplos para poder aplicar al robot de forma directa, para ello vamos al men\u00fa Archivo > Ejemplos > Masaylo, y escogemos el ejemplo que nos interese. Ejemplos de Masaylo","title":"Ejemplos de Masaylo"},{"location":"libreria/incorporar_libreria/","text":"Incorporar la librer\u00eda en un programa \u00b6 El siguiente paso es que las instrucciones para controlar nuestro robot, que est\u00e1n dentro de la librer\u00eda, est\u00e9n disponibles, por eso debemos incluir la librer\u00eda en nuestro c\u00f3digo, para ello: Men\u00fa Programa > Incluir librer\u00eda > Masaylo Escoger la librer\u00eda una vez instalada En el c\u00f3digo aparecen en las dos primeras l\u00edneas: #include <Encoder.h> #include <Masaylo.h> Estas dos l\u00edneas de c\u00f3digo son las que incorporan la librer\u00eda a nuestro programa para poder controlar el robot. Librer\u00eda incorporada","title":"Incorporaci\u00f3n de la librer\u00eda en un programa"},{"location":"libreria/incorporar_libreria/#incorporar-la-libreria-en-un-programa","text":"El siguiente paso es que las instrucciones para controlar nuestro robot, que est\u00e1n dentro de la librer\u00eda, est\u00e9n disponibles, por eso debemos incluir la librer\u00eda en nuestro c\u00f3digo, para ello: Men\u00fa Programa > Incluir librer\u00eda > Masaylo Escoger la librer\u00eda una vez instalada En el c\u00f3digo aparecen en las dos primeras l\u00edneas: #include <Encoder.h> #include <Masaylo.h> Estas dos l\u00edneas de c\u00f3digo son las que incorporan la librer\u00eda a nuestro programa para poder controlar el robot. Librer\u00eda incorporada","title":"Incorporar la librer\u00eda en un programa"},{"location":"libreria/instalacion/","text":"Instalaci\u00f3n de la librer\u00eda para Arduino \u00b6 La librer\u00eda se instala como cualquier librer\u00eda de arduino: Descargamos la Librer\u00eda . Abrimos el IDE de Arduino (entorno de desarrollo de Arduino). Para instalarlo si no lo tienes, lo puedes descargar en la direcci\u00f3n: https://www.arduino.cc/en/software Nos dirigimos al Men\u00fa Programa > Incluir librer\u00eda > A\u00f1adir biblioteca .ZIP ... Incluir librer\u00eda a\u00f1adir .zip En la siguiente ventana elegimos la ruta de la biblioteca o librer\u00eda a instalar, que en nuestro caso es Masaylo.zip, habr\u00e1 que recordar d\u00f3nde la descargamos previamente. Incluir librer\u00eda elegir .zip","title":"Instalaci\u00f3n"},{"location":"libreria/instalacion/#instalacion-de-la-libreria-para-arduino","text":"La librer\u00eda se instala como cualquier librer\u00eda de arduino: Descargamos la Librer\u00eda . Abrimos el IDE de Arduino (entorno de desarrollo de Arduino). Para instalarlo si no lo tienes, lo puedes descargar en la direcci\u00f3n: https://www.arduino.cc/en/software Nos dirigimos al Men\u00fa Programa > Incluir librer\u00eda > A\u00f1adir biblioteca .ZIP ... Incluir librer\u00eda a\u00f1adir .zip En la siguiente ventana elegimos la ruta de la biblioteca o librer\u00eda a instalar, que en nuestro caso es Masaylo.zip, habr\u00e1 que recordar d\u00f3nde la descargamos previamente. Incluir librer\u00eda elegir .zip","title":"Instalaci\u00f3n de la librer\u00eda para Arduino"},{"location":"libreria/motores/","text":"Controlar motores de Masaylo \u00b6 Lo primero que debemos hacer es crear un objeto tipo robot Masaylo, para ello pondremos la l\u00ednea antes de void setup(), Masaylo objetoMasaylo , en nuestro caso Masaylo m (nuestro robot Masaylo se llama m). Crear objeto Masaylo En la funci\u00f3n setup(), ya sab\u00e9is que se ejecuta una s\u00f3la vez, vamos a definir los pines de los motores se puede hacer de dos maneras: Sin pasar par\u00e1metros (sin colocar nada entre los par\u00e9ntesis), objetoMasaylo.init() , en nuestro caso de ejemplo m.init() : con esta orden indicamos que los pines de los motores son los que trae por defecto objetoMasaylo.init(6,7,8,11,12,13) , siendo el orden de los pines definidos de izquierda a derecha, pin de control de velocidad de giro (PWM) del motor izquierdo, pin A del motor izquierdo, pin B del motor izquierdo, pin de control de velocidad de giro (PWM) del motor derecho, pin A del motor derecho, pin B del motor derecho. Pasando par\u00e1metros de pines (coloc\u00e1ndolos entre par\u00e9ntesis), objetoMasaylo.init (pinPWMMotorIzdo,pinAMotorIzdo,pinBMotorIzdo,pinPWMMotorDcho,pinAMotorDcho,pinBMotorDcho) , de esta manera podr\u00edamos conectar nuestros motores a los pines que deseemos, un ejemplo de podr\u00eda ser m.init(6,7,8,11,12,13). Pasamos a explicar las instrucciones para mover el robot: objetoMasaylo.adelante (velocidad) : Mueve el robot Masaylo hacia delante, le podemos pasar el valor de la velocidad a la que lo hace (entre 0 y 255), si no pasamos valor, par\u00e9ntesis sin valor, lo hace a 255. En nuestro caso del ejemplo m.adelante() . objetoMasaylo.atras (velocidad) : Mueve el robot Masaylo hacia atr\u00e1s, le podemos pasar el valor de la velocidad a la que lo hace (entre 0 y 255), si no pasamos valor, par\u00e9ntesis sin valor, lo hace a 255. En nuestro caso del ejemplo m.atras() . objetoMasaylo.izquierda (velocidad) : Gira (pivota) el robot Masaylo hacia la izquierda, le podemos pasar el valor de la velocidad a la que lo hace (entre 0 y 255), si no pasamos valor, par\u00e9ntesis sin valor, lo hace a 255. En nuestro caso del ejemplo m.izquierda() . objetoMasaylo.derecha (velocidad) : Gira (pivota) el robot Masaylo hacia la derecha, le podemos pasar el valor de la velocidad a la que lo hace (entre 0 y 255), si no pasamos valor, par\u00e9ntesis sin valor, lo hace a 255. En nuestro caso del ejemplo m.derecha() . objetoMasaylo.alto () : Para el robot Masaylo. En nuestro caso del ejemplo m.alto() . A continuaci\u00f3n vemos estas \u00f3rdenes reflejadas en el ejemplo 01 de la librer\u00eda: Ejemplo 01 de la librer\u00eda En el ejemplo 02 vemos como se pasan valores a la velocidad a los movimientos de nuestro robot: Ejemplo 02 de la librer\u00eda","title":"Control de motores"},{"location":"libreria/motores/#controlar-motores-de-masaylo","text":"Lo primero que debemos hacer es crear un objeto tipo robot Masaylo, para ello pondremos la l\u00ednea antes de void setup(), Masaylo objetoMasaylo , en nuestro caso Masaylo m (nuestro robot Masaylo se llama m). Crear objeto Masaylo En la funci\u00f3n setup(), ya sab\u00e9is que se ejecuta una s\u00f3la vez, vamos a definir los pines de los motores se puede hacer de dos maneras: Sin pasar par\u00e1metros (sin colocar nada entre los par\u00e9ntesis), objetoMasaylo.init() , en nuestro caso de ejemplo m.init() : con esta orden indicamos que los pines de los motores son los que trae por defecto objetoMasaylo.init(6,7,8,11,12,13) , siendo el orden de los pines definidos de izquierda a derecha, pin de control de velocidad de giro (PWM) del motor izquierdo, pin A del motor izquierdo, pin B del motor izquierdo, pin de control de velocidad de giro (PWM) del motor derecho, pin A del motor derecho, pin B del motor derecho. Pasando par\u00e1metros de pines (coloc\u00e1ndolos entre par\u00e9ntesis), objetoMasaylo.init (pinPWMMotorIzdo,pinAMotorIzdo,pinBMotorIzdo,pinPWMMotorDcho,pinAMotorDcho,pinBMotorDcho) , de esta manera podr\u00edamos conectar nuestros motores a los pines que deseemos, un ejemplo de podr\u00eda ser m.init(6,7,8,11,12,13). Pasamos a explicar las instrucciones para mover el robot: objetoMasaylo.adelante (velocidad) : Mueve el robot Masaylo hacia delante, le podemos pasar el valor de la velocidad a la que lo hace (entre 0 y 255), si no pasamos valor, par\u00e9ntesis sin valor, lo hace a 255. En nuestro caso del ejemplo m.adelante() . objetoMasaylo.atras (velocidad) : Mueve el robot Masaylo hacia atr\u00e1s, le podemos pasar el valor de la velocidad a la que lo hace (entre 0 y 255), si no pasamos valor, par\u00e9ntesis sin valor, lo hace a 255. En nuestro caso del ejemplo m.atras() . objetoMasaylo.izquierda (velocidad) : Gira (pivota) el robot Masaylo hacia la izquierda, le podemos pasar el valor de la velocidad a la que lo hace (entre 0 y 255), si no pasamos valor, par\u00e9ntesis sin valor, lo hace a 255. En nuestro caso del ejemplo m.izquierda() . objetoMasaylo.derecha (velocidad) : Gira (pivota) el robot Masaylo hacia la derecha, le podemos pasar el valor de la velocidad a la que lo hace (entre 0 y 255), si no pasamos valor, par\u00e9ntesis sin valor, lo hace a 255. En nuestro caso del ejemplo m.derecha() . objetoMasaylo.alto () : Para el robot Masaylo. En nuestro caso del ejemplo m.alto() . A continuaci\u00f3n vemos estas \u00f3rdenes reflejadas en el ejemplo 01 de la librer\u00eda: Ejemplo 01 de la librer\u00eda En el ejemplo 02 vemos como se pasan valores a la velocidad a los movimientos de nuestro robot: Ejemplo 02 de la librer\u00eda","title":"Controlar motores de Masaylo"},{"location":"libreria/por_que/","text":"El por qu\u00e9 de la librer\u00eda \u00b6 Unos de los problemas para controlar robots muchas veces es la ausencia de instrucciones amigables en arduino para controlar sus elementos (motores dc, sensor de ultrasonidos, sensores infrarrojos para seguir l\u00edneas, control de distancias y giros a trav\u00e9s de encoders, servomotores y zumbadores), todo ello pensando en el acercamiento del uso de dicho robot para estudiantes de secundaria. Por este motivo desde el Club de Rob\u00f3tica Granada con la colaboraci\u00f3n de Antonio G\u00f3mez nos planteamos adaptar la librer\u00eda de su robot Masaylo para el control de una revisi\u00f3n de dicho robot.","title":"Por qu\u00e9 de la librer\u00eda"},{"location":"libreria/por_que/#el-por-que-de-la-libreria","text":"Unos de los problemas para controlar robots muchas veces es la ausencia de instrucciones amigables en arduino para controlar sus elementos (motores dc, sensor de ultrasonidos, sensores infrarrojos para seguir l\u00edneas, control de distancias y giros a trav\u00e9s de encoders, servomotores y zumbadores), todo ello pensando en el acercamiento del uso de dicho robot para estudiantes de secundaria. Por este motivo desde el Club de Rob\u00f3tica Granada con la colaboraci\u00f3n de Antonio G\u00f3mez nos planteamos adaptar la librer\u00eda de su robot Masaylo para el control de una revisi\u00f3n de dicho robot.","title":"El por qu\u00e9 de la librer\u00eda"},{"location":"libreria/ultrasonidos/","text":"Ultrasonidos y masaylo \u00b6 Masaylo incorpora un sensor de ultrasonidos en su parte delantera, que nos servir\u00e1 para medir distancias a los objetos que pueda encontrar en su camino. Las \u00f3rdenes que tenemos para controlar el sensor de ultrasonidos son: objetoMasaylo.ultrasonidos (pinTrigger,pinEcho) : Configura los pines trigger y echo del sensor de ultrasonidos. Si no pasas par\u00e1metros objetoMasaylo.ultrasonidos() , pone los valores objetoMasaylo.ultrasonidos(16,17) , esta instrucci\u00f3n debe estar en el setup de nuestro programa. En nuestro caso del ejemplo m.ultrasonidos (16,17) . objetoMasaylo.distancia () : Nos devuelve la distancia en cm del sensor de ultrasonidos a el objeto que tenga enfrentado. En nuestro caso del ejemplo m.distancia() . En el ejemplo que presentamos a continuaci\u00f3n se configura el sensor de ultrasonidos, para mostrar por el puerto serie la distancia a la que se encuentra un objeto enfrentado al robot masaylo. Ultrasonidos","title":"Ultrasonidos"},{"location":"libreria/ultrasonidos/#ultrasonidos-y-masaylo","text":"Masaylo incorpora un sensor de ultrasonidos en su parte delantera, que nos servir\u00e1 para medir distancias a los objetos que pueda encontrar en su camino. Las \u00f3rdenes que tenemos para controlar el sensor de ultrasonidos son: objetoMasaylo.ultrasonidos (pinTrigger,pinEcho) : Configura los pines trigger y echo del sensor de ultrasonidos. Si no pasas par\u00e1metros objetoMasaylo.ultrasonidos() , pone los valores objetoMasaylo.ultrasonidos(16,17) , esta instrucci\u00f3n debe estar en el setup de nuestro programa. En nuestro caso del ejemplo m.ultrasonidos (16,17) . objetoMasaylo.distancia () : Nos devuelve la distancia en cm del sensor de ultrasonidos a el objeto que tenga enfrentado. En nuestro caso del ejemplo m.distancia() . En el ejemplo que presentamos a continuaci\u00f3n se configura el sensor de ultrasonidos, para mostrar por el puerto serie la distancia a la que se encuentra un objeto enfrentado al robot masaylo. Ultrasonidos","title":"Ultrasonidos y masaylo"}]}